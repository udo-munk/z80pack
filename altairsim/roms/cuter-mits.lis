Z80-Macro-Assembler  Release 1.11-dev	Wed Nov  2 17:51:45 2022

LOC   OBJECT CODE   LINE   STMT SOURCE CODE
                       1      1 ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
                       2      2 ;
                       3      3 ; CUTER - MODIFIED TO USE MITS CARDS IN ALTAIR 8800
                       4      4 ;
                       5      5 ; PSEUDO DEVICE 0, CONSOLE: VDM-1 AT C8/CC00, KBD AT 4/5
                       6      6 ; PSEUDO DEVICE 1, SERIAL:  MITS SIO REV. 1 AT 0/1
                       7      7 ; PSEUDO DEVICE 2, SERIAL:  MITS 2SIO CHANNEL B AT 18/19
                       8      8 ;
                       9      9 ; TAPE I/O MODIFIED TO USE MITS ACR SIO AT 6/7
                      10     10 ;
                      11     11 ; 03/02/2017 UDO MUNK    FIRST VERSION FOR RELEASE
                      12     12 ; 03/23/2017 UDO MUNK    USE MITS 2SIO CHANNEL B FOR PSEUDO 2
                      13     13 ; 03/27/2017 UDO MUNK    USE MITS ACR SIO FOR TAPE I/O
                      14     14 ; 06/27/2017 UDO MUNK    DON'T CLEAR TO EOL FOR CR, JUST ADVANCE LINE
                      15     15 ;
                      16     16 ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
                      17     17 ;
                      18     18 ;
                      19     19 ;
                      20     20 ;        CUTER(TM)
                      21     21 ;
                      22     22 ;                 COPYRIGHT (C) 1977
                      23     23 ;                 SOFTWARE TECHNOLOGY CORP.
                      24     24 ;                 P.O. BOX 5260
                      25     25 ;                 SAN MATEO, CA 94402
                      26     26 ;                 (415) 349-8080
                      27     27 ;
                      28     28 ;    A L L    R I G H T S   R E S E R V E D ! ! !
                      29     29 ;
                      30     30 ;
                      31     31 ;        VERSION  1.3
                      32     32 ;                 77-03-27
                      33     33 ;
                      34     34 ;
                      35     35 ;  THIS PROGRAM IS DESIGNED TO BE A STANDALONE CUTS
                      36     36 ;  OPERATING SYSTEM. CUTER IS DESIGNED TO BE READ IN FROM
                      37     37 ;  CASSETTE TAPE OR TO BE RESIDENT IN READ-ONLY-MEMORY.
                      38     38 ;  CUTER SUPPORTS VARIOUS DEVICES INCLUDING SERIAL,
                      39     39 ;  PARALLEL, THE PROCESSOR TECHNOLOGY VDM(TM) AND UP TO
                      40     40 ;  TWO CUTS TAPE DRIVES.
                      41     41 ;
                      42     42 ;  CUTER(TM) HAS BEEN WRITTEN SO AS TO BE COMPATIBLE WITH
                      43     43 ;  SOLOS(TM).  THE FOLLOWING KEYS ARE USED BY CUTER(TM)
                      44     44 ;  IN PLACE OF THE SPECIAL KEYS ON THE SOL KEYBOARD:
                      45     45 ;
                      46     46 ;     CURSOR UP       CTL-W
                      47     47 ;     CURSOR LEFT     CTL-A
                      48     48 ;     CURSOR RIGHT    CTL-S
                      49     49 ;     CURSOR DOWN     CTL-Z
                      50     50 ;     CURSOR HOME     CTL-N
                      51     51 ;     CLEAR SCREEN    CTL-K
                      52     52 ;     MODE            CTL-@
                      53     53 ;
                      54     54 ;
                      55     55 ;
                      56     56         ORG     0C000H
                      57     57 ;
                      58     58 ;
                      59     59 ;   AUTO-STARTUP CODE
                      60     60 ;
c000  7f              61     61 START:  MOV     A,A     ;SHOW THIS IS CUTER (SOLOS=00)
                      62     62 ;      THIS BYTE ALLOWS AUTOMATIC POWER ON ENTRY
                      63     63 ;      WHEN IN ROM SUPPORTING THIS HARDWARE FEATURE.
c001  c3 d7 c1        64     64 INIT:   JMP     STRTA   ;SYSTEM RESTART ENTRY POINT
                      65     65 ;
                      66     66 ;   THESE JUMP POINTS ARE PROVIDED TO ALLOW COMMON ENTRY
                      67     67 ; LOCATIONS FOR ALL VERSIONS OF CUTER.  THEY ARE USED
                      68     68 ; EXTENSIVELY BY CUTS SYSTEM PROGRAMS AND IT IS RECOMMENDED
                      69     69 ; THAT USER ROUTINES ACCESS CUTER ROUTINES THROUGH THESE
                      70     70 ; POINTS ONLY!
                      71     71 ;
c004  c3 18 c2        72     72 RETRN:  JMP     COMND   ;RETURN TO CUTER COMMAND PROCESSOR
c007  c3 dc c5        73     73 FOPEN:  JMP     BOPEN   ;CASSETTE OPEN FILE ENTRY
c00a  c3 ff c5        74     74 FCLOS:  JMP     PCLOS   ;CASSETTE CLOSE FILE ENTRY
c00d  c3 42 c6        75     75 RDBYT:  JMP     RTBYT   ;CASSETTE READ BYTE ENTRY
c010  c3 7f c6        76     76 WRBYT:  JMP     WTBYT   ;CASSETTE WRITE BYTE ENTRY
c013  c3 c7 c6        77     77 RDBLK:  JMP     RTAPE   ;CASSETTE READ BLOCK ENTRY
c016  c3 7c c7        78     78 WRBLK:  JMP     WTAPE   ;CASSETTE WRITE BLOCK ENTRY
                      79     79 ;
                      80     80 ;     SYSTEM I/O ENTRY POINTS
                      81     81 ;
                      82     82 ;  THESE FOUR ENTRY POINTS ARE USED TO EITHER INPUT
                      83     83 ;  OR OUTPUT TO CUTER PSUEDO PORTS.
                      84     84 ;  THESE PSUEDO PORTS ARE AS FOLLOWS:
                      85     85 ;
                      86     86 ;  PORT   INPUT              OUTPUT
                      87     87 ;  ----   -----------------  ---------------------
                      88     88 ;   0     KEYBOARD INPUT     BUILT-IN VDM DRIVER
                      89     89 ;         ACTUAL PORT 3      PORT C8, MEMORY FROM CC00
                      90     90 ;   1     SERIAL PORT        SERIAL PORT
                      91     91 ;         ACTUAL PORT 1      ACTUAL PORT 1
                      92     92 ;   2     PARALLEL PORT      PARALLEL PORT
                      93     93 ;         ACTUAL PORT 2      ACTUAL PORT 2
                      94     94 ;   3     USER'S INPUT RTN   USER'S OUTPUT ROUTINE
                      95     95 ;
                      96     96 ;  STATUS FOR ACTUAL PORTS 1, 2 AND 3 IS VIA ACTUAL
                      97     97 ;  PORT 0.  THE BITS OF PORT ZERO ARE DEFINED AS FOLLOWS:
                      98     98 ;
                      99     99 ;   :     :     :     :     :     :---- : --- : --- :
                     100    100 ;   : TBE : RDA :     :     :     :PXDR : PDR : KDR :
                     101    101 ; BIT  7     6     5     4     3     2     1     0
                     102    102 ;
                     103    103 ;  WHERE:
                     104    104 ;    TBE    1=TRANSMITTER BUFFER EMPTY (SERIAL)
                     105    105 ;    RDA    1=READER DATA AVAILABLE (SERIAL)
                     106    106 ;    ----
                     107    107 ;    PXDR   0=PARALLEL EXTERNAL DEVICE READY
                     108    108 ;    ---
                     109    109 ;    PDR    0=PARALLEL DATA READY
                     110    110 ;    ---
                     111    111 ;    KDR    0=KEYBOARD DATA READY
                     112    112 ;
                     113    113 ;
                     114    114 ;
                     115    115 ;
                     116    116 ;  NOTE: SOUT AND SINP ARE "LDA" INSTRUCTIONS.
                     117    117 ;        THIS FACT IS USED TO ALLOW ACCESS TO THE
                     118    118 ;        BYTES "OPORT" AND "IPORT" DYNAMICALLY.
                     119    119 ;        THESE MUST REMAIN "LDA" INSTRUCTIONS!!!!!
                     120    120 ;
c019  3a 07 c8       121    121 SOUT:   LDA     OPORT   ;OUTPUT VIA STANDARD OUTPUT PSUEDO PORT
c01c  c3 2e c0       122    122 AOUT:   JMP     OUTPR   ;OUTPUT VIA PSUEDO PORT SPECIFIED IN REG A
c01f  3a 06 c8       123    123 SINP:   LDA     IPORT   ;INPUT VIA STANDARD INPUT PSUEDO PORT
c022  =              124    124 AINP    EQU     $       ;INPUT VIA PSUEDO PORT SPECIFIED IN REG A
                     125    125 ; -----------END OF SYSTEM ENTRY POINTS----------
                     126    126 ;
                     127    127 ;
                     128    128 ; AINP CONTINUES HERE (IT COULD HAVE BEEN A "JMP" THOUGH)
c022  e5             129    129         PUSH    H       ;SAVE HL FM ENTRY
c023  21 09 c3       130    130         LXI     H,ITAB
                     131    131 ;
                     132    132 ;    THIS ROUTINE PROCESSES THE I/O REQUESTS
                     133    133 ;
c026  e6 03          134    134 IOPRC:  ANI     3       ;KEEP REGISTER "A" TO FOUR VALUES
c028  07             135    135         RLC             ;COMPUTE ENTRY ADDRESS
c029  85             136    136         ADD     L
c02a  6f             137    137         MOV     L,A     ;WE HAVE ADDRESS
c02b  c3 87 c2       138    138         JMP     DISPT   ;DISPATCH TO IT
                     139    139 ;
                     140    140 ;
c02e  =              141    141 OUTPR   EQU     $       ;PROCESS OUTPUT REQUESTS
c02e  e5             142    142         PUSH    H       ;SAVE REGS
c02f  21 01 c3       143    143         LXI     H,OTAB  ;POINT TO OUTPUT DISPATCH TABLE
c032  c3 26 c0       144    144         JMP     IOPRC   ;DISPATCH FOR PROPER PSUEDO PORT
                     145    145 ;
                     146    146 ;
                     147    147 ;
                     148    148 ; CUTER SYSTEM I/O ROUTINES
                     149    149 ;
                     150    150 ;
                     151    151 ;    THIS ROUTINE IS A MODEL OF ALL INPUT ROUTINES WITHIN
                     152    152 ;  CUTER.  THE FIRST ROUTINE "KREA1" PERFORMS THE INPUT
                     153    153 ;  FROM THE STANDARD KEYBOARD ON PARALLEL PORT 3.
                     154    154 ;  ALL STANDARD INPUT DRIVERS RETURN EITHER THE CHARACTER
                     155    155 ;  WITH A NON-ZERO FLAG, OR JUST A ZERO FLAG INDICATING
                     156    156 ;  THAT NO CHARACTER IS AVAILABLE YET.  IT WILL BE THE
                     157    157 ;  RESPONSIBILITY OF THE USER TO LOOP WAITING FOR A
                     158    158 ;  CHARACTER, OR TO USE THE INPUT AS A STATUS REQUEST.
                     159    159 ;  WHEN A CHARACTER IS AVAILABLE, IT IS RETURNED IN REG A.
                     160    160 ;
                     161    161 ;  THE FOLLOWING KEYBOARD ROUTINE MAY BE USED AS A SAMPLE
                     162    162 ;  OF HOW TO WRITE A USER INPUT ROUTINE.
                     163    163 ;
                     164    164 ;         KEYBOARD INPUT ROUTINE
                     165    165 ;
                     166    166 ; MODIFIED SO THAT KBD STATUS PORT CAN BE DIFFERENT FROM SIO STATUS PORT
                     167    167 ; UDO MUNK
                     168    168 ;
c035  =              169    169 KREA1   EQU     $       ;KEYBOARD READ ROUTINE
                     170    170 ;       IN      STAPT   ;GET STATUS WORD
c035  db 04          171    171         IN      STKBD   ;*UM*
c037  2f             172    172         CMA             ;INVERT IT FOR PROPER RETURN
c038  e6 01          173    173         ANI     KDR     ;TEST NOT KEYBOARD DATA READY
c03a  c8             174    174         RZ              ;ZERO IF NO CHARACTER RECEIVED
                     175    175 ;
c03b  db 05          176    176         IN      KDATA   ;GET CHARACTER
c03d  c9             177    177         RET             ;GO BACK WITH IT
                     178    178 ;
                     179    179 ;
                     180    180 ;
                     181    181 ;   SERIAL INPUT ROUTINE
                     182    182 ;
c03e  =              183    183 SREA1   EQU     $       ;SERIAL INPUT ROUTINE
c03e  db 00          184    184         IN      STAPT   ;GET STATUS
c040  2f             185    185         CMA             ;*UM* MITS SIO FLAGS ARE ACTIVE LOW
c041  e6 01          186    186         ANI     SDR     ;TEST FOR SERIAL DATA READY
c043  c8             187    187         RZ              ;FLAGS ARE SET
                     188    188 ;
c044  db 01          189    189         IN      SDATA   ;GET DATA BYTE
                     190    190 ;  IT IS UP TO THE CALLER TO STRIP PARITY IF DESIRED
c046  c9             191    191         RET             ;WE HAVE IT
                     192    192 ;
                     193    193 ;
                     194    194 ;   SERIAL DATA OUTPUT
                     195    195 ;
                     196    196 ; MODIFIED SO THAT STATUS BIT CAN BE DEFINED AS ANY BIT
                     197    197 ; UDO MUNK
                     198    198 ;
c047  =              199    199 SEROT   EQU     $       ;SERIAL OUTPUT ROUTINE
c047  db 00          200    200         IN      STAPT   ;GET STATUS
                     201    201 ;        RAL             ;PUT HIGH BIT IN CARRY
                     202    202 ;        JNC     SEROT   ;LOOP UNTIL TRANSMITTER BUFFER IS EMPTY
c049  e6 80          203    203         ANI     STBE    ;*UM*
c04b  c2 47 c0       204    204         JNZ     SEROT   ;*UM*
c04e  78             205    205         MOV     A,B     ;GET THE CHARACTER BACK
c04f  d3 01          206    206         OUT     SDATA   ;SEND IT OUT
c051  c9             207    207         RET             ;AND WE'RE DONE
                     208    208 ;
                     209    209 ;
                     210    210 ; PARALLEL DATA INPUT
                     211    211 ;
                     212    212 ; MODIFIED TO USE 2SIO CHANNEL B
                     213    213 ; UDO MUNK
                     214    214 ;
c052  =              215    215 PARIT   EQU     $       ;GET CHAR FM PARALLEL PORT
                     216    216 ;        IN      STAPT   ;STATUS
                     217    217 ;        CMA             ;INVERT FOR PROPER RETURN
                     218    218 ;        ANI     PDR     ;IS DATA READY?
                     219    219 ;        RZ              ;NO--JUST EXIT
                     220    220 ;        IN      PDATA   ;YES--GET CHAR THEN
                     221    221 ;        RET             ;THEN EXIT
c052  db 12          222    222         IN      SIO2S   ;GET STATUS
c054  e6 01          223    223         ANI     SDR2    ;TEST FOR SERIAL DATA READY
c056  c8             224    224         RZ              ;FLAGS ARE SET
c057  db 13          225    225         IN      SIO2D   ;GET DATA BYTE
c059  c9             226    226         RET             ;WE HAVE IT
                     227    227 ;
                     228    228 ;
                     229    229 ;  PARALLEL DATA OUTPUT ROUTINE
                     230    230 ;
                     231    231 ; MODIFIED TO USE 2SIO CHANNEL B
                     232    232 ; UDO MUNK
                     233    233 ;
c05a  =              234    234 PAROT   EQU     $       ;OUTPUT CHAR TO PARALLEL PORT
                     235    235 ;        IN      STAPT   ;STATUS
                     236    236 ;        ANI     PXDR    ;IS EXTERNAL DEVICE READY?
                     237    237 ;        JNZ     PAROT   ;NO--WAIT TIL IT IS
                     238    238 ;        MOV     A,B     ;GET CHAR
                     239    239 ;        OUT     PDATA   ;SEND DATA NOW
                     240    240 ;        RET             ;DONE
c05a  db 12          241    241         IN      SIO2S   ;GET STATUS
c05c  e6 02          242    242         ANI     STBE2   ;DEVICE READY ?
c05e  ca 5a c0       243    243         JZ      PAROT   ;NO, WAIT
c061  78             244    244         MOV     A,B     ;GET THE CHARACTER BACK
c062  d3 13          245    245         OUT     SIO2D   ;SEND IT OUT
c064  c9             246    246         RET             ;AND WE'RE DONE
                     247    247 ;
                     248    248 ;
                     249    249 ; USER DEFINED INPUT/OUTPUT ROUTINES
c065  =              250    250 ERRIT   EQU     $       ;USER INPUT ROUTINE
c065  e5             251    251         PUSH    H       ;SAVE ORIG HL
c066  2a 00 c8       252    252         LHLD    UIPRT   ;GET USER'S RTN ADDR
c069  c3 70 c0       253    253         JMP     ERRO1   ;MERGE TO VERIFY THE ADDR
                     254    254 ;
c06c  =              255    255 ERROT   EQU     $       ;USER OUTPUT ROUTINE
c06c  e5             256    256         PUSH    H       ;SAVE ORIG HL
c06d  2a 02 c8       257    257         LHLD    UOPRT   ;GET USER'S RTN ADDR
c070  =              258    258 ERRO1   EQU     $       ;WE MERGE HERE TO VFY ADDR
c070  7d             259    259         MOV     A,L     ;ZERO=UNDEFINED
c071  b4             260    260         ORA     H       ;IS IT?
c072  c2 8b c2       261    261         JNZ     DISP1   ;NO--VALID--OFF TO IT
c075  c3 0f c2       262    262         JMP     STRTD   ;RESET I/O PORTS AND BACK TO COMMAND MODE
                     263    263 ;
                     264    264 ;
                     265    265 ;
                     266    266 ;                  VIDEO DISPLAY ROUTINES
                     267    267 ;
                     268    268 ;
                     269    269 ;  THESE ROUTINES ALLOW FOR STANDARD VIDEO TERMINAL
                     270    270 ;  OPERATIONS.  ON ENTRY, THE CHARACTER FOR OUTPUT IS IN
                     271    271 ;  REGISTER B AND ALL REGISTERS ARE UNALTERED ON RETURN.
                     272    272 ;
                     273    273 ;
                     274    274 ;
c078  =              275    275 VDM01   EQU     $       ;VDM OUTPUT DRIVER
c078  e5             276    276         PUSH    H       ;SAVE HL
c079  d5             277    277         PUSH    D       ;SAVE DE
c07a  c5             278    278         PUSH    B
                     279    279 ;
                     280    280 ;  PROCESS ESC SEQUENCE IF ANY
                     281    281 ;
c07b  3a 0c c8       282    282         LDA     ESCFL   ;GET ESCAPE FLAG
c07e  b7             283    283         ORA     A
c07f  c2 87 c1       284    284         JNZ     ESCS    ;IF NON ZERO GO PROCESS THE REST OF THE SEQUENCE
                     285    285 ;
c082  78             286    286         MOV     A,B     ;GET CHAR
c083  e6 7f          287    287         ANI     7FH     ;CLR HI BIT IN CASE
c085  47             288    288         MOV     B,A     ;USE CHAR STRIPPED OF HI BIT FOR COMPATABILITY
c086  ca a0 c0       289    289         JZ      GOBK    ;MAKE A QUICK EXIT FOR A NULL
                     290    290 ;
c089  21 e2 c2       291    291         LXI     H,TBL
c08c  cd a6 c0       292    292         CALL    TSRCH   ;GO PROCESS
                     293    293 ;
c08f  =              294    294 GOBACK  EQU     $       ;RESET CURSOR AND DELAY
c08f  cd 45 c1       295    295         CALL    VDADD   ;GET SCRN ADDR
c092  7e             296    296         MOV     A,M     ;GET CHAR
c093  f6 80          297    297         ORI     80H     ;INVERSE VIDEO
c095  77             298    298         MOV     M,A     ;CURSOR IS NOW THERE
c096  2a 0a c8       299    299         LHLD    SPEED-1 ;GET DELAY SPEED
c099  2c             300    300         INR     L       ;MAKE IT DEFINITELY NON-ZERO
c09a  af             301    301         XRA     A       ;DELAY ENDS WHEN H=ZERO
c09b  2b             302    302 TIMER:  DCX     H       ;LOOP FOR DELAY AMNT
c09c  bc             303    303         CMP     H       ;IS IT DONE YET
c09d  c2 9b c0       304    304         JNZ     TIMER   ;NO--KEEP DELAYING
c0a0  c1             305    305 GOBK:   POP     B
c0a1  d1             306    306         POP     D       ;RESTORE ALL REGISTERS
c0a2  e1             307    307         POP     H
c0a3  c9             308    308         RET             ;EXIT FROM VDMOT
                     309    309 ;
                     310    310 ;
c0a4  =              311    311 NEXT    EQU     $       ;GO TO NEXT CHR
c0a4  23             312    312         INX     H
c0a5  23             313    313         INX     H
                     314    314 ;
                     315    315 ;  THIS ROUTINE SEARCHES FOR A MATCH OF THE CHAR IN "B"
                     316    316 ;  TO THE CHAR IN THE TBL POINTED TO BY HL.
                     317    317 ;
c0a6  7e             318    318 TSRCH:  MOV     A,M     ;GET CHR FROM TABLE
c0a7  b7             319    319         ORA     A       ;SEE IF END OF TBL
c0a8  ca b8 c0       320    320         JZ      CHAR    ;ZERO IS THE LAST
c0ab  b8             321    321         CMP     B       ;TEST THE CHR
c0ac  23             322    322         INX     H       ;POINT FORWARD
c0ad  c2 a4 c0       323    323         JNZ     NEXT
c0b0  e5             324    324         PUSH    H       ;FOUND ONE...SAVE ADDRESS
c0b1  cd 5f c1       325    325         CALL    CREM    ;REMOVE CURSOR
c0b4  e3             326    326         XTHL            ;RESTORE ADDR OF CHAR ENTRY IN TBL
c0b5  c3 87 c2       327    327         JMP     DISPT   ;DISPATCH FOR CURSOR CONTROL
                     328    328 ;
                     329    329 ;
c0b8  =              330    330 CHAR    EQU     $       ;WE HAVE A CHAR
c0b8  78             331    331         MOV     A,B     ;GET CHARACTER
c0b9  fe 7f          332    332         CPI     7FH     ;IS IT A DEL?
c0bb  c8             333    333         RZ              ;GO BACK IF SO
                     334    334 ;
                     335    335 ;
                     336    336 ;
c0bc  cd 45 c1       337    337 OCHAR:  CALL    VDADD   ;GET SCREEN ADDRESS
c0bf  70             338    338         MOV     M,B     ;PUT CHR ON SCREEN
c0c0  3a 08 c8       339    339         LDA     NCHAR   ;GET CHARACTER POSITION
c0c3  fe 3f          340    340         CPI     63      ;END OF LINE?
c0c5  da e5 c0       341    341         JC      OK
c0c8  3a 09 c8       342    342         LDA     LINE
c0cb  fe 0f          343    343         CPI     15      ;END OF SCREEN?
c0cd  c2 e5 c0       344    344         JNZ     OK
                     345    345 ;
                     346    346 ;   END OF SCREEN...ROLL UP ONE LINE
                     347    347 ;
c0d0  af             348    348 SCROLL: XRA     A
c0d1  32 08 c8       349    349         STA     NCHAR   ;BACK TO FIRST CHAR POSITION
c0d4  4f             350    350 SROL:   MOV     C,A
c0d5  cd 4c c1       351    351         CALL    VDAD    ;CALCULATE LINE TO BE BLANKED
c0d8  af             352    352         XRA     A
c0d9  cd 23 c1       353    353         CALL    CLIN1   ;CLEAR IT
c0dc  3a 0a c8       354    354         LDA     BOT
c0df  3c             355    355         INR     A
c0e0  e6 0f          356    356         ANI     0FH
c0e2  c3 12 c1       357    357         JMP     ERAS3
                     358    358 ;
                     359    359 ;   INCREMENT LINE COUNTER IF NECESSARY
                     360    360 ;
c0e5  3a 08 c8       361    361 OK:     LDA     NCHAR   ;GET CHR POSITION
c0e8  3c             362    362         INR     A
c0e9  e6 3f          363    363         ANI     3FH     ;MOD 64
c0eb  32 08 c8       364    364         STA     NCHAR   ;STORE THE NEW
c0ee  c0             365    365         RNZ             ;MORE CHARS THIS LINE
c0ef  =              366    366 PDOWN   EQU     $       ;MOVE CURSOR DOWN ONE LINE
c0ef  3a 09 c8       367    367         LDA     LINE    ;GET THE LINE COUNT
c0f2  3c             368    368         INR     A
c0f3  e6 0f          369    369 CURSC:  ANI     0FH     ;MOD 15 INCREMENT
c0f5  32 09 c8       370    370 CUR:    STA     LINE    ;STORE THE NEW
c0f8  c9             371    371         RET
                     372    372 ;
                     373    373 ;    ERASE SCREEN
                     374    374 ;
c0f9  21 00 cc       375    375 PERSE:  LXI     H,VDMEM ;POINT TO SCREEN
c0fc  36 a0          376    376         MVI     M,80H+' ' ;THIS IS THE CURSOR
                     377    377 ;
c0fe  23             378    378         INX     H       ;NEXT CHAR
c0ff  =              379    379 ERAS1   EQU     $       ;LOOP TO CLR SCRN
c0ff  36 20          380    380         MVI     M,' '   ;BLANK IT OUT
c101  23             381    381         INX     H       ;NEXT SCRN LOC
c102  7c             382    382         MOV     A,H     ;SEE IF DONE
c103  fe d0          383    383         CPI     0D0H    ;DID IT GO ABOVE VDM
c105  da ff c0       384    384         JC      ERAS1   ;NO--MORE
c108  37             385    385         STC             ;SAY WE WANT TO DROP THRU TO ERAS3
                     386    386 ;
c109  =              387    387 PHOME   EQU     $       ;RESET CURSOR TO HOME
c109  3e 00          388    388         MVI     A,0     ;CLEAR, LEAVE CARRY AS IS
c10b  32 09 c8       389    389         STA     LINE    ;ZERO LINE
c10e  32 08 c8       390    390         STA     NCHAR   ;LEFT SIDE OF SCREEN
c111  d0             391    391         RNC             ;THIS IS JUST A HOME OPERATION
                     392    392 ;
c112  d3 c8          393    393 ERAS3:  OUT     DSTAT   ;RESET SCROLL PARAMETERS
c114  32 0a c8       394    394         STA     BOT     ;BEGINNING OF TEXT OFFSET
c117  c9             395    395         RET
                     396    396 ;
                     397    397 ;
c118  =              398    398 CLIN2   EQU     $       ;HERE TO SEE IF VDM OUTPUT
c118  3a 07 c8       399    399         LDA     OPORT   ;GET CRNT OUTPUT PORT
c11b  b7             400    400         ORA     A
c11c  c0             401    401         RNZ             ;NOT VDM--DONE THEN
c11d  cd 45 c1       402    402 CLINE:  CALL    VDADD   ;GET CURRENT SCREEN ADDRESS
c120  3a 08 c8       403    403         LDA     NCHAR   ;CURRENT CURSOR POSITION
c123  fe 40          404    404 CLIN1:  CPI     64      ;NO MORE THAN 63
c125  d0             405    405         RNC             ;ALL DONE
c126  36 20          406    406         MVI     M,' '   ;ALL SPACED OUT
c128  23             407    407         INX     H
c129  3c             408    408         INR     A
c12a  c3 23 c1       409    409         JMP     CLIN1   ;LOOP TO END OF LINE
                     410    410 ;
                     411    411 ;
                     412    412 ;  ROUTINE TO MOVE THE CURSOR UP ONE LINE
                     413    413 ;
c12d  3a 09 c8       414    414 PUP:    LDA     LINE    ;GET LINE COUNT
c130  3d             415    415         DCR     A
c131  c3 f3 c0       416    416         JMP     CURSC   ;MERGE
                     417    417 ;
                     418    418 ;  MOVE CURSOR LEFT ONE POSITION
                     419    419 ;
c134  3a 08 c8       420    420 PLEFT:  LDA     NCHAR
c137  3d             421    421         DCR     A
c138  =              422    422 PCUR    EQU     $       ;TAKE CARE OF CURSOR SAME LINE
c138  e6 3f          423    423         ANI     03FH    ;LET CURSOR WRAP AROUND
c13a  32 08 c8       424    424         STA     NCHAR   ;UPDATED CURSOR
c13d  c9             425    425         RET
                     426    426 ;
                     427    427 ;     CURSOR RIGHT ONE POSITION
                     428    428 ;
c13e  3a 08 c8       429    429 PRIT:   LDA     NCHAR
c141  3c             430    430         INR     A
c142  c3 38 c1       431    431         JMP     PCUR
                     432    432 ;
                     433    433 ;   ROUTINE TO CALCULATE SCREEN ADDRESS
                     434    434 ;
                     435    435 ;   ENTRY AT:    RETURNS:
                     436    436 ;
                     437    437 ;         VDADD  CURRENT SCREEN ADDRESS
                     438    438 ;         VDAD2  ADDRESS OF CURRENT LINE, CHAR 'C'
                     439    439 ;         VDAD   LINE 'A', CHARACTER POSITION 'C'
                     440    440 
c145  3a 08 c8       441    441 VDADD:  LDA     NCHAR   ;GET CHARACTER POSITION
c148  4f             442    442         MOV     C,A     ;'C' KEEPS IT
c149  3a 09 c8       443    443 VDAD2:  LDA     LINE    ;LINE POSITION
c14c  6f             444    444 VDAD:   MOV     L,A     ;INTO 'L'
c14d  3a 0a c8       445    445         LDA     BOT     ;GET TEXT OFFSET
c150  85             446    446         ADD     L       ;ADD IT TO THE LINE POSITION
c151  0f             447    447         RRC             ;TIMES TWO
c152  0f             448    448         RRC             ;MAKES FOUR
c153  6f             449    449         MOV     L,A     ;L HAS IT
c154  e6 03          450    450         ANI     3       ;MOD THREE FOR LATER
c156  c6 cc          451    451         ADI     VDMEM SHR 8 ;LOW SCREEN OFFSET
c158  67             452    452         MOV     H,A     ;NOW H IS DONE
c159  7d             453    453         MOV     A,L     ;TWIST L'S ARM
c15a  e6 c0          454    454         ANI     0C0H
c15c  81             455    455         ADD     C
c15d  6f             456    456         MOV     L,A
c15e  c9             457    457         RET             ;H & L ARE NOW PERVERTED
                     458    458 ;
                     459    459 ;    ROUTINE TO REMOVE CURSOR
                     460    460 ;
c15f  cd 45 c1       461    461 CREM:   CALL    VDADD   ;GET CURRENT SCREEN ADDRESS
c162  7e             462    462         MOV     A,M
c163  e6 7f          463    463         ANI     7FH     ;STRIP OFF THE CURSOR
c165  77             464    464         MOV     M,A
c166  c9             465    465         RET
                     466    466 ;
                     467    467 ;     ROUTINE TO BACKSPACE
                     468    468 ;
c167  cd 34 c1       469    469 PBACK:  CALL    PLEFT
c16a  cd 45 c1       470    470         CALL    VDADD   ;GET SCREEN ADDRESS
c16d  36 20          471    471         MVI     M,' '   ;PUT A BLANK THERE
c16f  c9             472    472         RET
                     473    473 ;
                     474    474 ;     ROUTINE TO PROCESS A CARRIAGE RETURN
                     475    475 ;
c170                 476    476 PCR:    ;CALL    CLINE   ;CLEAR FROM CURRENT CURSOR TO END OF LINE
                     477    477 ;  NOTE THAT A COMES BACK=64 WHICH WILL BE CLEARED AT PCUR
c170  3e 40          478    478         MVI     A,64    ;*UM* JUST ADVANCE LINE
c172  c3 38 c1       479    479         JMP     PCUR    ;AND STORE THE NEW VALUE
                     480    480 ;
                     481    481 ;   ROUTINE TO PROCESS LINEFEED
                     482    482 ;
c175  3a 09 c8       483    483 PLF:    LDA     LINE    ;GET LINE COUNT
c178  3c             484    484         INR     A       ;NEXT LINE
c179  e6 0f          485    485         ANI     15      ;SEE IF IT WRAPPED AROUND
c17b  c2 f5 c0       486    486         JNZ     CUR     ;IT DID NOT--NO SCROLL
                     487    487 ;
c17e  c3 d4 c0       488    488         JMP     SROL    ;SCROLL ONE LINE--CURSOR SOME POSITION
                     489    489 ;
                     490    490 ;     SET ESCAPE PROCESS FLAG
                     491    491 ;
c181  3e ff          492    492 PESC:   MVI     A,(-1) AND 0FFH
c183  32 0c c8       493    493         STA     ESCFL   ;SET FLAG
c186  c9             494    494         RET
                     495    495 ;
                     496    496 ;       PROCESS ESCAPE SEQUENCE
                     497    497 ;
c187  cd 5f c1       498    498 ESCS:   CALL    CREM    ;REMOVE CURSOR
c18a  cd 90 c1       499    499         CALL    ESCSP   ;PROCESS THE CHARACTER
c18d  c3 8f c0       500    500         JMP     GOBACK
                     501    501 ;
c190  3a 0c c8       502    502 ESCSP:  LDA     ESCFL   ;GET ESCAPE FLAG
c193  fe ff          503    503         CPI     (-1) AND 0FFH ;TEST FLAG
c195  ca b8 c1       504    504         JZ      SECOND
                     505    505 ;
                     506    506 ;  PROCESS THIRD CHR OF ESC SEQUENCE
                     507    507 ;
c198  21 0c c8       508    508         LXI     H,ESCFL
c19b  36 00          509    509         MVI     M,0
c19d  fe 02          510    510         CPI     2
c19f  da b0 c1       511    511         JC      SETX    ;SET X
c1a2  ca b4 c1       512    512         JZ      SETY    ;SET Y
c1a5  fe 08          513    513         CPI     8       ;SPECIAL SET SPEED
c1a7  ca 94 c5       514    514         JZ      STSPD   ;YES--SET THE SPEED WITH IT THEN
c1aa  fe 09          515    515         CPI     9
c1ac  da bc c0       516    516         JC      OCHAR   ;PUT IT ON THE SCREEN
c1af  c0             517    517         RNZ
                     518    518 ;
                     519    519 ;  TAB ABSOLUTE TO VALUE IN REG B
                     520    520 ;
c1b0  78             521    521 SETX:   MOV     A,B
c1b1  c3 38 c1       522    522         JMP     PCUR
                     523    523 ;
                     524    524 ;  SET CURSOR TO LINE "B"
                     525    525 ;
c1b4  78             526    526 SETY:   MOV     A,B
c1b5  c3 f3 c0       527    527         JMP     CURSC
                     528    528 ;
                     529    529 ;
                     530    530 ;   PROCESS SECOND CHR OF ESC SEQUENCE
                     531    531 ;
c1b8  78             532    532 SECOND: MOV     A,B
c1b9  fe 03          533    533         CPI     3
c1bb  ca ce c1       534    534         JZ      CURET
c1be  fe 04          535    535         CPI     4
c1c0  c2 ca c1       536    536         JNZ     ARET2
                     537    537 ;
c1c3  44             538    538 ARET:   MOV     B,H
c1c4  4d             539    539         MOV     C,L     ;PRESENT SCREEN ADDRESS TO BC FOR RETURN
c1c5  e1             540    540 ARET1:  POP     H       ;RETURN ADDRESS
c1c6  d1             541    541         POP     D       ;OLD B
c1c7  c5             542    542         PUSH    B
c1c8  e5             543    543         PUSH    H
c1c9  af             544    544         XRA     A
c1ca  32 0c c8       545    545 ARET2:  STA     ESCFL
c1cd  c9             546    546         RET
                     547    547 ;
                     548    548 ;
                     549    549 ;     RETURN PRESENT SCREEN PARAMETERS IN BC
                     550    550 ;
c1ce  21 08 c8       551    551 CURET:  LXI     H,NCHAR
c1d1  46             552    552         MOV     B,M     ;CHARACTER POSITION
c1d2  23             553    553         INX     H
c1d3  4e             554    554         MOV     C,M     ;LINE POSITION
c1d4  c3 c5 c1       555    555         JMP     ARET1
                     556    556 ;
                     557    557 ;
                     558    558 ;
                     559    559 ;                START UP SYSTEM
                     560    560 ;
                     561    561 ;   CLEAR SCREEN AND THE FIRST 256 BYTES OF GLOBAL RAM
                     562    562 ;  THEN ENTER THE COMMAND MODE.
                     563    563 ;
c1d7  af             564    564 STRTA:  XRA     A
c1d8  4f             565    565         MOV     C,A
c1d9  21 04 c8       566    566         LXI     H,DFLTS ;CLEAR AFTER USER PORT ADDRESSES
                     567    567 ;
c1dc  77             568    568 CLERA:  MOV     M,A
c1dd  23             569    569         INX     H
c1de  0c             570    570         INR     C
c1df  c2 dc c1       571    571         JNZ     CLERA
                     572    572 ;
                     573    573 ; DETERMINE THE DEFAULT PORTS
                     574    574 ;     THIS COULD BECOME "MVI A,XX" FOR YOUR SPECIFIC PORTS
c1e2  db ff          575    575         IN      SENSE   ;GET SWITCHES
                     576    576 ;
c1e4  47             577    577         MOV     B,A     ;SAVE IT
c1e5  e6 03          578    578         ANI     3       ;MAKE IT A VALID PORT
c1e7  32 05 c8       579    579         STA     DFLTS+1 ;SET DEFAULT OUTPUT PORT
c1ea  b7             580    580         ORA     A       ;SEE IF THIS THE VDM
c1eb  c2 f4 c1       581    581         JNZ     STRTB   ;NO--DO NOT RESET VDM
c1ee  31 ff cb       582    582         LXI     SP,SYSTP ;SET UP THE STACK FOR CALL
c1f1  cd f9 c0       583    583         CALL    PERSE   ;(REG A ASSUMED TO COME BACK ZERO)
c1f4  =              584    584 STRTB   EQU     $       ;FINISH OFF THIS PORT THEN DO NEXT
c1f4  21 00 00       585    585         LXI     H,0     ;USE FOR CLEARING USER ADDRESSES
c1f7  fe 03          586    586         CPI     3       ;IS IT A USER PORT
c1f9  ca ff c1       587    587         JZ      STRTC   ;YES-- DO NOT CLEAR IT
c1fc  22 02 c8       588    588         SHLD    UOPRT   ;NO--CLEAR ADDR
c1ff  =              589    589 STRTC   EQU     $       ;OUTPUT PORT ALL SET
c1ff  78             590    590         MOV     A,B     ;FM SENSE SWITCHES
c200  1f             591    591         RAR
c201  1f             592    592         RAR             ;NEXT 2 BITS ARE INPUT PORT
c202  e6 03          593    593         ANI     3       ;VALID PORT
c204  32 04 c8       594    594         STA     DFLTS   ;THIS IS DEFAULT INPUT PORT
c207  fe 03          595    595         CPI     3       ;IS THIS ONE A USER PORT
c209  ca 0f c2       596    596         JZ      STRTD   ;YES--DO NOT CLEAR IT THEN
c20c  22 00 c8       597    597         SHLD    UIPRT   ;NO--FORCE USER ADDRESS ZERO
c20f  =              598    598 STRTD   EQU     $       ;1ST TIME INITIALIZATION ALL DONE NOW
c20f  2a 04 c8       599    599         LHLD    DFLTS   ;PICK UP DEFAULT PORTS
c212  22 06 c8       600    600         SHLD    IPORT   ;FORCE PORTS TO DEFAULT
c215  =              601    601 COMN1   EQU     $       ;HERE TO TURN OFF TAPES, THEN COMMAND MODE
c215  af             602    602         XRA     A
c216  d3 06          603    603         OUT     TAPPT   ;BE SURE TAPES ARE OFF
                     604    604 ;
                     605    605 ;
                     606    606 ;
                     607    607 ;            =--  COMMAND MODE  --=
                     608    608 ;
                     609    609 ;
                     610    610 ;   THIS ROUTINE GETS AND PROCESSES COMMANDS
                     611    611 ;
c218  31 ff cb       612    612 COMND:  LXI     SP,SYSTP ;SET STACK POINTER
c21b  cd 3a c3       613    613         CALL    PROMPT  ;PUT PROMPT ON SCREEN
c21e  cd 27 c2       614    614         CALL    GCLI0   ;INIT TO GET COMMAND LINE
c221  cd 6a c2       615    615         CALL    COPRC   ;PROCESS THE LINE
c224  c3 18 c2       616    616         JMP     COMND   ;OVER AND OVER
                     617    617 ;
                     618    618 ;
                     619    619 ;
                     620    620 ;   THIS ROUTINE READS A COMMAND LINE FROM THE SYSTEM
                     621    621 ;  KEYBOARD
                     622    622 ;
                     623    623 ;  C/R   TERMINATES THE SEQUENCE ERASING ALL CHARS TO THE
                     624    624 ;        RIGHT OF THE CURSOR
                     625    625 ;  L/F   TERMINATES THE SEQUENCE
                     626    626 ;  ESC   RESETS TO COMMAND MODE.
                     627    627 ;
c227  =              628    628 GCLI0   EQU     $       ;HERE TO INIT FOR GCLIN
c227  21 63 ca       629    629         LXI     H,INLIN-1 ;PT TO CHAR IN FRONT OF INPUT BFR
c22a  36 07          630    630         MVI     M,7     ;MAKE SURE IT IS "BELL" TO KEEP FM DEL'ING TOO FAR
c22c  23             631    631         INX     H       ;NOW PT TO INPUT BFR
c22d  22 0e c8       632    632         SHLD    INPTR   ;SAVE AS STARTING PTR
c230  3e 50          633    633         MVI     A,80    ;NUMBER OF CHARS IN LINE (MAX)
c232  =              634    634 GCLI1   EQU     $       ;LOOP TO BLANK OUT LINE BFR
c232  36 20          635    635         MVI     M,' '   ;BLANKS
c234  23             636    636         INX     H       ;NEXT CHAR
c235  3d             637    637         DCR     A       ;FOR THIS COUNT
c236  c2 32 c2       638    638         JNZ     GCLI1   ;ENTIRE LINE
c239  cd 1f c0       639    639 GCLIN:  CALL    SINP    ;READ INPUT DEVICE
c23c  ca 39 c2       640    640         JZ      GCLIN
c23f  e6 7f          641    641         ANI     7FH     ;MAKE SURE NO X'80' BIT DURING CMND MODE
c241  ca 0f c2       642    642         JZ      STRTD   ;IF EITHER MODE (OR CTL-@)
c244  47             643    643         MOV     B,A
c245  fe 0d          644    644         CPI     CR      ;IS IT CR?
c247  ca 18 c1       645    645         JZ      CLIN2   ;YES--TERMINATE LINE HERE (CLR IF VDM)
c24a  fe 0a          646    646         CPI     LF      ;IS IT A LINEFEED
c24c  c8             647    647         RZ              ;YES--TERMINATE LINE AS IS
c24d  2a 0e c8       648    648         LHLD    INPTR   ;CRNT LINE PTR
c250  fe 7f          649    649         CPI     7FH     ;DELETE CHR?
c252  c2 5f c2       650    650         JNZ     GCLI2   ;NO--OK
c255  06 08          651    651         MVI     B,BACKS ;REPLACE IT
c257  2b             652    652         DCX     H       ;BACK LINE PTR UP TOO
c258  3e 07          653    653         MVI     A,'G'-40H ;SEE IF A BELL
c25a  be             654    654         CMP     M       ;IS IT?
c25b  c2 61 c2       655    655         JNZ     GCLI3   ;NO--OK
c25e  47             656    656         MOV     B,A     ;YES--RING THE BELL THEN
c25f  =              657    657 GCLI2   EQU     $       ;STORE CHAR IN INPUT AREA
c25f  70             658    658         MOV     M,B     ;PLACE CHAR INTO LINE
c260  23             659    659         INX     H       ;NEXT CHAR
c261  =              660    660 GCLI3   EQU     $       ;SAVE NEW LINE PTR
c261  22 0e c8       661    661         SHLD    INPTR   ;SAVE PTR
                     662    662 ;
c264  cd 19 c0       663    663 CONT:   CALL    SOUT
c267  c3 39 c2       664    664         JMP     GCLIN
                     665    665 ;
                     666    666 ;
                     667    667 ;
                     668    668 ;
                     669    669 ;      FIND AND PROCESS COMMAND
                     670    670 ;
c26a  =              671    671 COPRC   EQU     $       ;PROCESS THIS COMMAND LINE
c26a  cd aa c2       672    672         CALL    STUP    ;SETUP TO PROCESS INPUT LINE
c26d  eb             673    673         XCHG            ;DE=ADDR
c26e  21 00 c0       674    674         LXI     H,START ;PREP SO THAT HL WILL PT TO CUTER LATER
c271  e5             675    675         PUSH    H       ;PLACE PTR TO CUTER ON STACK FOR LATER DISPT
c272  cd 6c c3       676    676         CALL    SCHR    ;SCAN PAST BLANKS
c275  ca 6b c4       677    677         JZ      ERR1    ;NO COMMAND?
c278  eb             678    678         XCHG            ;HL HAS FIRST CHR
c279  11 bd c2       679    679         LXI     D,COMTAB ;POINT TO COMMAND TABLE
c27c  cd 91 c2       680    680         CALL    FDCOM   ;SEE IF IN PRIMARY TABLE
c27f  cc 8e c2       681    681         CZ      FDCOU   ;TRY CUSTOM ONLY IF NOT PRIMARY COMMAND
c282  =              682    682 DISP0   EQU     $       ;HERE TO EITHER DISPATCH OR DO ERROR
c282  ca 6c c4       683    683         JZ      ERR2    ;NOT IN EITHER TABLE
c285  13             684    684         INX     D       ;PT DE TO ADDR OF RTN
c286  eb             685    685         XCHG            ;HL=ADDR OF ADDR OF RTN
                     686    686 ; **** DROP THRU TO DISPT ***
                     687    687 ;
                     688    688 ; THIS ROUTINE DISPTACHES TO THE ADDR AT CONTENTS OF HL.
                     689    689 ; HL ARE RESTORED PRIOR TO GOING TO ROUTINE.
                     690    690 ;
c287  =              691    691 DISPT   EQU     $       ;DISPATCH
c287  7e             692    692         MOV     A,M     ;LOW BYTE
c288  23             693    693         INX     H
c289  66             694    694         MOV     H,M     ;HI BYTE
c28a  6f             695    695         MOV     L,A     ;AND LO, HL NOW COMPLETE
c28b  =              696    696 DISP1   EQU     $       ;HERE TO GO OFF TO HL DIRECTLY
c28b  e3             697    697         XTHL            ;HL RESTORED AND ADDR ON STACK
c28c  7d             698    698         MOV     A,L     ;ALWAYS PASS L IN "A" (PRIMARILY FOR SET'S)
c28d  c9             699    699         RET             ;OFF TO ROUTINE
                     700    700 ;
                     701    701 ;
                     702    702 ;
                     703    703 ;   THIS ROUTINE SEARCHES THROUGH A TABLE, POINTED TO
                     704    704 ;  BY 'DE', FOR A DOUBLE CHARACTER MATCH OF THE 'HL'
                     705    705 ;  MEMORY CONTENT.  IF NO MATCH IS FOUND THE SCAN ENDS
                     706    706 ;  WITH THE ZERO FLAG SET, ELSE NON-ZERO SET.
                     707    707 ;
c28e  =              708    708 FDCOU   EQU     $       ;HERE TO SCAN CUSTOM TABLE
c28e  11 3c c8       709    709         LXI     D,CUTAB ;PT TO CUSTOM RTN TBL
c291  1a             710    710 FDCOM:  LDAX    D
c292  b7             711    711         ORA     A       ;TEST FOR TABLE END
c293  c8             712    712         RZ              ;NOT FOUND POST THAT AND RETURN
c294  e5             713    713         PUSH    H       ;SAVE START OF SCAN ADDRESS
c295  be             714    714         CMP     M       ;TEST FIRST CHR
c296  13             715    715         INX     D
c297  c2 a3 c2       716    716         JNZ     NCOM
                     717    717 ;
c29a  23             718    718         INX     H
c29b  1a             719    719         LDAX    D
c29c  be             720    720         CMP     M       ;NOW SECOND CHARACTER
c29d  c2 a3 c2       721    721         JNZ     NCOM    ;GOODNESS
                     722    722 ;
c2a0  e1             723    723         POP     H       ;RETURN HL TO PT TO CHAR START
c2a1  b7             724    724         ORA     A       ;FORCE TO NON-ZERO FLAG
c2a2  c9             725    725         RET             ;LET CALLER KNOW
                     726    726 ;
                     727    727 ;
c2a3  13             728    728 NCOM:   INX     D       ;GO TO NEXT ENTRY
c2a4  13             729    729         INX     D
c2a5  13             730    730         INX     D
c2a6  e1             731    731         POP     H       ;GET BACK ORIGINAL ADDRESS
c2a7  c3 91 c2       732    732         JMP     FDCOM   ;CONTINUE SEARCH
                     733    733 ;
                     734    734 ;
                     735    735 ; SET UP TO PROCESS AN INPUT LINE
c2aa  =              736    736 STUP    EQU     $       ;PREPARE WHETHER VDM OR NOT
c2aa  21 64 ca       737    737         LXI     H,INLIN ;ASSUME NON-VDM INPUT
c2ad  22 0e c8       738    738         SHLD    INPTR   ;ALSO RESET PTR FOR NOW
c2b0  3a 07 c8       739    739         LDA     OPORT   ;SEE IF IT IS VDM
c2b3  b7             740    740         ORA     A       ;IS IT THE VDM PORT
c2b4  c0             741    741         RNZ             ;NO--HL ARE SET PROPERLY
c2b5  cd 5f c1       742    742         CALL    CREM    ;REMOVE CURSOR
c2b8  0e 01          743    743         MVI     C,1     ;GET VDM ADDR FM POSITION ONE
c2ba  c3 49 c1       744    744         JMP     VDAD2   ;GET SCRN ADDR
                     745    745 ;
                     746    746 ;           COMMAND TABLE
                     747    747 ;
                     748    748 ;  THIS TABLE DESCRIBES THE VALID COMMANDS FOR CUTER
                     749    749 ;
c2bd  =              750    750 COMTAB  EQU     $       ;START OF KNOWN COMMANDS
c2bd  44 55          751    751         DB      'DU'    ;DUMP
c2bf  ad c3          752    752         DW      DUMP
c2c1  45 4e          753    753         DB      'EN'    ;ENTR
c2c3  14 c4          754    754         DW      ENTER
c2c5  45 58          755    755         DB      'EX'    ;EXEC
c2c7  49 c4          756    756         DW      EXEC
c2c9  47 45          757    757         DB      'GE'    ;GET
c2cb  a1 c4          758    758         DW      TLOAD
c2cd  53 41          759    759         DB      'SA'    ;SAVE
c2cf  e0 c4          760    760         DW      TSAVE
c2d1  58 45          761    761         DB      'XE'    ;XEQ
c2d3  a0 c4          762    762         DW      TXEQ
c2d5  43 41          763    763         DB      'CA'    ;CAT
c2d7  27 c5          764    764         DW      TLIST
c2d9  53 45          765    765         DB      'SE'    ;SET COMMAND
c2db  76 c5          766    766         DW      CSET
c2dd  43 55          767    767         DB      'CU'    ;CUSTOM COMMAND ENTER/CLEAR
c2df  b9 c5          768    768         DW      CUSET
c2e1  00             769    769         DB      0       ;END OF TABLE MARK
                     770    770 ;
                     771    771 ;
                     772    772 ;               DISPLAY DRIVER COMMAND TABLE
                     773    773 ;
                     774    774 ;     THIS TABLE DEFINES THE CHARACTERS FOR SPECIAL
                     775    775 ;  PROCESSING. IF THE CHARACTER IS NOT IN THE TABLE IT
                     776    776 ;  GOES TO THE SCREEN.
                     777    777 ;
c2e2  0b             778    778 TBL:    DB      CLEAR   ;SCREEN
c2e3  f9 c0          779    779         DW      PERSE
c2e5  17             780    780         DB      UP      ;CURSOR
c2e6  2d c1          781    781         DW      PUP
c2e8  1a             782    782         DB      DOWN    ;"
c2e9  ef c0          783    783         DW      PDOWN
c2eb  01             784    784         DB      LEFT    ;"
c2ec  34 c1          785    785         DW      PLEFT
c2ee  13             786    786         DB      RIGHT   ;"
c2ef  3e c1          787    787         DW      PRIT
c2f1  0e             788    788         DB      HOME    ;"
c2f2  09 c1          789    789         DW      PHOME
c2f4  0d             790    790         DB      CR      ;CARRIAGE RETURN
c2f5  70 c1          791    791         DW      PCR
c2f7  0a             792    792         DB      LF      ;LINE FEED
c2f8  75 c1          793    793         DW      PLF
c2fa  08             794    794         DB      BACKS   ;BACK SPACE
c2fb  67 c1          795    795         DW      PBACK
c2fd  1b             796    796         DB      ESC     ;ESCAPE KEY
c2fe  81 c1          797    797         DW      PESC
c300  00             798    798         DB      0       ;END OF TABLE
                     799    799 ;
                     800    800 ;   OUTPUT DEVICE TABLE
                     801    801 ;
c301  78 c0          802    802 OTAB:   DW      VDM01   ;VDM DRIVER
c303  47 c0          803    803         DW      SEROT   ;SERIAL OUTPUT
c305  5a c0          804    804         DW      PAROT   ;PARALLEL OUTPUT
c307  6c c0          805    805         DW      ERROT   ;ERROR OR USER DRIVER HANDLER
                     806    806 ;
                     807    807 ;    INPUT DEVICE TABLE
                     808    808 ;
c309  35 c0          809    809 ITAB:   DW      KREA1   ;KEYBOARD INPUT
c30b  3e c0          810    810         DW      SREA1   ;SERIAL INPUT
c30d  52 c0          811    811         DW      PARIT   ;PARALLEL INPUT
c30f  65 c0          812    812         DW      ERRIT   ;ERROR OR USER DRIVER HANDLER
                     813    813 ;
                     814    814 ;
                     815    815 ;       SECONDARY COMMAND TABLE FOR SET COMMAND
                     816    816 ;
c311  54 41          817    817 SETAB:  DB      'TA'    ;SET TAPE SPEED
c313  8a c5          818    818         DW      TASPD
c315  53 3d          819    819         DB      'S='    ;SET DISPLAY SPEED
c317  95 c5          820    820         DW      DISPD
c319  49 3d          821    821         DB      'I='    ;SET INPUT PORT
c31b  99 c5          822    822         DW      SETIN
c31d  4f 3d          823    823         DB      'O='    ;SET OUTPUT PORT
c31f  9d c5          824    824         DW      SETOT
c321  43 49          825    825         DB      'CI'    ;SET CUSTOM DRIVER ADDRESS
c323  a1 c5          826    826         DW      SETCI
c325  43 4f          827    827         DB      'CO'    ;SET CUSTOM OUTPUT DRIVER ADDRESS
c327  a5 c5          828    828         DW      SETCO
c329  58 45          829    829         DB      'XE'    ;SET HEADER XEQ ADDRESS
c32b  ad c5          830    830         DW      SETXQ
c32d  54 59          831    831         DB      'TY'    ;SET HEADER TYPE
c32f  a9 c5          832    832         DW      SETTY
c331  4e 3d          833    833         DB      'N='    ;SET NUMBER OF NULLS
c333  b1 c5          834    834         DW      SETNU
c335  43 52          835    835         DB      'CR'    ;SET CRC (NORMAL OR IGNORE CRC ERRORS)
c337  b5 c5          836    836         DW      SETCR
c339  00             837    837         DB      0       ;END OF TABLE MARK
                     838    838 ; -*-
                     839    839 ;
                     840    840 ;
                     841    841 ;      OUTPUT A CRLF FOLLOWED BY A PROMPT
                     842    842 ;
c33a  cd 42 c3       843    843 PROMPT: CALL    CRLF
c33d  06 3e          844    844         MVI     B,'>'   ;THE PROMPT
c33f  c3 19 c0       845    845         JMP     SOUT    ;PUT IT ON THE SCREEN
                     846    846 ;
c342  06 0a          847    847 CRLF:   MVI     B,LF    ;LINE FEED
c344  cd 19 c0       848    848         CALL    SOUT
c347  06 0d          849    849         MVI     B,CR    ;CARRIAGE RETURN
c349  cd 19 c0       850    850         CALL    SOUT
c34c  3a 10 c8       851    851         LDA     NUCNT   ;GET COUNT OF NULLS TO OUTPUT
c34f  4f             852    852         MOV     C,A     ;SAVE COUNT IN C
c350  0d             853    853 NULOT:  DCR     C
c351  f8             854    854         RM              ;COUNTED DOWN PAST ZERO (MAX COUNT IS X'7F')
c352  af             855    855         XRA     A       ;HERE IS THE NULL
c353  cd 10 c4       856    856         CALL    OUTH    ;OUTPUT IT
c356  c3 50 c3       857    857         JMP     NULOT   ;LOOP FOR NUMBER OF NULLS
                     858    858 ;
                     859    859 ;
                     860    860 ;  SCAN OVER UP TO 12 CHARACTERS LOOKING FOR A BLANK
                     861    861 ;
c359  0e 0c          862    862 SBLK:   MVI     C,12    ;MAXIMUM COMMAND STRING
c35b  1a             863    863 SBLK1:  LDAX    D
c35c  fe 20          864    864         CPI     BLANK
c35e  ca 6c c3       865    865         JZ      SCHR    ;GOT A BLANK NOW SCAN PAST IT
c361  13             866    866         INX     D
c362  fe 3d          867    867         CPI     '='     ;A EQUAL WILL ALSO STOP US (AT NEXT CHAR)
c364  ca 6c c3       868    868         JZ      SCHR    ;FOUND, DE PT TO NEXT CHAR
c367  0d             869    869         DCR     C       ;NO MORE THAN TWELVE
c368  c2 5b c3       870    870         JNZ     SBLK1
c36b  c9             871    871         RET             ;GO BACK WITH ZERO FLAG SET
                     872    872 ;
                     873    873 ;
                     874    874 ;  SCAN PAST UP TO 10 BLANK POSITIONS LOOKING FOR
                     875    875 ; A NON BLANK CHARACTER.
                     876    876 ;
c36c  0e 0a          877    877 SCHR:   MVI     C,10    ;SCAN TO FIRST NON BLANK CHR WITHIN 10
c36e  1a             878    878 SCHR1:  LDAX    D       ;GET NEXT CHARACTER
c36f  fe 20          879    879         CPI     SPACE
c371  c0             880    880         RNZ             ;WE'RE PAST THEM
c372  13             881    881         INX     D       ;NEXT SCAN ADDRESS
c373  0d             882    882         DCR     C
c374  c8             883    883         RZ              ;COMMAND ERROR
c375  c3 6e c3       884    884         JMP     SCHR1   ;KEEP LOOPING
                     885    885 ;
                     886    886 ;  THIS ROUTINE SCANS OVER CHARACTERS, PAST BLANKS AND
                     887    887 ; CONVERTS THE FOLLOWING ADDRESS TO HEX.  ERRORS RETURN TO
                     888    888 ; THE ERROR HANDLER.
                     889    889 ;
c378  cd 59 c3       890    890 SCONV:  CALL    SBLK
c37b  ca 6b c4       891    891         JZ      ERR1
                     892    892 ;
                     893    893 ;  THIS ROUTINE CONVERTS ASCII DIGITS INTO BINARY FOLLOWING
                     894    894 ; A STANDARD HEX CONVERSION.  THE SCAN STOPS WHEN AN ASCII
                     895    895 ; SPACE IS ENCOUNTERED.  PARAMETER ERRORS REPLACE THE ERROR
                     896    896 ; CHARACTER ON THE SCREEN WITH A QUESTION MARK.
                     897    897 ;
c37e  21 00 00       898    898 SHEX:   LXI     H,0     ;CLEAR H & L
c381  1a             899    899 SHE1:   LDAX    D       ;GET CHARACTER
c382  fe 20          900    900         CPI     20H     ;IS IT A SPACE?
c384  c8             901    901         RZ              ;IF SO
c385  fe 2f          902    902         CPI     '/'
c387  c8             903    903         RZ
c388  fe 3a          904    904         CPI     ':'
c38a  c8             905    905         RZ
                     906    906 ;
c38b  29             907    907 HCONV:  DAD     H       ;MAKE ROOM FOR THE NEW ONE
c38c  29             908    908         DAD     H
c38d  29             909    909         DAD     H
c38e  29             910    910         DAD     H
c38f  cd 9b c3       911    911         CALL    HCOV1   ;DO THE CONVERSION
c392  d2 6b c4       912    912         JNC     ERR1    ;NOT VALID HEXIDECIMAL VALUE
c395  85             913    913         ADD     L
c396  6f             914    914         MOV     L,A     ;MOVE IT IN
c397  13             915    915         INX     D       ;BUMP THE POINTER
c398  c3 81 c3       916    916         JMP     SHE1
                     917    917 ;
c39b  d6 30          918    918 HCOV1:  SUI     48      ;REMOVE ASCII BIAS
c39d  fe 0a          919    919         CPI     10
c39f  d8             920    920         RC              ;IF LESS THAN 9
c3a0  d6 07          921    921         SUI     7       ;IT'S A LETTER??
c3a2  fe 10          922    922         CPI     10H
c3a4  c9             923    923         RET             ;WITH TEST IN HAND
                     924    924 ;
                     925    925 ;
                     926    926 ;  THIS ROUTINE WILL SEE IF A FIELD (OPERAND) IS PRESENT.
                     927    927 ;  IF NOT, THEN HL WILL REMAIN AS THEY WERE ON ENTRY.
                     928    928 ;  IF IT WAS PRESENT, THEN HL=THAT VALUE IN HEX.
                     929    929 ;
c3a5  =              930    930 PSCAN   EQU     $       ;OPTIONAL FIELD SCANNER
c3a5  cd 59 c3       931    931         CALL    SBLK    ;SEE IF FIELD IS PRESENT
c3a8  c8             932    932         RZ              ;RETURN LEAVING HL AS THEY WERE ON ENTRY
c3a9  cd 7e c3       933    933         CALL    SHEX    ;FIELD IS THERE, GO GET IT
c3ac  c9             934    934         RET             ;HL= EITHER OPTIONAL FIELD (HEX), OR AS IT WAS
                     935    935 ;
                     936    936 ;
                     937    937 ;
                     938    938 ;
                     939    939 ;           DUMP COMMAND
                     940    940 ;
                     941    941 ;     THIS ROUTINE DUMPS CHARACTERS FROM MEMORY TO THE
                     942    942 ;  CURRENT OUTPUT DEVICE.
                     943    943 ;  ALL VALUES ARE DESPLAYED AS ASCII HEX.
                     944    944 ;
                     945    945 ;  THE COMMAND FORM IS AS FOLLOWS:
                     946    946 ;
                     947    947 ;        DUMP  ADDR1  ADDR2
                     948    948 ;
                     949    949 ;    THE VALUES FROM ADDR1 TO ADDR2 ARE THEN OUTPUT TO THE
                     950    950 ;  OUTPUT DEVICE.  IF ONLY ADDR1 IS SPECIFIED THEN THE
                     951    951 ;  VALUE AT THAT ADDRESS IS OUTPUT.
                     952    952 ;
                     953    953 ;  IF WHILE DUMPING, THE MODE KEY IS PRESSED, THE DUMP WILL
                     954    954 ;  BE TERMINATED.  IF THE SPACE BAR IS PRESSED, THE DUMP
                     955    955 ;  WILL BE TEMPORARILY SUSPENDED UNTIL ANY KEY IS PRESSED.
                     956    956 ;
c3ad  =              957    957 DUMP    EQU     $       ;SET UP REGS TO DUMP SPECIFIED AREA
c3ad  cd 78 c3       958    958         CALL    SCONV   ;GET START ADDR (REQUIRED)
c3b0  e5             959    959         PUSH    H       ;SAVE THE START ADDR
c3b1  cd a5 c3       960    960         CALL    PSCAN   ;GET OPTIONAL END ADDR, HL=THIS OR START ADDR
c3b4  d1             961    961         POP     D       ;DE=START ADDR
c3b5  eb             962    962         XCHG            ;DE=END ADDR, HL=START ADDR NOW
                     963    963 ;
c3b6  cd 42 c3       964    964 DLOOP:  CALL    CRLF
c3b9  cd d9 c3       965    965         CALL    ADOUT   ;OUTPUT ADDRESS
c3bc  cd f7 c3       966    966         CALL    BOUT    ;ANOTHER SPACE TO KEEP IT PRETTY
c3bf  0e 10          967    967         MVI     C,16    ;VALUES PER LINE
                     968    968 ;
c3c1  7e             969    969 DLP1:   MOV     A,M     ;GET THE CHR
c3c2  c5             970    970         PUSH    B       ;SAVE VALUE COUNT
c3c3  cd de c3       971    971         CALL    HBOUT   ;SEND IT OUT WITH A BLANK
c3c6  7c             972    972         MOV     A,H     ;CRNT ADDR
c3c7  ba             973    973         CMP     D       ;VERSUS ENDING ADDR
c3c8  da d0 c3       974    974         JC      DLP1A   ;NOT DONE YET
c3cb  7d             975    975         MOV     A,L     ;TRY LOW ORDER BYTE
c3cc  bb             976    976         CMP     E
c3cd  d2 18 c2       977    977         JNC     COMND   ;ALL DONE WHEN CRNT REACHES ENDING
c3d0  =              978    978 DLP1A   EQU     $       ;HERE TO KEEP DUMPING
c3d0  c1             979    979         POP     B       ;VALUES PER LINE
c3d1  23             980    980         INX     H
c3d2  0d             981    981         DCR     C       ;BUMP THE LINE COUNT
c3d3  c2 c1 c3       982    982         JNZ     DLP1    ;NOT ZERO IF MORE FOR THIS LINE
c3d6  c3 b6 c3       983    983         JMP     DLOOP   ;DO A LFCR BEFORE THE NEXT
                     984    984 ;
                     985    985 ;    OUTPUT HL AS HEX 16 BIT VALUE
                     986    986 ;
c3d9  7c             987    987 ADOUT:  MOV     A,H     ;H FIRST
c3da  cd fc c3       988    988         CALL    HEOUT
c3dd  7d             989    989         MOV     A,L     ;THEN L FOLLOWED BY A SPACE
                     990    990 ;
c3de  cd fc c3       991    991 HBOUT:  CALL    HEOUT
c3e1  cd 1f c0       992    992         CALL    SINP    ;SEE IF WE SHD ESCAPE FM DUMP
c3e4  ca f7 c3       993    993         JZ      BOUT    ;NO--ADD THE SPACE THEN
c3e7  e6 7f          994    994         ANI     7FH     ;MAKE SURE ITS CLEAR OF PARITY
c3e9  ca 18 c2       995    995         JZ      COMND   ;EITHER MODE (OR CTL-@)
c3ec  fe 20          996    996         CPI     ' '     ;IS IT SPACE
c3ee  c2 f7 c3       997    997         JNZ     BOUT    ;NO--IGNORE THE CHAR
c3f1  cd 1f c0       998    998 WTLP1:  CALL    SINP    ;ON SPACE, WAIT FOR ANY OTHER CHAR
c3f4  ca f1 c3       999    999         JZ      WTLP1   ;JUST LOOP AFTER A SPACE UNTIL ANY KEY PRESSED
c3f7  06 20         1000   1000 BOUT:   MVI     B,' '
c3f9  c3 19 c0      1001   1001         JMP     SOUT    ;PUT IT OUT
                    1002   1002 ;
c3fc  4f            1003   1003 HEOUT:  MOV     C,A     ;GET THE CHARACTER
c3fd  0f            1004   1004         RRC
c3fe  0f            1005   1005         RRC             ;MOVE THE HIGH FOUR DOWN
c3ff  0f            1006   1006         RRC
c400  0f            1007   1007         RRC
c401  cd 05 c4      1008   1008         CALL    HEOU1   ;PUT THEM OUT
c404  79            1009   1009         MOV     A,C     ;THIS TIME THE LOW FOUR
                    1010   1010 ;
c405  e6 0f         1011   1011 HEOU1:  ANI     0FH     ;FOUR ON THE FLOOR
c407  c6 30         1012   1012         ADI     48      ;WE WORK WITH ASCII HERE
c409  fe 3a         1013   1013         CPI     58      ;0-9?
c40b  da 10 c4      1014   1014         JC      OUTH    ;YUP!
c40e  c6 07         1015   1015         ADI     7       ;MAKE IT A LETTER
c410  47            1016   1016 OUTH:   MOV     B,A     ;OUTPUT IT FROM REGISTER 'B'
c411  c3 19 c0      1017   1017         JMP     SOUT
                    1018   1018 ;
                    1019   1019 ;
                    1020   1020 ;           ENTR COMMAND
                    1021   1021 ;
                    1022   1022 ;   THIS ROUTINE GETS VALUES FROM THE KEYBOARD AND ENTERS
                    1023   1023 ; THEM INTO MEMORY.  THE INPUT VALUES ARE SCANNED FOLLOWING
                    1024   1024 ; A STANDARD 'GCLIN' INPUT SO ON-SCREEN EDITING MAY TAKE
                    1025   1025 ; PLACE PRIOR TO THE LINE TERMINATOR.  A SLASH '/'
                    1026   1026 ; ENDS THE ROUTINE AND RETURNS CONTROL TO THE COMMAND MODE.
                    1027   1027 ;
c414  cd 78 c3      1028   1028 ENTER:  CALL    SCONV   ;SCAN OVER CHARS AND GET ADDRESS
c417  e5            1029   1029         PUSH    H       ;SAVE ADDRESS
                    1030   1030 ;
c418  cd 42 c3      1031   1031 ENLOP:  CALL    CRLF
c41b  06 3a         1032   1032         MVI     B,':'
c41d  cd 19 c0      1033   1033         CALL    SOUT    ;DSPLY THE COLON
c420  cd 27 c2      1034   1034         CALL    GCLI0   ;INIT AND PROCESS A LINE
c423  cd aa c2      1035   1035         CALL    STUP    ;SET UP TO PROCESS INPUT LINE
c426  eb            1036   1036         XCHG            ;....TO DE
                    1037   1037 ;
                    1038   1038 ;
c427  0e 03         1039   1039 ENLO1:  MVI     C,3     ;NO MORE THAN THREE SPACES BETWEEN VALUES
c429  cd 6e c3      1040   1040         CALL    SCHR1   ;SCAN TO NEXT VALUE
c42c  ca 18 c4      1041   1041         JZ      ENLOP   ;LAST ENTRY FOUND START NEW LINE
                    1042   1042 ;
c42f  fe 2f         1043   1043         CPI     '/'     ;COMMAND TERMINATOR?
c431  ca 18 c2      1044   1044         JZ      COMND   ;IF SO...
c434  cd 7e c3      1045   1045         CALL    SHEX    ;CONVERT VALUE
c437  fe 3a         1046   1046         CPI     ':'     ;ADDRESS TERMINATOR?
c439  ca 44 c4      1047   1047         JZ      ENLO3   ;GO PROCESS IF SO
c43c  7d            1048   1048         MOV     A,L     ;GET LOW PART AS CONVERTED
c43d  e1            1049   1049         POP     H       ;GET MEMORY ADDRESS
c43e  77            1050   1050         MOV     M,A     ;PUT IN THE VALUE
c43f  23            1051   1051         INX     H
c440  e5            1052   1052         PUSH    H       ;BACK GOES THE ADDRESS
c441  c3 27 c4      1053   1053         JMP     ENLO1   ;CONTINUE THE SCAN
                    1054   1054 ;
c444  e3            1055   1055 ENLO3:  XTHL            ;PUT NEW ADDRESS ON STACK
c445  13            1056   1056         INX     D       ;MOVE SCAN PAST TERMINATOR
c446  c3 27 c4      1057   1057         JMP     ENLO1
                    1058   1058 ;
                    1059   1059 ;
                    1060   1060 ;              EXECUTE COMMAND
                    1061   1061 ;
                    1062   1062 ;   THIS ROUTINE GETS THE FOLLOWING PARAMETER AND DOES A
                    1063   1063 ; PROGRAM JUMP TO THE LOCATION GIVEN BY IT.  IF PROPER
                    1064   1064 ; STACK OPERATIONS ARE USED WITHIN THE EXTERNAL PROGRAM
                    1065   1065 ; IT CAN DO A STANDARD 'RET'URN TO THE CUTER COMMAND MODE.
                    1066   1066 ;
                    1067   1067 ;
c449  cd 78 c3      1068   1068 EXEC:   CALL    SCONV   ;SCAN PAST BLANKS AND GET PARAMETER
c44c  =             1069   1069 EXEC1   EQU     $       ;HERE TO GO TO HL
c44c  e5            1070   1070         PUSH    H       ;SAVE ON STACK
c44d  21 00 c0      1071   1071         LXI     H,START ;LET USER KNOW WHERE WE ARE
c450  c9            1072   1072         RET             ;AND OFF TO USER
                    1073   1073 ;
                    1074   1074 ;
                    1075   1075 ;
                    1076   1076 ;
                    1077   1077 ;   THIS ROUTINE GETS A NAME OF UP TO 5 CHARACTERS
                    1078   1078 ;  FROM THE INPUT STRING.  IF THE TERMINATOR IS A
                    1079   1079 ;  SLASH (/) THEN THE CHARACTER FOLLOWING IS TAKEN
                    1080   1080 ;  AS THE CASSETTE UNIT SPECIFICATION.
                    1081   1081 ;
                    1082   1082 ;
c451  =             1083   1083 NAME0   EQU     $       ;ENTER HERE TO SET HL TO THEAD
c451  21 1c c8      1084   1084         LXI     H,THEAD ;PT WHERE TO PUT NAME
c454  cd 59 c3      1085   1085 NAME:   CALL    SBLK    ;SCAN OVER TO FIRST CHRS
c457  06 06         1086   1086         MVI     B,6
                    1087   1087 ;
c459  1a            1088   1088 NAME1:  LDAX    D       ;GET CHARACTER
c45a  fe 20         1089   1089         CPI     ' '     ;NO UNIT DELIMITER
c45c  ca 80 c4      1090   1090         JZ      NFIL
c45f  fe 2f         1091   1091         CPI     '/'     ;UNIT DELIMITER
c461  ca 80 c4      1092   1092         JZ      NFIL
c464  77            1093   1093         MOV     M,A
c465  13            1094   1094         INX     D       ;BUMP THE SCAN POINTER
c466  23            1095   1095         INX     H
c467  05            1096   1096         DCR     B
c468  c2 59 c4      1097   1097         JNZ     NAME1   ;NAME IS OK, FALL THRU TO 'ERR1' IF NOT
                    1098   1098 ;
                    1099   1099 ;     CUTER ERROR HANDLER
                    1100   1100 ;
c46b  eb            1101   1101 ERR1:   XCHG            ;GET SCAN ADDRESS
c46c  36 3f         1102   1102 ERR2:   MVI     M,'?'   ;FLAG THE ERROR
c46e  3a 07 c8      1103   1103         LDA     OPORT   ;SEE IF VIA VDM DRIVER
c471  b7            1104   1104         ORA     A
c472  ca 18 c2      1105   1105         JZ      COMND   ;YES--VDM SCREEN NOW HAS THE ?
c475  cd 42 c3      1106   1106         CALL    CRLF
c478  06 3f         1107   1107         MVI     B,'?'   ;SET UP THE ????
c47a  cd 19 c0      1108   1108         CALL    SOUT    ;INDICATE INPUT NOT VALID
c47d  c3 18 c2      1109   1109         JMP     COMND   ;NOW READY FOR NEXT INPUT
                    1110   1110 ;
                    1111   1111 ;
                    1112   1112 ;
                    1113   1113 ;  HERE WE HAVE SCANNED OFF THE NAME. ZERO FILL IN FOR
                    1114   1114 ;  NAMES LESS THAN FIVE CHARACTERS.
                    1115   1115 ;
c480  36 00         1116   1116 NFIL:   MVI     M,0     ;PUT IN AT LEAST ONE ZERO
c482  23            1117   1117         INX     H
c483  05            1118   1118         DCR     B
c484  c2 80 c4      1119   1119         JNZ     NFIL    ;LOOP UNTIL B IS ZERO
                    1120   1120 ;
c487  fe 2f         1121   1121         CPI     '/'     ;IS THERE A UNIT SPECIFICATION?
c489  3e 01         1122   1122         MVI     A,1     ;PRETEND NOT
c48b  c2 94 c4      1123   1123         JNZ     DEFLT
c48e  13            1124   1124         INX     D       ;MOVE PAST THE TERMINATOR
c48f  cd 6c c3      1125   1125         CALL    SCHR    ;GO GET IT
c492  d6 30         1126   1126         SUI     '0'     ;REMOVE ASCII BIAS
                    1127   1127 ;
c494  =             1128   1128 DEFLT   EQU     $       ;CNVRT TO INTERNAL BIT FOR TAPE CONTROL
c494  e6 01         1129   1129         ANI     1       ;JUST BIT ZERO
c496  3e 80         1130   1130         MVI     A,TAPE1 ;ASSUME TAPE ONE
c498  c2 9c c4      1131   1131         JNZ     STUNT   ;IF NON ZERO, IT IS ONE
c49b  1f            1132   1132         RAR             ;ELSE MAKE IT TAPE TWO
c49c  32 54 c8      1133   1133 STUNT:  STA     FNUMF   ;SET IT IN
c49f  c9            1134   1134         RET
                    1135   1135 ;
                    1136   1136 ;
                    1137   1137 ;
                    1138   1138 ;   THIS ROUTINE PROCESSES THE XEQ AND GET COMMANDS
                    1139   1139 ;
                    1140   1140 ;
c4a0  3e            1141   1141 TXEQ:   DB      3EH     ;THIS BEGINS "MVI" OF THE "XRA" FOLLOWING
c4a1  af            1142   1142 TLOAD:  XRA     A       ;A=0 TLOAD, A=AF (#0) THEN XEQ
c4a2  f5            1143   1143         PUSH    PSW     ;SAVE FLAG TO SAY WHETHER LOAD OR XEQ
c4a3  21 2c c8      1144   1144         LXI     H,DHEAD ;PLACE DUMMY HDR HERE FOR COMPARES
c4a6  cd 54 c4      1145   1145         CALL    NAME    ;SET IN NAME AND UNIT
c4a9  21 00 00      1146   1146         LXI     H,0     ;ASSUME LOAD ADDR NOT GIVEN
c4ac  cd a5 c3      1147   1147         CALL    PSCAN   ;HL EITHER =0, OR OVERRIDE LOAD ADDR
                    1148   1148 ;
c4af  eb            1149   1149 TLOA2:  XCHG            ;PUT ADDRESS IN DE
c4b0  21 2c c8      1150   1150         LXI     H,DHEAD ;PT TO NORMAL HDR
c4b3  7e            1151   1151         MOV     A,M     ;GET 1ST CHAR OF NAME
c4b4  b7            1152   1152         ORA     A       ;IS THERE A NAME?
c4b5  c2 bb c4      1153   1153         JNZ     TLOA3   ;YES--LOOK FOR IT
c4b8  21 1c c8      1154   1154         LXI     H,THEAD ;PT TO SAME HDR TO LOAD NEXT FILE
c4bb  e5            1155   1155 TLOA3:  PUSH    H       ;SAVE PTR TO WHICH HDR TO USE
c4bc  cd 44 c5      1156   1156         CALL    ALOAD   ;GET UNIT AND SPEED
c4bf  e1            1157   1157         POP     H       ;RESTORE PTR TO PROPER HDR TO USE
c4c0  cd c7 c6      1158   1158         CALL    RTAPE   ;READ IN THE TAPE
c4c3  da 10 c5      1159   1159         JC      TAERR   ;TAPE ERROR?
                    1160   1160 ;
c4c6  cd 4c c5      1161   1161         CALL    NAOUT   ;PUT OUT THE HEADER PARAMETERS
c4c9  f1            1162   1162         POP     PSW     ;RESTORE FLAG SAYING WHETHER IT WAS LOAD OR XEQ
c4ca  b7            1163   1163         ORA     A
c4cb  c8            1164   1164         RZ              ;AUTO XEQ NOT WANTED
c4cc  3a 22 c8      1165   1165         LDA     HTYPE   ;CHECK TYPE
c4cf  b7            1166   1166         ORA     A       ;SET FLAGS
c4d0  fa 10 c5      1167   1167         JM      TAERR   ;TYPE IS NON XEQ
c4d3  3a 21 c8      1168   1168         LDA     THEAD+5
c4d6  b7            1169   1169         ORA     A
c4d7  c2 10 c5      1170   1170         JNZ     TAERR   ;THE BYTE MUST BE ZERO FOR AUTO XEQ
c4da  2a 27 c8      1171   1171         LHLD    XEQAD   ;GET THE TAPE ADDRESS
c4dd  c3 4c c4      1172   1172         JMP     EXEC1   ;AND GO OFF TO IT
                    1173   1173 ;
                    1174   1174 ;
                    1175   1175 ;
                    1176   1176 ;   THIS ROUTINE IS USED TO SAVE PROGRAMS AND DATA ON
                    1177   1177 ;   THE CASSETTE UNIT.
                    1178   1178 ;
                    1179   1179 ;
c4e0  =             1180   1180 TSAVE   EQU     $       ;SAVE MEMORY IMAGE TO TAPE
c4e0  cd 51 c4      1181   1181         CALL    NAME0   ;GET NAME AND UNIT
c4e3  cd 78 c3      1182   1182         CALL    SCONV   ;GET START ADDRESS
c4e6  e5            1183   1183         PUSH    H       ;SAVE START ADDR FOR SIZE COMPUTATION LATER
c4e7  cd 78 c3      1184   1184         CALL    SCONV   ;GET END ADDR (REQUIRED)
c4ea  e3            1185   1185         XTHL            ;HL=START ADDR NOW, STACK=END ADDR
c4eb  e5            1186   1186         PUSH    H       ;STACK =START FOLLOWED BY END
c4ec  cd a5 c3      1187   1187         CALL    PSCAN   ;SEE IF RETRIEVE FROM ADDR
c4ef  22 25 c8      1188   1188         SHLD    LOADR   ;EITHER ACTUAL START, OR OVERRIDE INTO HDR
c4f2  e1            1189   1189         POP     H       ;HL=START ADDR
c4f3  d1            1190   1190         POP     D       ;DE=END ADDR
c4f4  e5            1191   1191         PUSH    H       ;PUT START BACK ONTO STACK
c4f5  7b            1192   1192         MOV     A,E     ;SIZE=END-START+1
c4f6  95            1193   1193         SUB     L
c4f7  6f            1194   1194         MOV     L,A
c4f8  7a            1195   1195         MOV     A,D
c4f9  de 00         1196   1196         SBI     0       ;THIS EQUALS A "SBB H"
c4fb  94            1197   1197         SUB     H       ;THIS IS NEEDED
c4fc  67            1198   1198         MOV     H,A
c4fd  23            1199   1199         INX     H
c4fe  22 23 c8      1200   1200         SHLD    BLOCK   ;STORE THE SIZE
c501  e5            1201   1201         PUSH    H       ;SAVE AS THE BLOCK SIZE
                    1202   1202 ;
c502  cd 44 c5      1203   1203         CALL    ALOAD   ;GET UNIT AND SPEED
c505  21 1c c8      1204   1204         LXI     H,THEAD ;PT TO HEADER TO WRITE
c508  cd ad c7      1205   1205         CALL    WHEAD   ;TURN TAPE ON, THEN WRITE HEADER
c50b  d1            1206   1206         POP     D       ;GET BACK THE SIZE
c50c  e1            1207   1207         POP     H       ;AND GET BACK THE ACTUAL START ADDR
c50d  c3 8d c7      1208   1208         JMP     WTAP1   ;WRITE THE BLK (W/EXTRA PUSH)
                    1209   1209 ;
                    1210   1210 ;   OUTPUT ERROR AND HEADER
                    1211   1211 ;
c510  cd 42 c3      1212   1212 TAERR:  CALL    CRLF
c513  16 06         1213   1213         MVI     D,6
c515  21 21 c5      1214   1214         LXI     H,ERRM
c518  cd 66 c5      1215   1215         CALL    NLOOP   ;OUTPUT ERROR
c51b  cd 4c c5      1216   1216         CALL    NAOUT   ;THEN THE HEADER
c51e  c3 15 c2      1217   1217         JMP     COMN1
                    1218   1218 ;
c521  45 52 52 4f   1219   1219 ERRM:   DB      'ERROR '
c525  52 20         1219   1220
                    1220   1221 
                    1221   1222 ;
                    1222   1223 ;
                    1223   1224 ;              CAT COMMAND
                    1224   1225 ;
                    1225   1226 ;   THIS ROUTINE READS HEADERS FROM THE TAPE AND OUTPUTS
                    1226   1227 ;   THEM TO THE OUTPUT DEVICE.  IT CONTINUES UNTIL THE
                    1227   1228 ;   MODE KEY IS DEPRESSED.
                    1228   1229 ;
c527  =             1229   1230 TLIST   EQU     $       ;PRODUCE A LIST OF FILES ON A TAPE
c527  cd 51 c4      1230   1231         CALL    NAME0   ;GET UNIT IF ANY (NAME IS IGNORED)
c52a  cd 42 c3      1231   1232         CALL    CRLF    ;START ON A FRESH LINE
                    1232   1233 ;
                    1233   1234 ;
c52d  cd 44 c5      1234   1235 LLIST:  CALL    ALOAD
c530  06 01         1235   1236         MVI     B,1
c532  cd ed c7      1236   1237         CALL    TON     ;TURN ON THE TAPE
c535  cd 1f c7      1237   1238 LIST1:  CALL    RHEAD
c538  da 15 c2      1238   1239         JC      COMN1   ;TRUN OFF THE TAPE UNIT
c53b  c2 35 c5      1239   1240         JNZ     LIST1
c53e  cd 4c c5      1240   1241         CALL    NAOUT   ;OUTPUT THE HEADER
c541  c3 2d c5      1241   1242         JMP     LLIST
                    1242   1243 ;
                    1243   1244 ;
                    1244   1245 ;   THIS ROUTINE GETS THE CASSETTE UNIT NUMBER AND
                    1245   1246 ;   SPEED TO REGISTER "A" FOR THE TAPE CALLS
                    1246   1247 ;
c544  21 54 c8      1247   1248 ALOAD:  LXI     H,FNUMF ;POINT TO THE UNIT SPECIFICATION
c547  3a 0d c8      1248   1249         LDA     TSPD    ;GET THE TAPE SPEED
c54a  b6            1249   1250         ORA     M       ;PUT THEM TOGETHER
c54b  c9            1250   1251         RET             ;AND GO BACK
                    1251   1252 ;
                    1252   1253 ;   THIS ROUTINE OUTPUTS THE NAME AND PARAMETERS OF
                    1253   1254 ;   THEAD TO THE OUTPUT DEVICE.
                    1254   1255 ;
                    1255   1256 ;
c54c  16 08         1256   1257 NAOUT:  MVI     D,8
c54e  21 1b c8      1257   1258         LXI     H,THEAD-1 ;POINT TO THE HEADER
c551  cd 66 c5      1258   1259         CALL    NLOOP   ;OUTPUT THE HEADER
c554  cd f7 c3      1259   1260         CALL    BOUT    ;ANOTHER BLANK
c557  2a 25 c8      1260   1261         LHLD    LOADR   ;NOW THE LOAD ADDRESS
c55a  cd d9 c3      1261   1262         CALL    ADOUT   ;PUT IT OUT
c55d  2a 23 c8      1262   1263         LHLD    BLOCK   ;AND THE BLOCK SIZE
c560  cd d9 c3      1263   1264         CALL    ADOUT
c563  c3 42 c3      1264   1265         JMP     CRLF    ;DO THE CRLF AND RETURN
                    1265   1266 ;
                    1266   1267 ;
c566  7e            1267   1268 NLOOP:  MOV     A,M     ;GET CHARACTER
c567  b7            1268   1269         ORA     A
c568  c2 6d c5      1269   1270         JNZ     CHRLI   ;IF IT ISN'T A ZERO
c56b  3e 20         1270   1271         MVI     A,' '   ;SPACE OTHERWISE
c56d  =             1271   1272 CHRLI   EQU     $       ;CHAR IS OK TO SEND
c56d  cd 10 c4      1272   1273         CALL    OUTH    ;OUTPUT IT FROM A REG
c570  23            1273   1274         INX     H
c571  15            1274   1275         DCR     D
c572  c2 66 c5      1275   1276         JNZ     NLOOP
c575  c9            1276   1277         RET
                    1277   1278 ;
                    1278   1279 ;
                    1279   1280 ;
                    1280   1281 ;
                    1281   1282 ;      "SET" COMMAND
                    1282   1283 ;
                    1283   1284 ;   THIS ROUTINE GETS THE ASSOCIATED PARAMETER AND
                    1284   1285 ;   DISPATCHES TO THE PROPER ROUTINE FOR SETTING
                    1285   1286 ;   MEMORY VALUES.
                    1286   1287 ;
c576  cd 59 c3      1287   1288 CSET:   CALL    SBLK    ;SCAN TO SECONDARY COMMAND
c579  ca 6b c4      1288   1289         JZ      ERR1    ;MUST HAVE AT LEAST SOMETHING!!
c57c  d5            1289   1290         PUSH    D       ;SAVE SCAN ADDRESS
c57d  cd 78 c3      1290   1291         CALL    SCONV   ;CONVERT FOLLOWING VALUE
c580  e3            1291   1292         XTHL            ;HL=SAVED SCAN ADDR AND STACK=VALUE
c581  11 11 c3      1292   1293         LXI     D,SETAB ;SECONDARY COMMAND TABLE
c584  cd 91 c2      1293   1294         CALL    FDCOM   ;TRY TO LOCATE IT
c587  c3 82 c2      1294   1295         JMP     DISP0   ;OFF TO IT OR ERROR IF NOT IN TBL
                    1295   1296 ;
                    1296   1297 ;
                    1297   1298 ;  THIS ROUTINE SETS THE TAPE SPEED
                    1298   1299 ;
c58a  =             1299   1300 TASPD   EQU     $       ;GET CONVERTED VALUE
c58a  b7            1300   1301         ORA     A       ;IS IT ZERO?
c58b  ca 90 c5      1301   1302         JZ      SETSP   ;YES--THAT IS A PROPER SPEED
c58e  3e 20         1302   1303         MVI     A,32    ;NO--SET SPEED PROPERLY THEN
c590  32 0d c8      1303   1304 SETSP:  STA     TSPD
c593  c9            1304   1305         RET
                    1305   1306 ;
                    1306   1307 ;
c594  =             1307   1308 STSPD   EQU     $       ;VDM ESCAPE SEQUENCE COMES HERE
c594  78            1308   1309         MOV     A,B     ;GET CHAR FOR FOLLOWING DISPD
c595  =             1309   1310 DISPD   EQU     $       ;SET DISPLAY SPEED
c595  32 0b c8      1310   1311         STA     SPEED
c598  c9            1311   1312         RET
                    1312   1313 ;
                    1313   1314 ;
c599  =             1314   1315 SETIN   EQU     $       ;SET AN INPUT PSUEDO PORT
c599  32 06 c8      1315   1316         STA     IPORT
c59c  c9            1316   1317         RET
                    1317   1318 ;
                    1318   1319 ;
c59d  =             1319   1320 SETOT   EQU     $       ;SET AN OUTPUT PSUEDO PORT
c59d  32 07 c8      1320   1321         STA     OPORT
c5a0  c9            1321   1322         RET
                    1322   1323 ;
                    1323   1324 ;
c5a1  =             1324   1325 SETCI   EQU     $       ;DEFINE USER INPUT RTN ADDR
c5a1  22 00 c8      1325   1326         SHLD    UIPRT
c5a4  c9            1326   1327         RET
                    1327   1328 ;
                    1328   1329 ;
c5a5  =             1329   1330 SETCO   EQU     $       ;DEFINE USER OUTPUT RTN ADDR
c5a5  22 02 c8      1330   1331         SHLD    UOPRT
c5a8  c9            1331   1332         RET
                    1332   1333 ;
                    1333   1334 ;
c5a9  =             1334   1335 SETTY   EQU     $       ;SET TAPE HDR TYPE
c5a9  32 22 c8      1335   1336         STA     HTYPE
c5ac  c9            1336   1337         RET
                    1337   1338 ;
                    1338   1339 ;
c5ad  =             1339   1340 SETXQ   EQU     $       ;SET TAPE-EXECUTE ADDDR FOR HDR
c5ad  22 27 c8      1340   1341         SHLD    XEQAD
c5b0  c9            1341   1342         RET
                    1342   1343 ;
                    1343   1344 ;
c5b1  =             1344   1345 SETNU   EQU     $       ;HERE TO SET NUMBER OF NULLS
c5b1  32 10 c8      1345   1346         STA     NUCNT   ;THIS IS IT
c5b4  c9            1346   1347         RET
                    1347   1348 ;
                    1348   1349 ;
c5b5  =             1349   1350 SETCR   EQU     $       ;SET CRC TO BE NORMAL, OR IGNORE CRC ERRORS
c5b5  32 11 c8      1350   1351         STA     IGNCR   ;FF=IGNORE CRC ERRORS, ELSE=NORMAL
c5b8  c9            1351   1352         RET
                    1352   1353 ;
                    1353   1354 ;
c5b9  =             1354   1355 CUSET   EQU     $       ;TRY TO SET/CLEAR CUSTOM ROUTINE ADDR
c5b9  cd 51 c4      1355   1356         CALL    NAME0   ;GET A NAME (S/B 2 CHARS OR MORE)
c5bc  21 18 c2      1356   1357         LXI     H,COMND ;PT HERE IN CASE ADDR NOT GIVEN
c5bf  cd a5 c3      1357   1358         CALL    PSCAN   ;GET OPTIONAL OPERAND IF ANY
c5c2  e5            1358   1359         PUSH    H       ;SAVE THAT VALUE (IF ANY)
c5c3  21 1c c8      1359   1360         LXI     H,THEAD ;PT TO NAME
c5c6  cd 8e c2      1360   1361         CALL    FDCOU   ;SEE IF NAME IS KNOWN IN CUST TABLE
c5c9  ca cf c5      1361   1362         JZ      CUSE2   ;NO--PROCEED TO KNOW IT
c5cc  1b            1362   1363         DCX     D       ;DE PT TO 1ST CHAR OF NAME IN TBL
c5cd  36 00         1363   1364         MVI     M,0     ;(HL CAME BACK PT'ING TO THEAD)  CLR THIS NAME
c5cf  =             1364   1365 CUSE2   EQU     $       ;ENTER NEW ONE IN TBL
c5cf  7e            1365   1366         MOV     A,M     ;GET 1ST CHAR OF NAME
c5d0  12            1366   1367         STAX    D       ;PUT NAME INTO TABLE
c5d1  13            1367   1368         INX     D
c5d2  23            1368   1369         INX     H
c5d3  7e            1369   1370         MOV     A,M     ;GET 2ND CHAR OF NAME
c5d4  12            1370   1371         STAX    D       ;NAME IS NOW POSTED
c5d5  13            1371   1372         INX     D       ;PT TO 1ST BYTE OF ADDR
c5d6  e1            1372   1373         POP     H       ;RESTORE SAVED RTN ADDR
c5d7  eb            1373   1374         XCHG            ;DE=RTN ADDR, HL=THIS CU ENTRY
c5d8  73            1374   1375         MOV     M,E     ;LO BYTE
c5d9  23            1375   1376         INX     H
c5da  72            1376   1377         MOV     M,D     ;AND HI BYTE
c5db  c9            1377   1378         RET             ;ALL DONE
                    1378   1379 ;
                    1379   1380 ;
                    1380   1381 ; -*-
                    1381   1382 ;
                    1382   1383 ;
                    1383   1384 ;
                    1384   1385 ;
                    1385   1386 ;   THE FOLLOWING ROUTINES PROVIDE "BYTE BY BYTE" ACCESS
                    1386   1387 ;  TO THE CASSETTE TAPES ON EITHER A READ OR WRITE BASIS.
                    1387   1388 ;
                    1388   1389 ;  THE TAPE IS READ ONE BLOCK AT A TIME AND INDIVIDUAL
                    1389   1390 ;  TRANSFERS OF DATA HANDLED BY MANAGING A BUFFER AREA.
                    1390   1391 ;
                    1391   1392 ;  THE BUFFER AREA IS CONTROLLED BY A FILE CONTROL BLOCK
                    1392   1393 ;  (FCB) WHOSE STRUCTURE IS:
                    1393   1394 ;
                    1394   1395 ;
                    1395   1396 ;     7 BYTES FOR EACH OF THE TWO FILES STRUCTURED AS
                    1396   1397 ;   FOLLOWS:
                    1397   1398 ;
                    1398   1399 ;         1 BYTE -  ACCESS CONTROL   00 IF CLOSED
                    1399   1400 ;                                    FF IF READING
                    1400   1401 ;                                    FE IF WRITING
                    1401   1402 ;         1 BYTE -  READ COUNTER
                    1402   1403 ;         1 BYTE -  BUFFER POSITION POINTER
                    1403   1404 ;         2 BYTE -  CONTROL HEADER ADDRESS
                    1404   1405 ;         2 BYTE -  BUFFER LOCATION ADDRESS
                    1405   1406 ;
                    1406   1407 ;
                    1407   1408 ;
                    1408   1409 ;        THIS ROUTINE "OPENS" THE CASSETTE UNIT FOR ACCESS
                    1409   1410 ;
                    1410   1411 ;   ON ENTRY:  A - HAS THE TAPE UNIT NUMBER (1 OR 2)
                    1411   1412 ;             HL - HAS USER SUPPLIED HEADER FOR TAPE FILE
                    1412   1413 ;
                    1413   1414 ;
                    1414   1415 ;   NORMAL RETURN:   ALL REGISTERS ARE ALTERED
                    1415   1416 ;                    BLOCK IS READY FOR ACCESS
                    1416   1417 ;
                    1417   1418 ;   ERROR RETURN:    CARRY BIT IS SET
                    1418   1419 ;
                    1419   1420 ;   ERRORS:  BLOCK ALREADY OPEN
                    1420   1421 ;
                    1421   1422 ;
c5dc  e5            1422   1423 BOPEN:  PUSH    H       ;SAVE HEADER ADDRESS
c5dd  cd 2f c6      1423   1424         CALL    LFCB    ;GET ADDRESS OF FILE CONTROL
c5e0  c2 f6 c5      1424   1425         JNZ     TERE2   ;FILE WAS ALREADY OPEN
c5e3  36 01         1425   1426         MVI     M,1     ;NOW IT IS
c5e5  23            1426   1427         INX     H       ;POINT TO READ COUNT
c5e6  77            1427   1428         MOV     M,A     ;ZERO
c5e7  23            1428   1429         INX     H       ;POINT TO BUFFER CURSOR
c5e8  77            1429   1430         MOV     M,A     ;PUT IN THE ZERO COUNT
                    1430   1431 ;
                    1431   1432 ;  ALLOCATE THE BUFFER
                    1432   1433 ;
c5e9  11 63 c8      1433   1434         LXI     D,FBUF1 ;POINT TO BUFFER AREA
c5ec  3a 54 c8      1434   1435         LDA     FNUMF   ;GET WHICH ONE WE ARE GOING TO USE
c5ef  82            1435   1436         ADD     D
c5f0  57            1436   1437         MOV     D,A     ;256 BIT ADD
                    1437   1438 ;
c5f1  c1            1438   1439 UBUF:   POP     B       ;HEADER ADDRESS
c5f2  b7            1439   1440         ORA     A       ;CLEAR CARRY AND RETURN AFTER STORING PARAMS
c5f3  c3 b2 c6      1440   1441         JMP     PSTOR   ;STORE THE VALUES
                    1441   1442 ;
                    1442   1443 ;    GENERAL ERROR RETURN POINTS FOR STACK CONTROL
                    1443   1444 ;
c5f6  e1            1444   1445 TERE2:  POP     H
c5f7  d1            1445   1446 TERE1:  POP     D
c5f8  af            1446   1447 TERE0:  XRA     A       ;CLEAR ALL FLAGS
c5f9  37            1447   1448         STC             ;SET ERROR
c5fa  c9            1448   1449         RET
                    1449   1450 ;
                    1450   1451 ;
c5fb  3d            1451   1452 EOFER:  DCR     A       ;SET MINUS FLAGS
c5fc  37            1452   1453         STC             ;AND CARRY
c5fd  d1            1453   1454         POP     D       ;CLEAR THE STACK
c5fe  c9            1454   1455         RET             ;THE FLAGS TELL ALL
                    1455   1456 ;
                    1456   1457 ;
                    1457   1458 ;
                    1458   1459 ;
                    1459   1460 ;   THIS ROUTINE CLOSES THE FILE BUFFER TO ALLOW ACCESS
                    1460   1461 ;   FOR A DIFFERENT CASSETTE OR PROGRAM.  IF THE FILE
                    1461   1462 ;   OPERATIONS WERE "WRITE" THEN THE LAST BLOCK IS WRITTED
                    1462   1463 ;   OUT AND AN "END OF FILE" WRITTEN TO THE TAPE.  IF
                    1463   1464 ;   THE OPERATIONS WERE "READS" THEN THE FILE IS JUST
                    1464   1465 ;   MADE READY FOR NEW USE.
                    1465   1466 ;
                    1466   1467 ;   ON ENTRY:  A - HAS WHICH UNIT (1 OR 2)
                    1467   1468 ;
                    1468   1469 ;   ERROR RETURNS:  FILE WASN'T OPEN
                    1469   1470 ;
                    1470   1471 ;
c5ff  cd 2f c6      1471   1472 PCLOS:  CALL    LFCB    ;GET CONTROL BLOCK ADDRESS
c602  c8            1472   1473         RZ              ;WASN'T OPEN, CARRY IS SET FROM LFCB
c603  b7            1473   1474         ORA     A       ;CLEAR CARRY
c604  3c            1474   1475         INR     A       ;SET CONDITION FLAGS
c605  36 00         1475   1476         MVI     M,0     ;CLOSE THE CONTROL BYTE
c607  c8            1476   1477         RZ              ;WE WERE READING...NOTHING MORE TO DO
                    1477   1478 ;
                    1478   1479 ;    THE FILE OPERATIONS WERE "WRITES"
                    1479   1480 ;
                    1480   1481 ;  PUT THE CURRENT BLOCK ON THE TAPE
                    1481   1482 ;  (EVEN IF ONLY ONE BYTE)
                    1482   1483 ;  THEN WRITE AN END OF FILE TO THE TAPE
                    1483   1484 ;
                    1484   1485 ;
c608  23            1485   1486         INX     H
c609  23            1486   1487         INX     H
c60a  7e            1487   1488         MOV     A,M     ;GET CURSOR POSITION
c60b  7e            1488   1489         MOV     A,M     ;GET CURSOR POSITION
c60c  cd bb c6      1489   1490         CALL    PLOAD   ;BC GET HEADER ADDRESS, DE BUFFER ADDRESS
c60f  c5            1490   1491         PUSH    B       ;HEADER TO STACK
c610  21 07 00      1491   1492         LXI     H,BLKOF ;OFFSET TO BLOCK SIZE
c613  09            1492   1493         DAD     B
c614  b7            1493   1494         ORA     A       ;TEST COUNT
c615  ca 27 c6      1494   1495         JZ      EOFW    ;NO BYTES...JUST WRITE EOF
                    1495   1496 ;
                    1496   1497 ;    WRITE LAST BLOCK
                    1497   1498 ;
c618  e5            1498   1499         PUSH    H       ;SAVE BLOCK SIZE POINTER FOR EOF
c619  77            1499   1500         MOV     M,A     ;PUT IN COUNT
c61a  23            1500   1501         INX     H
c61b  36 00         1501   1502         MVI     M,0     ;ZERO THE HIGHER BYTE
c61d  23            1502   1503         INX     H
c61e  73            1503   1504         MOV     M,E     ;BUFFER ADDRESS
c61f  23            1504   1505         INX     H
c620  72            1505   1506         MOV     M,D
c621  60            1506   1507         MOV     H,B
c622  69            1507   1508         MOV     L,C     ;PUT HEADER ADDRESS IN HL
c623  cd 79 c7      1508   1509         CALL    WFBLK   ;GO WRITE IT OUT
c626  e1            1509   1510         POP     H       ;BLOCK SIZE POINTER
                    1510   1511 ;
                    1511   1512 ;   NOW WRITE END OF FILE TO CASSETTE
                    1512   1513 ;
c627  af            1513   1514 EOFW:   XRA     A       ;PUT IN ZEROS FOR SIZE:  EOF MARK IS ZERO BYTES!
c628  77            1514   1515         MOV     M,A
c629  23            1515   1516         INX     H
c62a  77            1516   1517         MOV     M,A
c62b  e1            1517   1518         POP     H       ;HEADER ADDRESS
c62c  c3 79 c7      1518   1519         JMP     WFBLK   ;WRITE IT OUT AND RETURN
                    1519   1520 ;
                    1520   1521 ;
                    1521   1522 ;
                    1522   1523 ;
                    1523   1524 ;   THIS ROUTINE LOCATES THE FILE CONTROL BLOCK POINTED TO
                    1524   1525 ;   BY REGISTER "A".  ON RETURN HL POINT TO THE CONTROL BYT
                    1525   1526 ;   AND REGISTER "A" HAS THE CONTROL WORD WITH THE FLAGS
                    1526   1527 ;   SET FOR IMMEDIATE CONDITION DECISIONS.
                    1527   1528 ;
                    1528   1529 ;
c62f  21 55 c8      1529   1530 LFCB:   LXI     H,FCBAS ;POINT TO THE BASE OF IT
c632  1f            1530   1531         RAR             ;MOVE THE 1 & 2 TO 0 & 1 LIKE COMPUTERS LIKE
c633  e6 01         1531   1532         ANI     1       ;SMALL NUMBERS ARE THE RULE
c635  32 54 c8      1532   1533         STA     FNUMF   ;CURRENT ACCESS FILE NUMBER
c638  ca 3e c6      1533   1534         JZ      LFCB1   ;UNIT ONE (VALUE OF ZERO)
c63b  21 5c c8      1534   1535         LXI     H,FCBA2 ;UNIT TWO--PT TO ITS FCB
c63e  =             1535   1536 LFCB1   EQU     $       ;HL PT TO PROPER FCB
c63e  7e            1536   1537         MOV     A,M     ;PICK UP FLAGS FM FCB
c63f  b7            1537   1538         ORA     A       ;SET FLAGS BASED ON CONTROL WORD
c640  37            1538   1539         STC             ;SET CARRY IN CASE OF IMMEDIATE ERROR RETURN
c641  c9            1539   1540         RET
                    1540   1541 ;
                    1541   1542 ;
                    1542   1543 ;
                    1543   1544 ;
                    1544   1545 ;    READ TAPE BYTE ROUTINE
                    1545   1546 ;
                    1546   1547 ;    ENTRY:       -  A -  HAS FILE NUMBER
                    1547   1548 ;    EXIT: NORMAL -  A -  HAS BYTE
                    1548   1549 ;          ERROR
                    1549   1550 ;            CARRY SET     - IF FILE NOT OPEN OR
                    1550   1551 ;                            PREVIOUS OPERATIONS WERE WRITE
                    1551   1552 ;            CARRY & MINUS - END OF FILE ENCOUNTERED
                    1552   1553 ;
                    1553   1554 ;
                    1554   1555 ;
                    1555   1556 ;
c642  cd 2f c6      1556   1557 RTBYT:  CALL    LFCB    ;LOCATE THE FILE CONTROL BLOCK
c645  c8            1557   1558         RZ              ;FILE NOT OPEN
c646  3c            1558   1559         INR     A       ;TEST IF FF
c647  fa f8 c5      1559   1560         JM      TERE0   ;ERROR WAS WRITING
c64a  36 ff         1560   1561         MVI     M,(-1) AND 0FFH ;SET IT AS READ  (IN CASE IT WAS JUST OPENED)
c64c  23            1561   1562         INX     H
c64d  7e            1562   1563         MOV     A,M     ;GET READ COUNT
c64e  e5            1563   1564         PUSH    H       ;SAVE COUNT ADDRESS
c64f  23            1564   1565         INX     H
c650  cd bb c6      1565   1566         CALL    PLOAD   ;GET THE OTHER PARAMETERS
c653  e1            1566   1567         POP     H
c654  b7            1567   1568         ORA     A
c655  c2 71 c6      1568   1569         JNZ     GTBYT   ;IF NOT EMPTY GO GET BYTE
                    1569   1570 ;
                    1570   1571 ;  CURSOR POSITION WAS ZERO...READ A NEW BLOCK INTO
                    1571   1572 ;  THE BUFFER.
                    1572   1573 ;
c658  d5            1573   1574 RDNBLK: PUSH    D       ;BUFFER POINTER
c659  e5            1574   1575         PUSH    H       ;TABLE ADDRESS
c65a  23            1575   1576         INX     H
c65b  cd a2 c6      1576   1577         CALL    PHEAD   ;PREPARE THE HEADER FOR READ
c65e  cd c4 c6      1577   1578         CALL    RFBLK   ;READ IN THE BLOCK
c661  da f6 c5      1578   1579         JC      TERE2   ;ERROR POP OFF STACK BEFORE RETURN
c664  e1            1579   1580         POP     H
c665  7b            1580   1581         MOV     A,E     ;LOW BYTE OF COUNT (WILL BE ZERO IF 256)
c666  b2            1581   1582         ORA     D       ;SEE IF BOTH ARE ZERO
c667  ca fb c5      1582   1583         JZ      EOFER   ;BYTE COUNT WAS ZERO....END OF FILE
c66a  73            1583   1584         MOV     M,E     ;NEW COUNT ( ZERO IS 256 AT THIS POINT)
c66b  23            1584   1585         INX     H       ;BUFFER LOCATION POINTER
c66c  36 00         1585   1586         MVI     M,0
c66e  2b            1586   1587         DCX     H
c66f  7b            1587   1588         MOV     A,E     ;COUNT TO A
c670  d1            1588   1589         POP     D       ;GET BACK BUFFER ADDRESS
                    1589   1590 ;
                    1590   1591 ;
                    1591   1592 ;
                    1592   1593 ;   THIS ROUTINE GETS ONE BYTE FROM THE BUFFER
                    1593   1594 ;  AND RETURNS IT IN REGISTER "A".  IF THE END
                    1594   1595 ;  OF THE BUFFER IS REACHED IT MOVES THE POINTER
                    1595   1596 ;  TO THE BEGINNING OF THE BUFFER FOR THE NEXT
                    1596   1597 ;  LOAD.
                    1597   1598 ;
c671  3d            1598   1599 GTBYT:  DCR     A       ;BUMP THE COUNT
c672  77            1599   1600         MOV     M,A     ;RESTORE IT
c673  23            1600   1601         INX     H
c674  7e            1601   1602         MOV     A,M     ;GET BUFFER POSITION
c675  34            1602   1603         INR     M       ;BUMP IT
                    1603   1604 ;
c676  83            1604   1605         ADD     E
c677  5f            1605   1606         MOV     E,A     ;DE NOW POINT TO CORRECT BUFFER POSITION
c678  d2 7c c6      1606   1607         JNC     RT1
c67b  14            1607   1608         INR     D
c67c  1a            1608   1609 RT1:    LDAX    D       ;GET CHARACTER FROM BUFFER
c67d  b7            1609   1610         ORA     A       ;CLEAR CARRY
c67e  c9            1610   1611         RET             ;ALL DONE
                    1611   1612 ;
                    1612   1613 ;
                    1613   1614 ;
                    1614   1615 ;
                    1615   1616 ;      THIS ROUTINE IS USED TO WRITE A BYTE TO THE FILE
                    1616   1617 ;
                    1617   1618 ;      ON ENTRY:   A -  HAS FILE NUMBER
                    1618   1619 ;                  B -  HAS DATA BYTE
                    1619   1620 ;
                    1620   1621 ;
c67f  cd 2f c6      1621   1622 WTBYT:  CALL    LFCB    ;GET CONTROL BLOCK
c682  c8            1622   1623         RZ              ;FILE WASN'T OPEN
c683  3c            1623   1624         INR     A
c684  c8            1624   1625         RZ              ;FILE WAS READ
c685  36 fe         1625   1626         MVI     M,0FEH  ;SET IT TO WRITE
c687  23            1626   1627         INX     H
c688  23            1627   1628         INX     H
c689  78            1628   1629         MOV     A,B     ;GET CHARACTER
c68a  f5            1629   1630         PUSH    PSW
c68b  e5            1630   1631         PUSH    H       ;SAVE CONTROL ADDRESS+2
                    1631   1632 ;
                    1632   1633 ;   NOW DO THE WRITE
                    1633   1634 ;
c68c  cd bb c6      1634   1635         CALL    PLOAD   ;BC GETS HEADER ADDR, DE BUFFER ADDRESS
c68f  e1            1635   1636         POP     H
c690  7e            1636   1637         MOV     A,M     ;COUNT BYTE
c691  83            1637   1638         ADD     E
c692  5f            1638   1639         MOV     E,A
c693  d2 97 c6      1639   1640         JNC     WT1
c696  14            1640   1641         INR     D
c697  f1            1641   1642 WT1:    POP     PSW     ;CHARACTER
c698  12            1642   1643         STAX    D       ;PUT CHR IN BUFFER
c699  b7            1643   1644         ORA     A       ;CLEAR FLAGS
c69a  34            1644   1645         INR     M       ;INCREMENT THE COUNT
c69b  c0            1645   1646         RNZ             ;RETURN IF COUNT DIDN'T ROLL OVER
                    1646   1647 ;
                    1647   1648 ;   THE BUFFER IS FULL. WRITE IT TO TAPE AND RESET
                    1648   1649 ;  CONTROL BLOCK.
                    1649   1650 ;
c69c  cd a2 c6      1650   1651         CALL    PHEAD   ;PREPARE THE HEADER
c69f  c3 79 c7      1651   1652         JMP     WFBLK   ;WRITE IT OUT AND RETURN
                    1652   1653 ;
                    1653   1654 ;
                    1654   1655 ;
                    1655   1656 ;
                    1656   1657 ;  THIS ROUTINE PUTS THE BLOCK SIZE (256) AND BUFFER
                    1657   1658 ;  ADDRESS IN THE FILE HEADER.
                    1658   1659 ;
c6a2  cd bb c6      1659   1660 PHEAD:  CALL    PLOAD   ;GET HEADER AND BUFFER ADDRESSES
c6a5  c5            1660   1661         PUSH    B       ;HEADER ADDRESS
c6a6  21 06 00      1661   1662         LXI     H,BLKOF-1 ;PSTOR DOES AN INCREMENT
c6a9  09            1662   1663         DAD     B       ;HL POINT TO BLOCKSIZE ENTRY
c6aa  01 00 01      1663   1664         LXI     B,256
c6ad  cd b2 c6      1664   1665         CALL    PSTOR
c6b0  e1            1665   1666         POP     H       ;HL RETURN WITH HEADER ADDRESS
c6b1  c9            1666   1667         RET
                    1667   1668 ;
                    1668   1669 ;
c6b2  23            1669   1670 PSTOR:  INX     H
c6b3  71            1670   1671         MOV     M,C
c6b4  23            1671   1672         INX     H
c6b5  70            1672   1673         MOV     M,B
c6b6  23            1673   1674         INX     H
c6b7  73            1674   1675         MOV     M,E
c6b8  23            1675   1676         INX     H
c6b9  72            1676   1677         MOV     M,D
c6ba  c9            1677   1678         RET
                    1678   1679 ;
                    1679   1680 ;
c6bb  23            1680   1681 PLOAD:  INX     H
c6bc  4e            1681   1682         MOV     C,M
c6bd  23            1682   1683         INX     H
c6be  46            1683   1684         MOV     B,M
c6bf  23            1684   1685         INX     H
c6c0  5e            1685   1686         MOV     E,M
c6c1  23            1686   1687         INX     H
c6c2  56            1687   1688         MOV     D,M
c6c3  c9            1688   1689         RET
                    1689   1690 ;
                    1690   1691 ;
                    1691   1692 ;
                    1692   1693 ;
                    1693   1694 ;
                    1694   1695 ;   THIS ROUTINE SETS THE CORRECT UNIT FOR SYSTEM READS
c6c4  cd dc c7      1695   1696 RFBLK:  CALL    GTUNT   ;SET UP A=UNIT WITH SPEED
                    1696   1697 ;
                    1697   1698 ;
                    1698   1699 ;
                    1699   1700 ;
                    1700   1701 ;              TAPE READ ROUTINES
                    1701   1702 ;
                    1702   1703 ;     ON-ENTRY:     A HAS UNIT AND SPEED
                    1703   1704 ;                   HL POINT TO HEADER BLOCK
                    1704   1705 ;                   DE HAVE OPTIONAL PUT ADDRESS
                    1705   1706 ;
                    1706   1707 ;     ON EXIT:      CARRY IS SET IF ERROR OCCURED
                    1707   1708 ;                   TAPE UNITS ARE OFF
                    1708   1709 ;
                    1709   1710 ;
c6c7  d5            1710   1711 RTAPE:  PUSH    D       ;SAVE OPTIONAL ADDRESS
c6c8  06 03         1711   1712         MVI     B,3     ;SHORT DELAY
c6ca  cd ed c7      1712   1713         CALL    TON
c6cd  db 07         1713   1714         IN      TDATA   ;CLEAR THE UART FLAGS
                    1714   1715 ;
c6cf  e5            1715   1716 PTAP1:  PUSH    H       ;HEADER ADDRESS
c6d0  cd 1f c7      1716   1717         CALL    RHEAD   ;GO READ HEADER
c6d3  e1            1717   1718         POP     H
c6d4  da 02 c7      1718   1719         JC      TERR    ;IF AN ERROR OR ESC WAS RECEIVED
c6d7  c2 cf c6      1719   1720         JNZ     PTAP1   ;IF VALID HEADER NOT FOUND
                    1720   1721 ;
                    1721   1722 ;  FOUND A VALID HEADER NOW DO COMPARE
                    1722   1723 ;
c6da  e5            1723   1724         PUSH    H       ;GET BACK AND RESAVE ADDRESS
c6db  11 1c c8      1724   1725         LXI     D,THEAD
c6de  cd d0 c7      1725   1726         CALL    DHCMP   ;COMPARE DE-HL HEADERS
c6e1  e1            1726   1727         POP     H
c6e2  c2 cf c6      1727   1728         JNZ     PTAP1
                    1728   1729 ;
                    1729   1730 ;
c6e5  d1            1730   1731         POP     D       ;OPTIONAL "PUT" ADDRESS
c6e6  7a            1731   1732         MOV     A,D
c6e7  b3            1732   1733         ORA     E       ;SEE IF DE IS ZERO
c6e8  2a 23 c8      1733   1734         LHLD    BLOCK   ;GET BLOCK SIZE
c6eb  eb            1734   1735         XCHG            ;...TO DE
                    1735   1736 ;  DE HAS HBLOCK....HL HAS USER OPTION
c6ec  c2 f2 c6      1736   1737         JNZ     RTAP    ;IF DE WAS ZERO GET TAPE LOAD ADDRESS
c6ef  2a 25 c8      1737   1738         LHLD    LOADR   ;GET TAPE LOAD ADDRESS
                    1738   1739 ;
                    1739   1740 ;
                    1740   1741 ;     THIS ROUTINE READS "DE" BYTES FROM THE TAPE
                    1741   1742 ;     TO ADDRESS HL.  THE BYTES MUST BE FROM ONE
                    1742   1743 ;     CONTIGUOUS PHYSICAL BLOCK ON THE TAPE.
                    1743   1744 ;
                    1744   1745 ;          HL HAS "PUT" ADDRESS
                    1745   1746 ;          DE HAS SIZE OF TAPE BLOCK
                    1746   1747 ;
c6f2  d5            1747   1748 RTAP:   PUSH    D       ;SAVE SIZE FOR RETURN TO CALLING PROGRAM
                    1748   1749 ;
c6f3  =             1749   1750 RTAP2   EQU     $       ;HERE TO LOOP RDING BLKS
c6f3  cd 11 c7      1750   1751         CALL    DCRCT   ;DROP COUNT, B=LEN THIS BLK
c6f6  ca 0c c7      1751   1752         JZ      RTOFF   ;ZERO=ALL DONE
                    1752   1753 ;
c6f9  cd 40 c7      1753   1754         CALL    RHED1   ;READ THAT MANY BYTES
c6fc  da 02 c7      1754   1755         JC      TERR    ;IF ERROR OR ESC
c6ff  ca f3 c6      1755   1756         JZ      RTAP2   ;RD OK--READ SOME MORE
                    1756   1757 ;
                    1757   1758 ;  ERROR RETURN
                    1758   1759 ;
c702  af            1759   1760 TERR:   XRA     A
c703  37            1760   1761         STC             ;SET ERROR FLAGS
c704  c3 0d c7      1761   1762         JMP     RTOF1
                    1762   1763 ;
                    1763   1764 ;
c707  06 01         1764   1765 TOFF:   MVI     B,1
c709  cd ef c7      1765   1766         CALL    DELAY
c70c  af            1766   1767 RTOFF:  XRA     A
c70d  d3 06         1767   1768 RTOF1:  OUT     TAPPT
c70f  d1            1768   1769         POP     D       ;RETURN BYTE COUNT
c710  c9            1769   1770         RET
                    1770   1771 ;
                    1771   1772 ;
c711  =             1772   1773 DCRCT   EQU     $       ;COMMON RTN TO COUNT DOWN BLK LENGTHS
c711  af            1773   1774         XRA     A       ;CLR FOR LATER TESTS
c712  47            1774   1775         MOV     B,A     ;SET THIS BLK LEN=256
c713  b2            1775   1776         ORA     D       ;IS AMNT LEFT < 256
c714  c2 1c c7      1776   1777         JNZ     DCRC2   ;NO--REDUCE AMNT BY 256
c717  b3            1777   1778         ORA     E       ;IS ENTIRE COUNT ZERO
c718  c8            1778   1779         RZ              ;ALL DONE--ZERO=THIS CONDITION
c719  43            1779   1780         MOV     B,E     ;SET THIS BLK LEN TO AMNT REMAINING
c71a  5a            1780   1781         MOV     E,D     ;MAKE ENTIRE COUNT ZERO NOW
c71b  c9            1781   1782         RET             ;ALL DONE (NON-ZERO FLAG)
c71c  =             1782   1783 DCRC2   EQU     $       ;REDUCE COUNT BY 256
c71c  15            1783   1784         DCR     D       ;DROP BY 256
c71d  b7            1784   1785         ORA     A       ;FORCE NON-ZERO FLAG
c71e  c9            1785   1786         RET             ;NON-ZERO=NOT DONE YET (BLK LEN=256)
                    1786   1787 ;
                    1787   1788 ;
                    1788   1789 ;   READ THE HEADER
                    1789   1790 ;
c71f  06 0a         1790   1791 RHEAD:  MVI     B,10    ;FIND 10 NULLS
c721  cd 59 c7      1791   1792 RHEA1:  CALL    STAT
c724  d8            1792   1793         RC              ;IF ESCAPE
c725  db 07         1793   1794         IN      TDATA   ;IGNORE ERROR CONDITIONS
c727  b7            1794   1795         ORA     A       ;ZERO?
c728  c2 1f c7      1795   1796         JNZ     RHEAD
c72b  05            1796   1797         DCR     B
c72c  c2 21 c7      1797   1798         JNZ     RHEA1   ;LOOP UNTIL 10 IN A ROW
                    1798   1799 ;
                    1799   1800 ;    WAIT FOR THE START CHARACTER
                    1800   1801 ;
c72f  cd 6c c7      1801   1802 SOHL:   CALL    TAPIN
c732  d8            1802   1803         RC              ;ERROR OR ESCAPE
c733  fe 01         1803   1804         CPI     1       ;ARE WE AT THE 01 YET (START CHAR)
c735  da 2f c7      1804   1805         JC      SOHL    ;NO, BUT STIL ZEROES
c738  c2 1f c7      1805   1806         JNZ     RHEAD   ;NO, LOOK FOR ANOTHER 10 NULLS
                    1806   1807 ;
                    1807   1808 ;    WE HAVE  10 (OR MORE) NULLS FOLLOWED IMMEDIATELY
                    1808   1809 ;    BY AN 01.  NOW READ THE HEADER.
                    1809   1810 ;
c73b  21 1c c8      1810   1811         LXI     H,THEAD ;POINT TO BUFFER
c73e  06 10         1811   1812         MVI     B,HLEN  ;LENGTH TO READ
                    1812   1813 ;
c740  =             1813   1814 RHED1   EQU     $       ;RD A BLOCK INTO HL FOR B BYTES
c740  0e 00         1814   1815         MVI     C,0     ;INIT THE CRC
c742  =             1815   1816 RHED2   EQU     $       ;LOOP HERE
c742  cd 6c c7      1816   1817         CALL    TAPIN   ;GET A BYTE
c745  d8            1817   1818         RC
c746  77            1818   1819         MOV     M,A     ;STORE IT
c747  23            1819   1820         INX     H       ;INCREMENT ADDRESS
c748  cd a6 c7      1820   1821         CALL    DOCRC   ;GO COMPUTE THE CRC
c74b  05            1821   1822         DCR     B       ;WHOLE HEADER YET?
c74c  c2 42 c7      1822   1823         JNZ     RHED2   ;DO ALL THE BYTES
                    1823   1824 ;
                    1824   1825 ;   THIS ROUTINE GETS THE NEXT BYTE AND COMPARES IT
                    1825   1826 ; TO THE VALUE IN REGISTER C.  THE FLAGS ARE SET ON
                    1826   1827 ; RETURN.
                    1827   1828 ;
c74f  cd 6c c7      1828   1829         CALL    TAPIN   ;GET CRC BYTE
c752  a9            1829   1830         XRA     C       ;CLR CARRY AND SET ZERO IF MATCH, ELSE NON-ZERO
c753  c8            1830   1831         RZ              ;CRC IS FINE
c754  3a 11 c8      1831   1832         LDA     IGNCR   ;BAD CRC, SHD WE STILL ACCEPT IT
c757  3c            1832   1833         INR     A       ;SEE IF IT WAS FF, IF FF THEN ZERO SAYS IGN ERR
                    1833   1834 ;   NOW, CRC ERR DETECTION DEPENDS ON IGNCR.
c758  c9            1834   1835         RET
                    1835   1836 ;
                    1836   1837 ;    THIS ROUTINE GETS THE NEXT AVAILABLE BYTE FROM THE
                    1837   1838 ;  TAPE.  WHILE WAITING FOR THE BYTE THE KEYBOARD IS TESTED
                    1838   1839 ;  FOR AN ESC COMMAND.  IF RECEIVED THE TAPE LOAD IS
                    1839   1840 ;  TERMINATED AND A RETURN TO THE COMMAND MODE IS MADE.
                    1840   1841 ;
c759  db 06         1841   1842 STAT:   IN      TAPPT   ;TAPE STATUS PORT
c75b  2f            1842   1843         CMA             ;*UM* MITS ACR USES ACTIVE LOW
c75c  e6 01         1843   1844         ANI     TDR
c75e  c0            1844   1845         RNZ
c75f  cd 1f c0      1845   1846         CALL    SINP    ;CHECK INPUT
c762  ca 59 c7      1846   1847         JZ      STAT    ;NOTHING THERE YET
c765  e6 7f         1847   1848         ANI     7FH     ;CLEAR PARITY 1ST
c767  c2 59 c7      1848   1849         JNZ     STAT    ;EITHER MODE OR CTL-@
c76a  37            1849   1850         STC             ;SET ERROR FLAG
c76b  c9            1850   1851         RET             ;AND RETURN
                    1851   1852 ;
                    1852   1853 ;
                    1853   1854 ;
c76c  cd 59 c7      1854   1855 TAPIN:  CALL    STAT    ;WAIT UNTIL A CHARACTER IS AVAILABLE
c76f  d8            1855   1856         RC
                    1856   1857 ;
c770  db 06         1857   1858 TREDY:  IN      TAPPT   ;TAPE STATUS
c772  e6 18         1858   1859         ANI     TFE+TOE ;DATA ERROR?
c774  db 07         1859   1860         IN      TDATA   ;GET THE DATA
c776  c8            1860   1861         RZ              ;IF NO ERRORS
c777  37            1861   1862         STC             ;SET ERROR FLAG
c778  c9            1862   1863         RET
                    1863   1864 ;
                    1864   1865 ;
                    1865   1866 ;  THIS ROUTINE GETS THE CORRECT UNIT FOR SYSTEM WRITES
c779  cd dc c7      1866   1867 WFBLK:  CALL    GTUNT   ;SET UP A WITH UNIT AND SPEED
                    1867   1868 ;
                    1868   1869 ;
                    1869   1870 ;
                    1870   1871 ;       WRITE TAPE BLOCK ROUTINE
                    1871   1872 ;
                    1872   1873 ;   ON ENTRY:   A   HAS UNIT AND SPEED
                    1873   1874 ;              HL   HAS POINTER TO HEADER
                    1874   1875 ;
                    1875   1876 ;
c77c  =             1876   1877 WTAPE   EQU     $       ;HERE TO WRITE TAPE
c77c  e5            1877   1878         PUSH    H       ;SAVE HEADER ADDRESS
c77d  cd ad c7      1878   1879         CALL    WHEAD   ;TURN ON, THEN WRITE HDR
c780  e1            1879   1880         POP     H
c781  11 07 00      1880   1881         LXI     D,BLKOF ;OFFSET TO BLOCK SIZE IN HEADER
c784  19            1881   1882         DAD     D       ;HL POINT TO BLOCK SIZE
c785  5e            1882   1883         MOV     E,M
c786  23            1883   1884         INX     H
c787  56            1884   1885         MOV     D,M     ;DE HAVE SIZE
c788  23            1885   1886         INX     H
c789  7e            1886   1887         MOV     A,M
c78a  23            1887   1888         INX     H
c78b  66            1888   1889         MOV     H,M
c78c  6f            1889   1890         MOV     L,A     ;HL HAVE STARTING ADDRESS
                    1890   1891 ;
                    1891   1892 ;    THIS ROUTINE WRITES ONE PHYSICAL BLOCK ON THE
                    1892   1893 ;  TAPE "DE" BYTES LONG FROM ADDRESS "HL".
                    1893   1894 ;
                    1894   1895 ;
c78d  =             1895   1896 WTAP1   EQU     $       ;HERE FOR THE EXTRA PUSH
c78d  e5            1896   1897         PUSH    H       ;A DUMMY PUSH FOR LATER EXIT
c78e  =             1897   1898 WTAP2   EQU     $       ;LOOP HERE UNTIL ENTIRE AMOUNT READ
c78e  cd 11 c7      1898   1899         CALL    DCRCT   ;DROP COUNT IN DE AND SET UP B W/LEN THIS BLK
c791  ca 07 c7      1899   1900         JZ      TOFF    ;RETURNS ZERO IF ALL DONE
c794  cd c1 c7      1900   1901         CALL    WTBL    ;WRITE BLOCK FOR BYTES IN B (256)
c797  c3 8e c7      1901   1902         JMP     WTAP2   ;LOOP UNTIL ALL DONE
                    1902   1903 ;
                    1903   1904 ;
c79a  f5            1904   1905 WRTAP:  PUSH    PSW
c79b  db 06         1905   1906 WRWAT:  IN      TAPPT   ;TAPE STATUS
c79d  2f            1906   1907         CMA             ;*UM* MITS ACR USES ACTIVE LOW
c79e  e6 80         1907   1908         ANI     TTBE    ;IS TAPE READY FOR A CHAR YET
c7a0  ca 9b c7      1908   1909         JZ      WRWAT   ;NO--WAIT
c7a3  f1            1909   1910         POP     PSW     ;YES--RESTORE CHAR TO OUTPUT
c7a4  d3 07         1910   1911         OUT     TDATA   ;SEND CHAR TO TAPE
                    1911   1912 ;
c7a6  =             1912   1913 DOCRC   EQU     $       ;A COMMON CRC COMPUTATION ROUTINE
c7a6  91            1913   1914         SUB     C
c7a7  4f            1914   1915         MOV     C,A
c7a8  a9            1915   1916         XRA     C
c7a9  2f            1916   1917         CMA
c7aa  91            1917   1918         SUB     C
c7ab  4f            1918   1919         MOV     C,A
c7ac  c9            1919   1920         RET             ;ONE  BYTE NOW WRITTEN
                    1920   1921 ;
                    1921   1922 ;
                    1922   1923 ;   THIS ROUTINE WRITES THE HEADER POINTED TO BY
                    1923   1924 ;   HL TO THE TAPE.
                    1924   1925 ;
c7ad  =             1925   1926 WHEAD   EQU     $       ;HERE TO 1ST TURN ON THE TAPE
c7ad  cd eb c7      1926   1927         CALL    WTON    ;TURN IT ON, THEN WRITE HEADER
c7b0  16 32         1927   1928         MVI     D,50    ;WRITE 50 ZEROS
c7b2  af            1928   1929 NULOP:  XRA     A
c7b3  cd 9a c7      1929   1930         CALL    WRTAP
c7b6  15            1930   1931         DCR     D
c7b7  c2 b2 c7      1931   1932         JNZ     NULOP
                    1932   1933 ;
c7ba  3e 01         1933   1934         MVI     A,1
c7bc  cd 9a c7      1934   1935         CALL    WRTAP
c7bf  06 10         1935   1936         MVI     B,HLEN  ;LENGTH TO WRITE OUT
                    1936   1937 ;
c7c1  0e 00         1937   1938 WTBL:   MVI     C,0     ;RESET CRC BYTE
c7c3  7e            1938   1939 WLOOP:  MOV     A,M     ;GET CHARACTER
c7c4  cd 9a c7      1939   1940         CALL    WRTAP   ;WRITE IT TO THE TAPE
c7c7  05            1940   1941         DCR     B
c7c8  23            1941   1942         INX     H
c7c9  c2 c3 c7      1942   1943         JNZ     WLOOP
c7cc  79            1943   1944         MOV     A,C     ;GET CRC
c7cd  c3 9a c7      1944   1945         JMP     WRTAP   ;PUT IT ON THE TAPE AND RETURN
                    1945   1946 ;
                    1946   1947 ;
                    1947   1948 ;   THIS ROUTINE COMPARES THE HEADER IN THEAD TO
                    1948   1949 ;   THE USER SUPPLIED HEADER IN ADDRESS HL.
                    1949   1950 ;   ON RETURN IF ZERO IS SET THE TWO NAMES COMPARED
                    1950   1951 ;
c7d0  06 05         1951   1952 DHCMP:  MVI     B,5
c7d2  1a            1952   1953 DHLOP:  LDAX    D
c7d3  be            1953   1954         CMP     M
c7d4  c0            1954   1955         RNZ
c7d5  05            1955   1956         DCR     B
c7d6  c8            1956   1957         RZ              ;IF ALL FIVE COMPARED
c7d7  23            1957   1958         INX     H
c7d8  13            1958   1959         INX     D
c7d9  c3 d2 c7      1959   1960         JMP     DHLOP
                    1960   1961 ;
c7dc  =             1961   1962 GTUNT   EQU     $       ;SET A=SPEED + UNIT
c7dc  3a 54 c8      1962   1963         LDA     FNUMF   ;GET UNIT
c7df  b7            1963   1964         ORA     A       ;SEE WHICH UNIT
c7e0  3a 0d c8      1964   1965         LDA     TSPD    ;BUT 1ST GET SPEED
c7e3  c2 e8 c7      1965   1966         JNZ     GTUN2   ;MAKE IT UNIT TWO
c7e6  c6 40         1966   1967         ADI     TAPE2   ;THIS ONCE=UNIT 2, TWICE=UNIT 1
c7e8  c6 40         1967   1968 GTUN2:  ADI     TAPE2   ;UNIT AND SPEED NOW SET IN A
c7ea  c9            1968   1969         RET             ;ALL DONE
                    1969   1970 ;
c7eb  06 04         1970   1971 WTON:   MVI     B,4     ;SET LOOP DELAY  (BIT LONGER ON A WRITE)
c7ed  =             1971   1972 TON     EQU     $       ;HERE TO TURN A TAPE ON THEN DELAY
c7ed  d3 06         1972   1973         OUT     TAPPT   ;GET TAPE MOVING, THEN DELAY
                    1973   1974 ;
c7ef  11 00 00      1974   1975 DELAY:  LXI     D,0
c7f2  1b            1975   1976 DLOP1:  DCX     D
c7f3  7a            1976   1977         MOV     A,D
c7f4  b3            1977   1978         ORA     E
c7f5  c2 f2 c7      1978   1979         JNZ     DLOP1
c7f8  05            1979   1980         DCR     B
c7f9  c2 ef c7      1980   1981         JNZ     DELAY
c7fc  c9            1981   1982         RET
                    1982   1983 ;
                    1983   1984 ;
                    1984   1985 ;**** -- END OF PROGRAM--
                    1985   1986 ;
                    1986   1987 ;
                    1987   1988 ;
                    1988   1989 ;
                    1989   1990 ;    S Y S T E M    E Q U A T E S
                    1990   1991 ;
                    1991   1992 ;
                    1992   1993 ;          VDM PARAMETERS
                    1993   1994 ;
cc00  =             1994   1995 VDMEM   EQU     0CC00H  ;VDM SCREEN MEMORY
                    1995   1996 ;
                    1996   1997 ;
                    1997   1998 ;            KEYBOARD SPECIAL KEY ASSIGNMENTS
                    1998   1999 ;
                    1999   2000 ;  THESE DEFINITIONS ARE DESIGNED TO ALLOW
                    2000   2001 ;  COMPATABILITY WITH SOLOS(TM). THESE ARE THE
                    2001   2002 ;  SAME KEYS WITH BIT 7 (X'80') STRIPPED OFF.
                    2002   2003 ;
001a  =             2003   2004 DOWN    EQU     1AH     ;CTL Z
0017  =             2004   2005 UP      EQU     17H     ;CTL W
0001  =             2005   2006 LEFT    EQU     01H     ;CTL A
0013  =             2006   2007 RIGHT   EQU     13H     ;CTL S
000b  =             2007   2008 CLEAR   EQU     0BH     ;CTL K
000e  =             2008   2009 HOME    EQU     0EH     ;CTL N
0000  =             2009   2010 MODE    EQU     00H     ;CTL-@
                    2010   2011 ;BACKS   EQU     5FH     ;BACKSPACE
0008  =             2011   2012 BACKS   EQU     08H     ;*UM*
000a  =             2012   2013 LF      EQU     10
000d  =             2013   2014 CR      EQU     13
0020  =             2014   2015 BLANK   EQU     ' '
0020  =             2015   2016 SPACE   EQU     BLANK
0018  =             2016   2017 CX      EQU     'X'-40H
001b  =             2017   2018 ESC     EQU     1BH
                    2018   2019 ;
                    2019   2020 ;          PORT ASSIGNMENTS
                    2020   2021 ;
0000  =             2021   2022 STAPT   EQU     0       ;STATUS PORT GENERAL
                    2022   2023 ;STKBD   EQU     STAPT   ;PROCTEC 3P+S
0004  =             2023   2024 STKBD   EQU     4       ;*UM* MITS PIO
0001  =             2024   2025 SDATA   EQU     1       ;SERIAL DATA
0012  =             2025   2026 SIO2S   EQU     18      ;*UM* STATUS SIO2 B
0013  =             2026   2027 SIO2D   EQU     19      ;*UM* DATA SIO2 B
0002  =             2027   2028 PDATA   EQU     2       ;PARALLEL DATA
                    2028   2029 ;KDATA   EQU     3       ;KEYBOARD DATA PROCTEC 3P+S
0005  =             2029   2030 KDATA   EQU     5       ;*UM* KEYBOARD DATA MITS PIO
00c8  =             2030   2031 DSTAT   EQU     0C8H    ;VDM CONTROL PORT
                    2031   2032 ;TAPPT   EQU     0FAH    ;TAPE STATUS PORT PROCTEC SOL-20
0006  =             2032   2033 TAPPT   EQU     06H     ;*UM* TAPE STATUS PORT MITS ACR
                    2033   2034 ;TDATA   EQU     0FBH    ;TAPE DATA PORT PROCTEC SOL-20
0007  =             2034   2035 TDATA   EQU     07H     ;*UM* TAPE DATA PORT MITS ACR
00ff  =             2035   2036 SENSE   EQU     0FFH    ;SENSE SWITCHES
                    2036   2037 ;
                    2037   2038 ;
                    2038   2039 ;
                    2039   2040 ;          BIT ASSIGNMENT MASKS
                    2040   2041 ;
0001  =             2041   2042 SCD     EQU     1       ;SERIAL CARRIER DETECT
0002  =             2042   2043 SDSR    EQU     2       ;SERIAL DATA SET READY
0004  =             2043   2044 SPE     EQU     4       ;SERIAL PARITY ERROR
0008  =             2044   2045 SFE     EQU     8       ;SERIAL FRAMING ERROR
0010  =             2045   2046 SOE     EQU     16      ;SERIAL OVERRUN ERROR
0020  =             2046   2047 SCTS    EQU     32      ;SERIAL CLEAR TO SEND
                    2047   2048 ;SDR     EQU     64      ;SERIAL DATA READY PROCTEC 3P+S
0001  =             2048   2049 SDR     EQU     1       ;*UM* SERIAL DATA READY MITS SIO
0001  =             2049   2050 SDR2    EQU     1       ;*UM* SERIAL DATA READY MITS 2SIO
                    2050   2051 ;STBE    EQU     128     ;SERIAL TRANSMITTER BUFFER EMPTY PROCTEC 3P+S
0080  =             2051   2052 STBE    EQU     128     ;*UM* SERIAL TRANSMITTER BUFFER EMPTY MITS SIO
0002  =             2052   2053 STBE2   EQU     2       ;*UM* SERIAL TRANSMITTER BUFFER EMPTY MITS 2SIO
                    2053   2054 ;
0001  =             2054   2055 KDR     EQU     1       ;KEYBOARD DATA READY
0002  =             2055   2056 PDR     EQU     2       ;PARALLEL DATA READY
0004  =             2056   2057 PXDR    EQU     4       ;PARALLEL DEVICE READY
                    2057   2058 ;TFE     EQU     8       ;TAPE FRAMING ERROR PROCTEC CUTS
0010  =             2058   2059 TFE     EQU     16      ;*UM* TAPE FRAMING ERROR MITS ACR
                    2059   2060 ;TOE     EQU     16      ;TAPE OVERFLOW ERROR PROCTEC CUTS
0008  =             2060   2061 TOE     EQU     8       ;*UM* TAPE OVERFLOW ERROR MITS ACR
                    2061   2062 ;TDR     EQU     64      ;TAPE DATA READY PROCTEC CUTS
0001  =             2062   2063 TDR     EQU     1       ;*UM* TAPE DATA READY MITS ACR
0080  =             2063   2064 TTBE    EQU     128     ;TAPE TRANSMITTER BUFFER EMPTY
                    2064   2065 ;
0001  =             2065   2066 SOK     EQU     1       ;SCROLL OK FLAG
                    2066   2067 ;
0080  =             2067   2068 TAPE1   EQU     80H     ;1=TURN TAPE ONE ON
0040  =             2068   2069 TAPE2   EQU     40H     ;1=TURN TAPE TWO ON
                    2069   2070 ;
                    2070   2071 ;
                    2071   2072 ;
                    2072   2073 ;
                    2073   2074 ;       S Y S T E M   G L O B A L    A R E A
                    2074   2075 ;
                    2075   2076         ORG    START+0800H ;RAM STARTS JUST AFTER ROM
                    2076   2077 ;
c800  =             2077   2078 SYSRAM  EQU     $       ;START OF SYSTEM RAM
cbff  =             2078   2079 SYSTP   EQU     SYSRAM+3FFH ;STACK WORKS FM TOP DOWN
                    2079   2080 ;
                    2080   2081 ;
                    2081   2082 ;   PARAMETERS STORED IN RAM
                    2082   2083 ;
c800                2083   2084 UIPRT:  DS      2       ;USER DEFINED INPUT RTN IF NON ZERO
c802                2084   2085 UOPRT:  DS      2       ;USER DEFINED OUTPUT RTN IF NON ZERO
c804                2085   2086 DFLTS:  DS      2       ;DEFAULT PSUEDO I/O PORTS
c806                2086   2087 IPORT:  DS      1       ;CRNT INPUT PSUEDO PORT
c807                2087   2088 OPORT:  DS      1       ;CRNT OUTPUT PSUEDO PORT
c808                2088   2089 NCHAR:  DS      1       ;CURRENT CHARACTER POSITION
c809                2089   2090 LINE:   DS      1       ;CURRENT LINE POSITION
c80a                2090   2091 BOT:    DS      1       ;BEGINNING OF TEXT DISPLACEMENT
c80b                2091   2092 SPEED:  DS      1       ;SPEED CONTROL BYTE
c80c                2092   2093 ESCFL:  DS      1       ;ESCAPE FLAG CONTROL BYTE
c80d                2093   2094 TSPD:   DS      1       ;CURRENT TAPE SPEED
c80e                2094   2095 INPTR:  DS      2       ;PTR TO NEXT CHAR POSITION IN INLIN
c810                2095   2096 NUCNT:  DS      1       ;NUMBER OF NULLS AFTER CRLF
c811                2096   2097 IGNCR:  DS      1       ;IGN CRC ERR FLAG, FF=IGN CRC ERRS, ELSE=NORMAL
                    2097   2098 ;
c812                2098   2099         DS      10      ;ROOM FOR FUTURE EXPANSION
                    2099   2100 ;
                    2100   2101 ; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
                    2101   2102 ;    T H I S   I S   T H E   H E A D E R   L A Y O U T    *
                    2102   2103 ; * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
                    2103   2104 ;
c81c                2104   2105 THEAD:  DS      5       ;NAME
c821                2105   2106         DS      1       ;THIS BYTE MUST BE ZERO
c822                2106   2107 HTYPE:  DS      1       ;TYPE
c823                2107   2108 BLOCK:  DS      2       ;BLOCK SIZE
c825                2108   2109 LOADR:  DS      2       ;LOAD ADDRESS
c827                2109   2110 XEQAD:  DS      2       ;AUTO EXECUTE ADDRESS
c829                2110   2111 HSPR:   DS      3       ;SPARES
                    2111   2112 ;
0010  =             2112   2113 HLEN    EQU     $-THEAD ;LENGTH OF HEADER
0007  =             2113   2114 BLKOF   EQU     BLOCK-THEAD ;OFFSET TO BLOCK SIZE
c82c                2114   2115 DHEAD:  DS      HLEN    ;A DUMMY HDR FOR COMPARES WHILE RD'ING
                    2115   2116 ;
                    2116   2117 ;
c83c                2117   2118 CUTAB:  DS      6*4     ;ROOM FOR UP TO 6 CUSTOM USER COMMANDS
                    2118   2119 ;
                    2119   2120 ;
c854                2120   2121 FNUMF:  DS      1       ;FOR CURRENT FILE OPERATIONS
c855                2121   2122 FCBAS:  DS      7       ;1ST FILE CONTROL BLOCK
c85c                2122   2123 FCBA2:  DS      7       ;2ND FILE CONTROL BLOCK
c863                2123   2124 FBUF1:  DS      2*256   ;SYSTEM FILE BUFFER BASE
ca63                2124   2125         DS      1       ;"BELL" (X'07') FLAGS START OF INPUT BFR
ca64                2125   2126 INLIN:  DS      80      ;ROOM FOR THE INPUT LINE
cab4  =             2126   2127 USARE   EQU     $       ;START OF USER AREA
                    2127   2128 ;
                    2128   2129 ;   REMEMBER THAT THE STACK WORKS ITS WAY DOWN-FROM
                    2129   2130 ;   THE END OF THIS 1K RAM AREA.
                    2130   2131 ;
                    2131   2132 ; -*-
cab4                2132   2133         END

Symbol table

ADOUT  c3d9    AINP   c022*   ALOAD  c544    AOUT   c01c*   ARET   c1c3*
ARET1  c1c5    ARET2  c1ca    BACKS  0008    BLANK  0020    BLKOF  0007 
BLOCK  c823    BOPEN  c5dc    BOT    c80a    BOUT   c3f7    CHAR   c0b8 
CHRLI  c56d    CLEAR  000b    CLERA  c1dc    CLIN1  c123    CLIN2  c118 
CLINE  c11d*   COMN1  c215    COMND  c218    COMTAB c2bd    CONT   c264*
COPRC  c26a    CR     000d    CREM   c15f    CRLF   c342    CSET   c576 
CUR    c0f5    CURET  c1ce    CURSC  c0f3    CUSE2  c5cf    CUSET  c5b9 
CUTAB  c83c    CX     0018*   DCRC2  c71c    DCRCT  c711    DEFLT  c494 
DELAY  c7ef    DFLTS  c804    DHCMP  c7d0    DHEAD  c82c    DHLOP  c7d2 
DISP0  c282    DISP1  c28b    DISPD  c595    DISPT  c287    DLOOP  c3b6 
DLOP1  c7f2    DLP1   c3c1    DLP1A  c3d0    DOCRC  c7a6    DOWN   001a 
DSTAT  00c8    DUMP   c3ad    ENLO1  c427    ENLO3  c444    ENLOP  c418 
ENTER  c414    EOFER  c5fb    EOFW   c627    ERAS1  c0ff    ERAS3  c112 
ERR1   c46b    ERR2   c46c    ERRIT  c065    ERRM   c521    ERRO1  c070 
ERROT  c06c    ESC    001b    ESCFL  c80c    ESCS   c187    ESCSP  c190 
EXEC   c449    EXEC1  c44c    FBUF1  c863    FCBA2  c85c    FCBAS  c855 
FCLOS  c00a*   FDCOM  c291    FDCOU  c28e    FNUMF  c854    FOPEN  c007*
GCLI0  c227    GCLI1  c232    GCLI2  c25f    GCLI3  c261    GCLIN  c239 
GOBACK c08f    GOBK   c0a0    GTBYT  c671    GTUN2  c7e8    GTUNT  c7dc 
HBOUT  c3de    HCONV  c38b*   HCOV1  c39b    HEOU1  c405    HEOUT  c3fc 
HLEN   0010    HOME   000e    HSPR   c829*   HTYPE  c822    IGNCR  c811 
INIT   c001*   INLIN  ca64    INPTR  c80e    IOPRC  c026    IPORT  c806 
ITAB   c309    KDATA  0005    KDR    0001    KREA1  c035    LEFT   0001 
LF     000a    LFCB   c62f    LFCB1  c63e    LINE   c809    LIST1  c535 
LLIST  c52d    LOADR  c825    MODE   0000*   NAME   c454    NAME0  c451 
NAME1  c459    NAOUT  c54c    NCHAR  c808    NCOM   c2a3    NEXT   c0a4 
NFIL   c480    NLOOP  c566    NUCNT  c810    NULOP  c7b2    NULOT  c350 
OCHAR  c0bc    OK     c0e5    OPORT  c807    OTAB   c301    OUTH   c410 
OUTPR  c02e    PARIT  c052    PAROT  c05a    PBACK  c167    PCLOS  c5ff 
PCR    c170    PCUR   c138    PDATA  0002*   PDOWN  c0ef    PDR    0002*
PERSE  c0f9    PESC   c181    PHEAD  c6a2    PHOME  c109    PLEFT  c134 
PLF    c175    PLOAD  c6bb    PRIT   c13e    PROMPT c33a    PSCAN  c3a5 
PSTOR  c6b2    PTAP1  c6cf    PUP    c12d    PXDR   0004*   RDBLK  c013*
RDBYT  c00d*   RDNBLK c658*   RETRN  c004*   RFBLK  c6c4    RHEA1  c721 
RHEAD  c71f    RHED1  c740    RHED2  c742    RIGHT  0013    RT1    c67c 
RTAP   c6f2    RTAP2  c6f3    RTAPE  c6c7    RTBYT  c642    RTOF1  c70d 
RTOFF  c70c    SBLK   c359    SBLK1  c35b    SCD    0001*   SCHR   c36c 
SCHR1  c36e    SCONV  c378    SCROLL c0d0*   SCTS   0020*   SDATA  0001 
SDR    0001    SDR2   0001    SDSR   0002*   SECOND c1b8    SENSE  00ff 
SEROT  c047    SETAB  c311    SETCI  c5a1    SETCO  c5a5    SETCR  c5b5 
SETIN  c599    SETNU  c5b1    SETOT  c59d    SETSP  c590    SETTY  c5a9 
SETX   c1b0    SETXQ  c5ad    SETY   c1b4    SFE    0008*   SHE1   c381 
SHEX   c37e    SINP   c01f    SIO2D  0013    SIO2S  0012    SOE    0010*
SOHL   c72f    SOK    0001*   SOUT   c019    SPACE  0020    SPE    0004*
SPEED  c80b    SREA1  c03e    SROL   c0d4    STAPT  0000    START  c000 
STAT   c759    STBE   0080    STBE2  0002    STKBD  0004    STRTA  c1d7 
STRTB  c1f4    STRTC  c1ff    STRTD  c20f    STSPD  c594    STUNT  c49c 
STUP   c2aa    SYSRAM c800    SYSTP  cbff    TAERR  c510    TAPE1  0080 
TAPE2  0040    TAPIN  c76c    TAPPT  0006    TASPD  c58a    TBL    c2e2 
TDATA  0007    TDR    0001    TERE0  c5f8    TERE1  c5f7*   TERE2  c5f6 
TERR   c702    TFE    0010    THEAD  c81c    TIMER  c09b    TLIST  c527 
TLOA2  c4af*   TLOA3  c4bb    TLOAD  c4a1    TOE    0008    TOFF   c707 
TON    c7ed    TREDY  c770*   TSAVE  c4e0    TSPD   c80d    TSRCH  c0a6 
TTBE   0080    TXEQ   c4a0    UBUF   c5f1*   UIPRT  c800    UOPRT  c802 
UP     0017    USARE  cab4*   VDAD   c14c    VDAD2  c149    VDADD  c145 
VDM01  c078    VDMEM  cc00    WFBLK  c779    WHEAD  c7ad    WLOOP  c7c3 
WRBLK  c016*   WRBYT  c010*   WRTAP  c79a    WRWAT  c79b    WT1    c697 
WTAP1  c78d    WTAP2  c78e    WTAPE  c77c    WTBL   c7c1    WTBYT  c67f 
WTLP1  c3f1    WTON   c7eb    XEQAD  c827    
