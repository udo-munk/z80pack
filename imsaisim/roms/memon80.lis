Z80-Macro-Assembler  Release 1.11-dev	Wed Nov  2 18:00:50 2022

LOC   OBJECT CODE   LINE   STMT SOURCE CODE
                       1      1 ;==============================================================
                       2      2 ; Simple, configurable 1K-byte or 2K-byte ROM-based monitor for
                       3      3 ; an 8080- or Z80-based system, supporting a variety of serial
                       4      4 ; ports and floppy disk controllers.
                       5      5 ;
                       6      6 ; See comments further down for a list and description of
                       7      7 ; Memon/80's commands.
                       8      8 ;
                       9      9 ; Memon/80 uploads and downloads data either the console or a
                      10     10 ; second serial port (called the Transfer Port).
                      11     11 ;
                      12     12 ; Memon/80 supports the following serial ports for either the
                      13     13 ; console or the Transfer Port, as selected with assembly
                      14     14 ; options below.
                      15     15 ;    Altair 88-SIO
                      16     16 ;    Altair 88-2SIO or my own 88-2SIOJP
                      17     17 ;    Altair 8800b Turnkey Module's serial port
                      18     18 ;    Altair (MITS) 88-UIO's serial port
                      19     19 ;    California Comouter Systems 2718's serial ports
                      20     20 ;    California Computer Systems 2719
                      21     21 ;    California Computer Systems 2810 CPU'S serial port
                      22     22 ;    Compupro Interfacer 1
                      23     23 ;    Compupro Interfacer II
                      24     24 ;    Cromemco 4FDC/16FDC/64FDC disk controller's serial port
                      25     25 ;    Cromemco TU-ART
                      26     26 ;    Electronic Control Technology (ECT) R2IO
                      27     27 ;    Heathkit H8-4 quad serial port
                      28     28 ;    Heathkit H8-5 Console/Cassette controller's console port
                      29     29 ;      (assuming a PAM-8 or XCON-8 ROM is installed in the H8)
                      30     30 ;    IMSAI SIO-2
                      31     31 ;    Ithaca Intersystems Series II VIO's serial ports
                      32     32 ;    Jade Serial/Parallel I/O Board's serial ports
                      33     33 ;    Micromation Doubler disk controller's serial port
                      34     34 ;    Processor Technology 3P+S's serial port
                      35     35 ;    Salota I/O 2+1's serial ports
                      36     36 ;    Solid State Music IO4's serial ports (Configured as one of
                      37     37 ;      the other supported serial port boards)
                      38     38 ;    Solid State Music IO5's serial ports
                      39     39 ;    Tarbell 4044 4S2P's serial ports
                      40     40 ;    Vector Graphic BitStreamer
                      41     41 ;    Vector Graphic BitStreamer II
                      42     42 ;    Wameco (WMC) IO-1B's serial port
                      43     43 ;
                      44     44 ; Memon/80's BO command boots from the following floppy
                      45     45 ; disk controllers, selected with assembly options below. 
                      46     46 ;    Altair 88-DCDD 8"
                      47     47 ;    Altair 88-MDS Minidisk
                      48     48 ;    California Computer Systems 2422
                      49     49 ;    Cromemco 4FDC/16FDC/64FDC
                      50     50 ;    Heathkit H17 Minifloppy
                      51     51 ;    IMSAI FIF (FIB & IFM)
                      52     52 ;    IMSAI MDC-DIO
                      53     53 ;    Micromation Doubler
                      54     54 ;    Micropolis - FD Control B
                      55     55 ;    Northstar MDC-A Minidisk
                      56     56 ;    Northstar MDS-A  Minidisk
                      57     57 ;    Northstar MDS-D Double-density  Minidisk
                      58     58 ;    Salota FDC
                      59     59 ;    SD Systems Versafloppy (Single-density)
                      60     60 ;    SD Systems Versafloppy II (Double-density)
                      61     61 ;    Tarbell 1011 8" (Single-density)
                      62     62 ;    Tarbell 2022 8" (Double-density)
                      63     63 ;
                      64     64 ; Formatted to assemble with digital Research'S ASM.
                      65     65 ;==============================================================
0000  =               66     66 FALSE	equ	0
ffff  =               67     67 TRUE	equ	NOT FALSE
                      68     68 
                      69     69 ;==========================================================
                      70     70 ;=               Memon/80 Option Selection                =
                      71     71 ;=                                                        =
                      72     72 ;= Set the required options in the following 10 sections  =
                      73     73 ;=                                                        =
                      74     74 ;= Select Memon/80 functionality by setting these         =
                      75     75 ;= variables according to the guidelines in each section. =
                      76     76 ;==========================================================
                      77     77 
                      78     78 ;============================---------------------------
                      79     79 ;= 1. Specify the CPU Speed =
                      80     80 ;============================
                      81     81 ;(Only used to adjust time-out loops for floppy disk booting)
                      82     82 ;-------------------------------------------------------
0004  =               83     83 CPUMHz	equ	4	;Integer CPU speed in MHz
                      84     84 
                      85     85 ;===========================----------------------
                      86     86 ;= 2. Specify the ROM Size =
                      87     87 ;===========================
                      88     88 ;2K-Byte EPROM option adds several commands,
                      89     89 ;and extends a few other commands.
                      90     90 ;   ROM2K equ TRUE selects a 2K EPROM (e.g. 2716)
                      91     91 ;   ROM2K equ FALSE selects a 1K EPROM (e.g. 2708)
                      92     92 ;-------------------------------------------------
ffff  =               93     93 ROM2K	equ	TRUE
                      94     94 
                      95     95 ;============================================---------------
                      96     96 ;= 3. Specify Memon/80's Memory Utilization =
                      97     97 ;============================================
                      98     98 ;These specify where Memon/80 is place in memory and where
                      99     99 ;its buffers, stack, and variables are. Additionally, you
                     100    100 ;can disable some Memon/80 features to reduce the code size. 
                     101    101 ;-----------------------------------------------------------
f800  =              102    102 MEBASE	equ	0F800h	;Base address of Memon/80 code
                     103    103 
0000  =              104    104 RAMCOD	equ	FALSE	;Set to true if executing from RAM in
                     105    105 			;low memory (e.g. at 0100h for CP/M).
                     106    106 
ffff  =              107    107 RAMHNT	equ	TRUE	;TRUE causes Memon to hunt for the
                     108    108 			;highest contiguous RAM page for its
                     109    109 			;stack, buffer, and variables.
                     110    110 			;FALSE uses RAM just below RAMEND,
                     111    111 			;and saves at least 26 bytes. Must be
                     112    112 			;FALSE for I/O boards using interrupts.
                     113    113 
ffff  =              114    114 RAMEND	equ	0FFFFh	;Last allowed RAM address for MEMON/80.
                     115    115 			;(Ignored if RAMHNT equ TRUE.)
                     116    116 			;All of Memon's RAM must fit in one
                     117    117 			;256-byte page. This means the low 2
                     118    118 			;hex digits must be larger than 70h. (a
                     119    119 			;few more if your I/O ports use
                     120    120 			;interrupts.) -->Must be xxFFh for
                     121    121 			;Altair disk drives<--
                     122    122 
ffff  =              123    123 HELPC	equ	TRUE	;TRUE includes a minimal help command.
                     124    124 			;FALSE saves 40 to 60 bytes.
                     125    125 
ffff  =              126    126 LOWERC	equ	TRUE	;TRUE allows lowercase input too.
                     127    127 			;FALSE saves 11 bytes.
                     128    128 
ffff  =              129    129 HLRECS	equ	TRUE	;TRUE: HL command reports total number
                     130    130 			;of records received when done.
                     131    131 			;FALSE: saves 25 bytes.
                     132    132 
ffff  =              133    133 CORPT	equ	TRUE	;TRUE includes the <RPT> option for the
                     134    134 			;CO (copy) command.
                     135    135 			;FALSE saves 36 bytes.
                     136    136 
ffff  =              137    137 EXOPT	equ	TRUE	;TRUE includes the EX command option to
                     138    138 			;disable the ROM on IN from FFh (for
                     139    139 			;Altair-type boards).
                     140    140 			;FALSE saves 17 bytes.
                     141    141 
ffff  =              142    142 DUPRTY	equ	TRUE	;TRUE makes the DU output a little
                     143    143 			;prettier
                     144    144 			;FALSE saves 17 bytes
                     145    145 
                     146    146 ;===============================------------
                     147    147 ;= 4. Specify the Console Port =
                     148    148 ;===============================
                     149    149 ;Exactly one of these must be TRUE
                     150    150 ;-------------------------------------------
0000  =              151    151 CALSIO	equ	FALSE	;Altair 88-SIO
0000  =              152    152 CA2SIO	equ	FALSE	;Altair 88-2SIO (Port A or B)
                     153    153 			;or 8800b Turnkey Module or 88-UIO
0000  =              154    154 CC2718A	equ	FALSE	;CCS 2718 Serial Port A
0000  =              155    155 CC2718B	equ	FALSE	;CCS 2718 Serial Port B
0000  =              156    156 CC2719A	equ	FALSE	;CCS 2719 Port A
0000  =              157    157 CC2719B	equ	FALSE	;CCS 2719 Port B
0000  =              158    158 CC2810	equ	FALSE	;CCS 2810 CPU'S serial port
0000  =              159    159 CIFAC	equ	FALSE	;Compupro Interfacer 1 (Port A or B)
0000  =              160    160 CIFAC2	equ	FALSE	;Compupro Interfacer II
0000  =              161    161 CTUART	equ	FALSE	;Cromemco TU-ART (Port A or B)
0000  =              162    162 CCFDCS	equ	FALSE	;Cromemco 4FDC/16FDC/64FDC serial port
0000  =              163    163 CER2IO	equ	FALSE	;ECT R2IO (Port A, B, or C)
0000  =              164    164 CH84	equ	FALSE	;Heathkit H8-4 Serial (any of the 4)
0000  =              165    165 CH85	equ	FALSE	;Heathkit H8-5's console port
ffff  =              166    166 CISIO2A	equ	TRUE	;IMSAI SIO-2 Port A
0000  =              167    167 CISIO2B	equ	FALSE	;IMSAI SIO-2 Port B
0000  =              168    168 CIVIO2	equ	FALSE	;Ithaca Intersystems VIO-II Port A or B
0000  =              169    169 CJADSP	equ	FALSE	;Jade Serial/Parallel I/O (port A or B)
0000  =              170    170 CMDUBLR	equ	FALSE	;Micromation Doubler serial port
0000  =              171    171 CPT3PS	equ	FALSE	;Processor Technology 3P+S
0000  =              172    172 CSAL21	equ	FALSE	;Salota I/O 2+1 (Port A or B)
0000  =              173    173 CSIO5	equ	FALSE	;Solid State Music IO5 Serial (A or B)
0000  =              174    174 CTARBL	equ	FALSE	;Tarbell 4044 (Port A, B, C, or D)
0000  =              175    175 CBITS1	equ	FALSE	;Vector Graphic BitStreamer
0000  =              176    176 CBITS2	equ	FALSE	;Vector Graphic BitStreamer II Port A,B,C
0000  =              177    177 CWIOB1	equ	FALSE	;Wameco IOB-1's serial port
                     178    178 
                     179    179 ;================================---------------------------
                     180    180 ;= 5. Specify the Transfer Port =
                     181    181 ;================================
                     182    182 ;At most one of these must be TRUE. If none is TRUE then the
                     183    183 ;following commands will be deleted: TB (set Transfer Port
                     184    184 ;baud rate), TE (Terminal mode), and TP (Select transfer
                     185    185 ;Port). The Transfer Port must not also be the Console Port
                     186    186 ;-----------------------------------------------------------
0000  =              187    187 TALSIO	equ	FALSE	;Altair 88-SIO
0000  =              188    188 TA2SIO	equ	FALSE	;Altair 88-2SIO (Port A or B)
                     189    189 			;or 8800b Turnkey Module or 88-UIO
0000  =              190    190 TC2718A	equ	FALSE	;CCS 2718 Serial Port A
0000  =              191    191 TC2718B	equ	FALSE	;CCS 2718 Serial Port B
0000  =              192    192 TC2719A	equ	FALSE	;CCS 2719 Port A
0000  =              193    193 TC2719B	equ	FALSE	;CCS 2719 Port B
0000  =              194    194 TC2810	equ	FALSE	;CCS 2810 CPU'S serial port
0000  =              195    195 TIFAC	equ	FALSE	;Compupro Interfacer 1 (Port A or B)
0000  =              196    196 TIFAC2	equ	FALSE	;Compupro Interfacer II
0000  =              197    197 TTUART	equ	FALSE	;Cromemco TU-ART (Port A or B)
0000  =              198    198 TCFDCS	equ	FALSE	;Cromemco 4FDC/16FDC/64FDC serial port
0000  =              199    199 TER2IO	equ	FALSE	;ECT R2IO (Port A, B, or C)
0000  =              200    200 TH84	equ	FALSE	;Heathkit H8-4 (any of the 4)
0000  =              201    201 TH85	equ	FALSE	;Heathkit H8-5's console port
ffff  =              202    202 TISIO2A	equ	TRUE	;IMSAI SIO-2 Port A
0000  =              203    203 TISIO2B	equ	FALSE	;IMSAI SIO-2 Port B
0000  =              204    204 TIVIO2	equ	FALSE	;Ithaca Intersystems VIO-II Port A or B
0000  =              205    205 TJADSP	equ	FALSE	;Jade Serial/Parallel I/O (port A or B)
0000  =              206    206 TMDUBLR	equ	FALSE	;Micromation Doubler serial port
0000  =              207    207 TPT3PS	equ	FALSE	;Processor Technology 3P+S
0000  =              208    208 TSAL21	equ	FALSE	;Salota I/O 2+1 (Port A or B)
0000  =              209    209 TSIO5	equ	FALSE	;Solid State Music IO5 Serial (A or B)
0000  =              210    210 TTARBL	equ	FALSE	;Tarbell 4044 (Port A, B, C, or D)
0000  =              211    211 TBITS1	equ	FALSE	;Vector Graphic BitStreamer
0000  =              212    212 TBITS2	equ	FALSE	;Vector Graphic BitStreamer II Port A,B,C
0000  =              213    213 TWIOB1	equ	FALSE	;Wameco IOB-1's serial port
                     214    214 
                     215    215 ;=========================================--------------------
                     216    216 ;= 6. Set the Serial port base addresses =
                     217    217 ;=========================================
                     218    218 ;Here are the default addresses for various boards. Make sure
                     219    219 ;that CBASE is not the same as TBASE, and that their address
                     220    220 ;ranges do not overlap,  unless they are on the same serial
                     221    221 ;board, sharing address space. (some board combinations will
                     222    222 ;require you to change the address of at least one board to a
                     223    223 ;non-default address.) Also make sure that neither serial port
                     224    224 ;interferes with the addresses used by the disk controller,
                     225    225 ;if you are enabling the BO (boot from floppy) command.
                     226    226 ;
                     227    227 ;                                    Port      Board
                     228    228 ;                                    Base     Address
                     229    229 ;   Serial Port Board        Port   Address    Range
                     230    230 ;-------------------------------------------------------------
                     231    231 ; Altair 88-SIO                       00h     00h-01h
                     232    232 ;
                     233    233 ; Altair 88-2SIO             Port A   10h     10h-13h
                     234    234 ;                            Port B   12h
                     235    235 ;
                     236    236 ; Altair 8800b Turnkey       Serial   10h     10h-11h
                     237    237 ;
                     238    238 ; MITS 88-UIO                Serial   10h     10h-11h
                     239    239 ;
                     240    240 ; CCS 2718                    Ser A  00h     00h-03h
                     241    241 ; (Jumpers SPR=N,SAI-N,SBI=I) Ser B  00h
                     242    242 ;
                     243    243 ; CCS 2719                   Port A   50h     50h-57h
                     244    244 ;                            Port B   50h
                     245    245 ;
                     246    246 ; CCS 2810                   Serial   20h     20h-26h
                     247    247 ;
                     248    248 ; Compupro Interfacer 1      Port A   00h     00h-03h
                     249    249 ;                            Port B   02h
                     250    250 ;
                     251    251 ; Compupro Interfacer II              00h     00h-01h
                     252    252 ;
                     253    253 ; Cromemco TU-ART            Port A   20h     20h-23h
                     254    254 ;                            Port B   50h     50h-53h
                     255    255 ;
                     256    256 ; Cromemco 4FDC/16FDC/64FDC  Serial   00h     00h-03h
                     257    257 ;
                     258    258 ; ECT R2I/O                  Port A   00h     00h-07h
                     259    259 ;                            Port B   02h
                     260    260 ;                            Port C   04h
                     261    261 ;
                     262    262 ; Heathkit H8-4              Console  0E8h   0E8h-0EDh
                     263    263 ;                        Lineprinter  0E0h   0E0h-0E6h
                     264    264 ;                         Alt Term 0  0C0h   0C0h-0C6h
                     265    265 ;                         Alt Term 1  0C8h   0C8h-0CDh
                     266    266 ;                         Alt Term 2  0D0h   0D0h-0D6h
                     267    267 ;                         Alt Term 3  0D8h   0D8h-0DDh
                     268    268 ;
                     269    269 ; Heathkit H8-5              Console  0FAh   0F8h-0FBh
                     270    270 ;
                     271    271 ; IMSAI SIO-2                Port A   02h     02h-06h
                     272    272 ;                            Port B   04h
                     273    273 ;
                     274    274 ; Ithaca Intersystems VIO-II Port A   00h     00h-1Fh
                     275    275 ;                            Port B   04h
                     276    276 ;
                     277    277 ; Jade Serial/Parallel I/O   Port A   00h     00h-02h
                     278    278 ;                            Port B   01h    & 80h-82h
                     279    279 ;
                     280    280 ; Micromation Doubler        Serial 0F800h  0F800h-0FFFFh
                     281    281 ;   (memory-mapped)
                     282    282 ;
                     283    283 ; Processor Technology 3P+S   C & D   00h     00h-03h
                     284    284 ;
                     285    285 ; Salota I/O 2+1            Serial A  80h     80h-8Eh
                     286    286 ;                           Serial B  82h
                     287    287 ;
                     288    288 ; Solid State Music IO5     Serial A  00h     00h-0Dh
                     289    289 ;                           Serial B  02h
                     290    290 ;
                     291    291 ; Tarbell 4044 4S2P IO       Port A   11h     10h-18h
                     292    292 ;                            Port B   13h
                     293    293 ;                            Port C   15h
                     294    294 ;                            Port D   17h
                     295    295 ;
                     296    296 ; VG BitStreamer       -              02h     02h-03h
                     297    297 ;
                     298    298 ; VG BitStreamer II          Port A   02h     02h-09h
                     299    299 ;                            Port B   04h
                     300    300 ;                            Port C   06h
                     301    301 ;
                     302    302 ; Wameco IOB-1               Serial   04h     00h-05h
                     303    303 ;-------------------------------------------------------------
0002  =              304    304 CBASE	equ	002h	;Console Port base address
0022  =              305    305 TBASE	equ	022h	;Transfer Port base address
                     306    306 
                     307    307 ;=====================================--------------------
                     308    308 ;= 7. Set the Serial Port Baud Rates =
                     309    309 ;=====================================
                     310    310 ;Set the Console baud rate and the initial Transfer Port
                     311    311 ;baud rate, for boards that support software-controlled
                     312    312 ;baud rates. (Note that the TB command is only available
                     313    313 ;if ROM2K is TRUE and a Transfer Port has been specified.)
                     314    314 ;The following supported boards allow software to set the
                     315    315 ;baud rate:
                     316    316 ;
                     317    317 ;  Serial Port Board                Max Rate      Notes
                     318    318 ;---------------------------------------------------------
                     319    319 ; CCS 2718                           19200
                     320    320 ; CCS 2719                           57600
                     321    321 ; CCS 2810                           38400
                     322    322 ; Cromemco TU-ART                    76800     no 600 baud
                     323    323 ; Cromemco 4FDC/16FDC/64FDC          76800     no 600 baud
                     324    324 ; Heathkit H8-4                      38400
                     325    325 ; Ithaca Intersystems System II VIO  19200
                     326    326 ;
                     327    327 ;Specify the baud rates from this table:
                     328    328 ;
                     329    329 ;    Baud  Stop   CBAUD/TBAUD
                     330    330 ;    Rate  Bits      Value
                     331    331 ;----------------------------
                     332    332 ;     110    2         0
                     333    333 ;     150    1         1
                     334    334 ;     300    1         2
                     335    335 ;     600    1         3
                     336    336 ;    1200    1         4
                     337    337 ;    2400    1         5
                     338    338 ;    4800    1         6
                     339    339 ;    9600    1         7
                     340    340 ;   19200    1         8
                     341    341 ;   38400    1         9
                     342    342 ;   57600    1        10
                     343    343 ;   76800    1        11
                     344    344 ;---------------------------------------------------------
0009  =              345    345 CBAUD	equ	9	;Console baud rate
000a  =              346    346 TBAUD	equ	10	;Initial Transfer Port baud rate
                     347    347 
                     348    348 ;==================================------------------
                     349    349 ;= 8. Specify the Disk controller =
                     350    350 ;==================================
                     351    351 ;The disk controller is only used for the BO command.
                     352    352 ;At most one of these may be TRUE. If none is TRUE,
                     353    353 ;then the BO (boot) command will be deleted.
                     354    354 ;----------------------------------------------------
0000  =              355    355 A88DCD	equ	FALSE	;MITS Altair 88-DCDD
0000  =              356    356 A88MCD	equ	FALSE	;MITS Altair 88-MDS
0000  =              357    357 CC2422	equ	FALSE	;CCS 2422 Disk controller
0000  =              358    358 C4FDC	equ	FALSE	;Cromemco 4FDC
0000  =              359    359 C16FDC	equ	FALSE	;Cromemco 16FDC
0000  =              360    360 C64FDC	equ	FALSE	;Cromemco 64FDC
0000  =              361    361 H17R	equ	FALSE	;Heathkit H17 (onboard boot ROM),
ffff  =              362    362 IFIF	equ	TRUE	;IMSAI FIF
0000  =              363    363 IMD8R	equ	FALSE	;IMSAI MDC-DIO with 8" disk (onboard
                     364    364 			;..boot ROM
0000  =              365    365 IMDMR	equ	FALSE	;IMSAI MDC-DIO with minidisk (onboard
                     366    366 			;..boot ROM
0000  =              367    367 MDUBLR	equ	FALSE	;Micromation Doubler (onboard boot
                     368    368 			;..ROM
0000  =              369    369 MICROP	equ	FALSE	;Micropolis FD controller B
0000  =              370    370 MICROR	equ	FALSE	;Micropolis FD Controller B (onboard
                     371    371 			;..boot ROM
0000  =              372    372 NSTARS	equ	FALSE	;Northstar MDC-A and MDS-A
0000  =              373    373 NSTRSR	equ	FALSE	;Northstar MDC-A and MDS-A (onboard
                     374    374 			;..boot ROM
0000  =              375    375 NSTARD	equ	FALSE	;Northstar MDS-D
0000  =              376    376 NSTRDR	equ	FALSE	;Northstar MDS-D (onboard boot ROM)
0000  =              377    377 SALFDC	equ	FALSE	;Salota FDC (same as Versafloppy II)
0000  =              378    378 VERSA1  equ     FALSE	;SD Systems Versafloppy
0000  =              379    379 VERSA2  equ     FALSE	;SD Sales Versafloppy II
0000  =              380    380 TARBL1	equ	FALSE	;Tarbell 1011
0000  =              381    381 TARBL2	equ	FALSE	;Tarbell 2022
                     382    382 
                     383    383 ;=================================================-------------
                     384    384 ;= 9. Set the Disk Controller's Base Addresse(s) =
                     385    385 ;=================================================
                     386    386 ;Here are the default base addresses for various boards. Note
                     387    387 ;that some disk controllers use I/O address, some use memory
                     388    388 ;addresses, and some use both. Also, some of these boards do
                     389    389 ;not allow you to change their I/O addresses and/or memory
                     390    390 ;addresses.
                     391    391 ;                             I/O     I/O      Memory   Memory
                     392    392 ;                             Base    Top       Base     Top
                     393    393 ;     Disk Controller        Address Address   Address  Address
                     394    394 ;--------------------------------------------------------------
                     395    395 ; MITS Altair 88-DCDD/88-MDS  08h     0Ah
                     396    396 ; CCS 2422 Disk controller   {04h & 30h-34h}
                     397    397 ; Cromemco 4FDC/16FDC/64FDC  {04h & 30h-34h}
                     398    398 ; Heathkit H17                                 01800h    01FFFh
                     399    399 ; IMSAI FIF                   0FDH    0FDH
                     400    400 ; IMSAI MDC-DIO               0D0h    0DFh     0E000h    0EFFFh
                     401    401 ; Micromation Doubler                          0F800h    0FFFFh
                     402    402 ; Micropolis FD controller B                   0F400h    0F7FFh
                     403    403 ; Northstar MDC-A and MDS-A                    0E800h    0EBFFh
                     404    404 ; Northstar MDS-D                              0E800h    0EBFFh
                     405    405 ; SD Systems Versafloppy      060h    067h
                     406    406 ; Tarbell 1011/2022           0F8h    0FFH
                     407    407 ;--------------------------------------------------------------
00fd  =              408    408 DIBASE	equ	0fdh	;Disk Controller I/O Base Address
0000  =              409    409 DMBASE	equ	0000h	;Disk controller memory Base Address
                     410    410 
                     411    411 ;=====================================================---------
                     412    412 ;= 10. Specify whether or not interrupts are enabled =
                     413    413 ;=====================================================
                     414    414 ;"ENINTS equ TRUE" will generally leave interrupts enabled,
                     415    415 ;masking them only during initialization and when time-critical
                     416    416 ;code is running. Unless your computer requires interrupts to
                     417    417 ;be enabled, set this to FALSE.
                     418    418 ;
                     419    419 ;"ENINTS equ FALSE" will mask interrupts always, and save
                     420    420 ;several bytes of code space, and protect you from random
                     421    421 ;interrupts and potential code crashes in a computer where
                     422    422 ;interrupts are not set up.
                     423    423 ;
                     424    424 ;Some I/O ports (e.g. the Heathkit H8-5) require interrupts.
                     425    425 ;If such a board is specified above, then interrupts will get
                     426    426 ;enabled anyway, (and the necessary interrupt code will be
                     427    427 ;installed) regardless of what you enter here.
                     428    428 ;--------------------------------------------------------------
0000  =              429    429 ENINTS equ	FALSE
                     430    430 
                     431    431 ;===============================
                     432    432 ;=   End of Assembly Options   =
                     433    433 ;= No user options below here. =
                     434    434 ;===============================
                     435    435 
                     436    436 
                     437    437 ;==============================================================
                     438    438 ;Memon/80 Commands (all values are in HEX)
                     439    439 ;
                     440    440 ; BO <DRIVE>  {Some controllers require ROM2K}
                     441    441 ;    Boot from floppy disk. The <DRIVE> option ( a number
                     442    442 ;    between 0 and 3) is only available for the Cromemco disk
                     443    443 ;    controllers, because CDOS is one of the few S100 operating
                     444    444 ;    systems that allows booting from anything but the first
                     445    445 ;    drive.
                     446    446 ;
                     447    447 ; CE [command line]  {Requires ROM2K}
                     448    448 ;    Execute CP/M program: Copy Command line (any text string)
                     449    449 ;    to RAM at 0080h, install WBOOT jump at 0000h, and jump to
                     450    450 ;    program at 0100h.
                     451    451 ;
                     452    452 ; CO <SRC> <DST> <BCNT> [<RPT>]
                     453    453 ;    Copy <BCNT> bytes of memory from address <SRC> to address
                     454    454 ;    <DST>. The <RPT> option is available only if CORPT=TRUE.
                     455    455 ;    This optionally repeats the copy <RPT> times. (This is for
                     456    456 ;    programming EPROMS with e.g. a Cromemco bytesaver).
                     457    457 ;
                     458    458 ; DU [<ADR> [<BCNT>]]
                     459    459 ;    Dump <BCNT> (which defaults to 1) bytes of memory in both
                     460    460 ;    hex and ASCII, starting at address <ADR> (defaults to 0).
                     461    461 ;
                     462    462 ; EN [<ADR>]
                     463    463 ;    Enter hex data into memory at <ADR>, which defaults to 0.
                     464    464 ;    values are separated with spaces or CR'S. Quit EN command
                     465    465 ;    with a blank line.
                     466    466 ;
                     467    467 ; EX [[<ADR>] <OPT>]
                     468    468 ;    Execute at <ADR>, which defaults to 0. ProgramS can RET
                     469    469 ;    to Memon/80'S main loop.
                     470    470 ;    <OPT> is available only of ROM2K=TRUE. If <OPT>=1 then
                     471    471 ;    Memon/80 executes an IN from port FFh before jumping to
                     472    472 ;    the specified address. (This disables PROM on the
                     473    473 ;    MITS 8800b Turnkey Module and on my 88-2SIOJP.)
                     474    474 ;
                     475    475 ; FI [<ADR> [<BCNT> [<VAL>]]]
                     476    476 ;    Fill <BCNT> bytes of memory starting at <ADR> with <VAL>,
                     477    477 ;    <VAL> and <ADR> default to 0. <BCNT> defaults to all RAM.
                     478    478 ;    Stop when fill reaches Memon/80'S RAM page.
                     479    479 ;
                     480    480 ; HD <ADR> <BCNT>
                     481    481 ;    Intel hex dump <BCNT> bytes of memory starting at <ADR>,
                     482    482 ;    to the Transfer Port
                     483    483 ;
                     484    484 ; HL [<OFST>]
                     485    485 ;    Load Intel hex file to memory from the Transfer Port. Add
                     486    486 ;    optional address offset <OFST> to each record address.
                     487    487 ;    This will generate a "Mem" error if a record will write
                     488    488 ;    over Memon/80's RAM page (or RAM image, if RAMCOD=TRUE).
                     489    489 ;    HL will report the total number of records received when
                     490    490 ;    an Intel hex EOF record is received, if ROM2K=TRUE.
                     491    491 ;
                     492    492 ; IN <PORT>
                     493    493 ;    Input from <PORT> and print result on Console
                     494    494 ;
                     495    495 ; MT <ADR> <CNT>  {Requires ROM2K}
                     496    496 ;    Test <CNT> bytes of memory, starting at <ADR>. This is a
                     497    497 ;    destructive test - RAM will be filled with garbage. Errors
                     498    498 ;    are reported to the Console. This will skip over the
                     499    499 ;    portion of RAM that Memon uses for its stack.   
                     500    500 ;
                     501    501 ; OT <PORT> <data>
                     502    502 ;    Output <data> to <PORT>
                     503    503 ;
                     504    504 ; SE <ADR> <Byte1> [<byte2> [<byte3> [..<Byten>]]]
                     505    505 ;     or
                     506    506 ; SE <ADR> 'text string'  {Requires ROM2K}
                     507    507 ;    Search for string in memory, starting at address <ADR>
                     508    508 ;    Can also mix forms e.g.
                     509    509 ; SE 100 'Hello world' 0D 0A 'second line'
                     510    510 ;
                     511    511 ; TB <BAUD>  {Requires ROM2K}
                     512    512 ;            {deleted if no Transfer Port specified}
                     513    513 ;    Set TRansfer Port baud rate, <BAUD> from this table:
                     514    514 ;    Value  Baud Rate
                     515    515 ;      0       110 (2 stop bits)
                     516    516 ;      1       150
                     517    517 ;      2       300
                     518    518 ;      3       600
                     519    519 ;      4      1200
                     520    520 ;      5      2400
                     521    521 ;      6      4800
                     522    522 ;      7      9600
                     523    523 ;      8     19200
                     524    524 ;      9     38400
                     525    525 ;      A     76800
                     526    526 ;
                     527    527 ;    This command is only available if the serial port board
                     528    528 ;    that's selected to be the Transfer Port allows software to 
                     529    529 ;    set its baud rate. Not all baud rates are available for
                     530    530 ;    every board. Attempting to select an unsupported baud rate
                     531    531 ;    will result in a command error.
                     532    532 ;
                     533    533 ; TE [<EXCHR>] {deleted if no Transfer Port specified}
                     534    534 ;    Terminal mode: Console keyboard input goes to Port B
                     535    535 ;    output, and Port B input goes to the Console output.
                     536    536 ;    Type CTRL-<EXCHR> (which defaults to CTRL-C) to exit.
                     537    537 ;
                     538    538 ; TP [<0/1>] {deleted if no Transfer Port specified}
                     539    539 ;    Enable the Transfer Port. "TP 0" disables the Transfer
                     540    540 ;    port, causing Transfer Port operations to use the Console
                     541    541 ;    Port instead. defaults to 1 (enabled).
                     542    542 ;
                     543    543 ; VE <SRC> <DST> <BCNT>
                     544    544 ;    Verify <BCNT> bytes of memory, starting at <SRC> and <DST>
                     545    545 ;==============================================================
                     546    546 ;REVISION HISTORY
                     547    547 ;
                     548    548 ;VERS. 2.6 by M. Eberhard  1 May 2019 2019
                     549    549 ;  Fix bug with "?" (help) command (Thanks Thomas)
                     550    550 ;
                     551    551 ;VERS. 2.5 by M. Eberhard  11 April 2019
                     552    552 ;  Comment cleanup, fix problem with MITS disk controller
                     553    553 ;  selection.
                     554    554 ;
                     555    555 ;VERS. 2.4 by M. Eberhard 26 December 2018
                     556    556 ;  Work around ASM bug: "set" variables that control
                     557    557 ;  conditional assembly must be declared as 0 (FALSE) first,
                     558    558 ;  before any other value gets assigned to them. Some
                     559    559 ;  additional cleanup as well.
                     560    560 ;
                     561    561 ;VERS. 2.3 by M. Eberhard 3 November 2018
                     562    562 ;  Support the Heathkit H8-4. Support the H8-5, which requires
                     563    563 ;  interrupts for receiving data. Allow interrupts to be
                     564    564 ;  enabled, generally. Allow for no transfer port to be
                     565    565 ;  specified and eliminate all transfer port commands if no
                     566    566 ;  transfer port is defined. Support H17 disk controller. Allow
                     567    567 ;  simple disk boots to work without ROM2K=FALSE. Allow more
                     568    568 ;  assembly options to save code space.
                     569    569 ;
                     570    570 ;VERS. 2.2 by M. Eberhard 1 October 2018
                     571    571 ;  Fix pseudo-op bug when assembling with ROM2k=FALSE
                     572    572 ;
                     573    573 ;VERS. 2.1 by M. Eberhard  26 April 2018
                     574    574 ;  Correct comments for IMSAI 2SIO ports. (Thanks, Len B.)
                     575    575 ;  Support many more I/O boards and disk controllers. Correct a
                     576    576 ;  few comments. Add CE command.
                     577    577 ;
                     578    578 ;VERS. 2.0 by M. Eberhard  31 December 2016
                     579    579 ;  Eliminate Module interface. default TP to enabled.
                     580    580 ;  ROM2K option adds a bunch of commands, requires 2K EPROM.
                     581    581 ;  (Unreleased Version)
                     582    582 ;
                     583    583 ;VERS. 1.1 by M. Eberhard 9 November 2016
                     584    584 ;  Add IN and OT commands. Better defaults and RAM overwrite
                     585    585 ;  protection for FI. check each byte for RAM page overwrite
                     586    586 ;  during HL. disable ints for the IMSAI SIO-2. add support for
                     587    587 ;  several more serial ports. Squeeze code. Eliminate record-
                     588    588 ;  type test on HL. Improve comments & labels a lot.
                     589    589 ;
                     590    590 ;VERS. 1.00 by M. Eberhard 14 April 2014
                     591    591 ;  Created
                     592    592 ;==============================================================
                     593    593 
0026  =              594    594 VERSION	equ	26h		;BCD-encoded version number
                     595    595 
                     596    596  if not ROM2K
                     597    597 ROMSIZ	equ	400h		;1K EPROM size (e.g. 2708)
                     598    598  endif ;not ROM2K
                     599    599  if ROM2K
0800  =              600    600 ROMSIZ	equ	800h		;2K EPROM size (e.g. 2716)
                     601    601  endif ;ROM2K
                     602    602 
                     603    603 ;***********************
                     604    604 ;General program Equates
                     605    605 ;***********************
0003  =              606    606 CTRLC	equ	03h		;ASCII control-C
0008  =              607    607 BS	equ	08h		;ASCII backspace
000a  =              608    608 LF	equ	0Ah		;ASCII linefeed
000d  =              609    609 CR	equ	0DH		;ASCII carriage return
0027  =              610    610 QUOTE	equ	27h		;ASCII single quote
007f  =              611    611 DEL	equ	7Fh		;ASCII delete
                     612    612 
003e  =              613    613 PROMPT	equ	'>'		;prompt character
0003  =              614    614 CABKEY	equ	CTRLC		;command abort character
0003  =              615    615 DTEXIT	equ	CTRLC		;default Terminal mode exit chr
002e  =              616    616 PCFIER	equ	'.'		;Console pacifier chr
0010  =              617    617 HDRLEN	equ	16		;Intel hex record length for HD
                     618    618 
0020  =              619    619 STKSIZ	equ	32		;Max stack size
0050  =              620    620 LBSIZE	equ	80		;input line buffer size
                     621    621 
                     622    622 ;*********************
                     623    623 ;RAM Page Organization
                     624    624 ;*********************
                     625    625  if RAMHNT and not (A88DCD or A88MCD)
00b0  =              626    626 RAMBUF	equ	100h-LBSIZE	;buffer offest in RAM page
                     627    627  endif ;RAMHNT and not (A88DCD or A88MCD)
                     628    628 
                     629    629  if not RAMHNT and not (A88DCD or A88MCD)
                     630    630 RAMBUF	equ	RAMEND-LBSIZE+1	;buffer address in RAM page
                     631    631  endif ;not RAMHNT and not (A88DCD or A88MCD)
                     632    632 
                     633    633 ;The Altair disk controller code requires the buffer to be at
                     634    634 ;the end of a 256-byte page
                     635    635 
                     636    636  if  RAMHNT and (A88DCD or A88MCD)
                     637    637 RAMBUF	equ	100h-85h	;Exactly room for 1 sector
                     638    638 				;SECSIZ=BPS+HDRSIZ+TLRSIZ
                     639    639  endif ;RAMHNT and (A88DCD or A88MCD)
                     640    640 
                     641    641  if  (not RAMHNT) and (A88DCD or A88MCD)
                     642    642 RAMBUF	equ	RAMEND-85h+1	;Exactly room for 1 sector
                     643    643 				;SECSIZ=BPS+HDRSIZ+TLRSIZ
                     644    644  endif ;(not RAMHNT) and (A88DCD or A88MCD)
                     645    645 
                     646    646 ;The stack goes just below the RAM buffer
                     647    647 
00b0  =              648    648 STACK	equ	RAMBUF		;SP decrements before writing
                     649    649 
                     650    650 ;Assign for interrupt flags, even if we don't use them
                     651    651 ;Note: if interrupts are used then RAMHNT MUST be FALSE
                     652    652 
008f  =              653    653 CIFLAG	equ	STACK-STKSIz-1	;console interrupt Rx flag
008e  =              654    654 CRXBUF	equ	STACK-STKSIz-2	;console interrupt Rx buffer
008d  =              655    655 TIFLAG	equ	STACK-STKSIz-3	;T-port interrupt Rx flag 
008c  =              656    656 TRXBUF	equ	STACK-STKSIz-4	;T-port interrupt Rx buffer
                     657    657 
                     658    658 ;************************************************************
                     659    659 ;CP/M Equates (for CE command)
                     660    660 ;The CE command creates a CP/M BIOS-like jump to Memon/80's
                     661    661 ;warm-boot entry point, which is followed by a CP/M BIOS-
                     662    662 ;like jump table to its I/O routines. The CE command also
                     663    663 ;moves the command-line text entered by the user to the
                     664    664 ;CP/M-like COMBUF. These make execution possible for simple
                     665    665 ;CP/M programs that only call the BIOS for console I/O, and
                     666    666 ;make no BDOS calls. This command is especially useful for
                     667    667 ;building a CP/M disk form scratch, allowing you to load
                     668    668 ;(via the HL command) and run (via the CE command) programs
                     669    669 ;like FORMAT and PUTSYS. Once you have a diskette with a bare
                     670    670 ;CP/M and a working BIOS, you can uses these commands to load
                     671    671 ;CP/M's non-built in commands onto the diskette.
                     672    672 ;************************************************************
                     673    673  if ROM2K
0000  =              674    674 WBOOT	equ	0000H		;Jump to "BIOS" warm boot
0001  =              675    675 WBOOTA	equ	WBOOT+1		;Address of Warm Boot
0080  =              676    676 COMBUF	equ	WBOOT+80H	;command line buffer
0100  =              677    677 USAREA	equ	WBOOT+100H	;User program area
                     678    678  endif ;ROM2K
                     679    679 
                     680    680 ;==================================================
                     681    681 ;= Option Selection Logic                         =
                     682    682 ;=                                                =
                     683    683 ;= The following long section of equates performs =
                     684    684 ;= the logic for supporting the various serial    =
                     685    685 ;= ports and disk controllers, as selected above. =
                     686    686 ;= Generally, these should not be modified.       =
                     687    687 ;==================================================
                     688    688 
                     689    689 ;-------------------------------------------
                     690    690 ;Initialize some assembler variables that
                     691    691 ;may get changed, based on options set above
                     692    692 ;-------------------------------------------
0000  #              693    693 TMEMAP	set	FALSE
0000  #              694    694 CMEMAP	set	FALSE
0000  #              695    695 TMRCTC	set	FALSE
0000  #              696    696 T5511	set	FALSE
0000  #              697    697 C6850	set	FALSE
0000  #              698    698 T6850	set	FALSE
0000  #              699    699 C8250	set	FALSE
0000  #              700    700 T8250	set	FALSE
0000  #              701    701 C8251	set	FALSE
0000  #              702    702 T8251	set	FALSE
0000  #              703    703 DART	set	FALSE
0000  #              704    704 CISTAT	set	FALSE
0000  #              705    705 TISTAT	set	FALSE
0000  #              706    706 CSBAUD	set	FALSE
0000  #              707    707 TSBAUD	set	FALSE
0000  #              708    708 BD192	set	FALSE
0000  #              709    709 BD384	set	FALSE
0000  #              710    710 BD576	set	FALSE
0000  #              711    711 BD768	set	FALSE
0000  #              712    712 CRXINT	set	FALSE
0000  #              713    713 TRXINT	set	FALSE
0000  #              714    714 TPORT	set	FALSE
                     715    715 
                     716    716 ;-------------------------------------------------------
                     717    717 ;Altair 88-SIO Equates
                     718    718 ;
                     719    719 ;The 88-SIO is built around a 2502-type generic UART,
                     720    720 ;with a jumper selectable baud rate generator and with
                     721    721 ;external logic providing status and control registers.
                     722    722 ;
                     723    723 ;Note that the 88-SIO requires no initialization.
                     724    724 ;-------------------------------------------------------
                     725    725  if CALSIO
                     726    726 
                     727    727 CSTAT	equ	CBASE		;1st SIO status input port
                     728    728 CDATA	equ	CBASE+1		;1st SIO Rx & Tx data regs
                     729    729 
                     730    730 CRXRDY	equ	00000001B	;Console Rx data reg full
                     731    731 CTXRDY	equ	10000000B	;Console Tx data reg empty
                     732    732 
                     733    733 CISTAT	set	TRUE		;Status bits are active-low
                     734    734  endif ;CALSIO
                     735    735 
                     736    736  if TALSIO
                     737    737 TPORT	set	TRUE		;Transfer port is defined
                     738    738 
                     739    739 TSTAT	equ	TBASE		;2nd SIO status input port
                     740    740 TDATA	equ	TBASE+1		;2nd SIO Rx & Tx data regs
                     741    741 
                     742    742 TRXRDY	equ	00000001B	;Transfer Port Rx data reg full
                     743    743 TTXRDY	equ	10000000B	;Trans. port Tx data reg empty
                     744    744 
                     745    745 TISTAT	set	TRUE		;Status bits active-low
                     746    746  endif ;TALSIO
                     747    747 
                     748    748 ;-------------------------------------------------------------
                     749    749 ;Altair 88-2SIO, 8800b Turnkey Module, and MITS 88-UIO Equates
                     750    750 ;
                     751    751 ;The 88-2SIO, the 8800b Turnkey Module, the 88-UIO, and my own
                     752    752 ;88-2SIOJP are all built around a pair of MC6850 ACIA'S with a
                     753    753 ;jumper-selectable baud rate generator.
                     754    754 ;-------------------------------------------------------------
                     755    755  if CA2SIO
                     756    756 C6850	set	TRUE		;Altair 6850-type UART present
                     757    757 CB6850	equ	CBASE
                     758    758  endif ;CA2SIO
                     759    759 
                     760    760  if TA2SIO
                     761    761 TPORT	set	TRUE		;Transfer port is defined
                     762    762 T6850	set	TRUE		;Altair 6850-type UART present
                     763    763 TB6850	equ	TBASE
                     764    764  endif ;TA2SIO
                     765    765 
                     766    766 ;--------------------------------------------------------------
                     767    767 ;CCS 2718 Equates
                     768    768 ;
                     769    769 ;The CCS 2718's serial port A is built around an 1883/1602/1611
                     770    770 ;generic UART. Its serial port B is built around an 8251 UART.
                     771    771 ;Both UARTs are clocked by an external baud rate generator that
                     772    772 ;can be forced to a chosen baud rate for each port with
                     773    773 ;juimpers, or jumpered for software baud rate control. This
                     774    774 ;code assumes that software can control the baud rates.
                     775    775 ;Additionally, the control register for serial port A is
                     776    776 ;configured with jumpers. This code assumes the configuration
                     777    777 ;is as shown on page 2-8 of the CCS 2718 manual.
                     778    778 ;--------------------------------------------------------------
                     779    779  if CC2718A
                     780    780 CSTAT	equ	CBASE	;serial port A status
                     781    781 CCTRL	equ	CBASE	;channel a control
                     782    782 CDATA	equ	CBASE+1	;serial port A data
                     783    783 
                     784    784 CTXRDY	  equ	  01h	;Console Tx ready bit
                     785    785 CRXRDY	  equ	  02h	;Console Rx ready bit
                     786    786 
                     787    787 CBD110	equ	10Fh	;0= 110 baud
                     788    788 CBD150	equ	10Eh	;1= 150 baud
                     789    789 CBD300	equ	10Dh	;2= 300 baud
                     790    790 CBD600	equ	106h	;3= 600 baud
                     791    791 CBD1200	equ	10Bh	;4= 1200 baud
                     792    792 CBD2400	equ	10Ch	;5= 2400 baud
                     793    793 CBD4800	equ	109h	;6= 4800 baud
                     794    794 CBD9600	equ	108H	;7= 9600 baud
                     795    795 CBD192	equ	0	;8= 19200 baud
                     796    796 CBD384	equ	0	;9= 38400 baud (not supported)
                     797    797 CBD576	equ	0	;a= 57600 baud (not supported)
                     798    798 CBD768	equ	0	;b= 76800 baud (not supported)
                     799    799 
                     800    800 CSBAUD	set	TRUE	;software Console baud rate control
                     801    801  endif ;CCS2718A
                     802    802 
                     803    803  if CC2718B
                     804    804 C8251 set TRUE
                     805    805 CB8251	equ	CBASE+2	;Base of Console 8251 registers
                     806    806 
                     807    807 CBD110	equ	1F0h	;0= 110 baud
                     808    808 CBD150	equ	1E0h	;1= 150 baud
                     809    809 CBD300	equ	1D0h	;2= 300 baud
                     810    810 CBD600	equ	160h	;3= 600 baud
                     811    811 TBD1200	equ	1B0h	;4= 1200 baud
                     812    812 CBD2400	equ	1C0h	;5= 2400 baud
                     813    813 CBD4800	equ	190h	;6= 4800 baud
                     814    814 CBD9600	equ	180H	;7= 9600 baud
                     815    815 CBD192	equ	0	;8= 19200 baud
                     816    816 CBD384	equ	0	;9= 38400 baud (not supported)
                     817    817 CBD576	equ	0	;a= 57600 baud (not supported)
                     818    818 CBD768	equ	0	;b= 76800 baud (not supported)
                     819    819 
                     820    820 CSBAUD	set	TRUE	;software Console baud rate control
                     821    821  endif ;CCS2718B
                     822    822 
                     823    823  if TC2718A
                     824    824 TPORT	set	TRUE	;Transfer port is defined
                     825    825 
                     826    826 TSTAT	equ	TBASE	;serial port A status
                     827    827 TCTRL	equ	TBASE	;channel a control
                     828    828 TDATA	equ	TBASE+1	;serial port A data
                     829    829 
                     830    830 TTXRDY	  equ	  01h	;Transfer Port Tx ready bit
                     831    831 TRXRDY	  equ	  02h	;Transfer Port Rx ready bit
                     832    832 
                     833    833 TBD110	equ	10Fh	;0= 110 baud
                     834    834 TBD150	equ	10Eh	;1= 150 baud
                     835    835 TBD300	equ	10Dh	;2= 300 baud
                     836    836 TBD600	equ	106h	;3= 600 baud
                     837    837 TBD1200	equ	10Bh	;4= 1200 baud
                     838    838 TBD2400	equ	10Ch	;5= 2400 baud
                     839    839 TBD4800	equ	109h	;6= 4800 baud
                     840    840 TBD9600	equ	108H	;7= 9600 baud
                     841    841 TBD192	equ	100h	;8= 19200 baud
                     842    842 TBD384	equ	0	;9= 38400 baud (not supported)
                     843    843 TBD576	equ	0	;a= 57600 baud (not supported)
                     844    844 TBD768	equ	0	;b= 76800 baud (not supported)
                     845    845 
                     846    846 TSBAUD	set	TRUE	;software transfer port baud control
                     847    847  endif ;TCS2718A
                     848    848 
                     849    849  if TC2718B
                     850    850 T8251 set TRUE
                     851    851 TB8251	equ	CBASE+2		;Base of T-port 8251 registers
                     852    852 
                     853    853 TBD110	equ	1F0h	;0= 110 baud
                     854    854 TBD150	equ	1E0h	;1= 150 baud
                     855    855 TBD300	equ	1D0h	;2= 300 baud
                     856    856 TBD600	equ	160h	;3= 600 baud
                     857    857 TBD1200	equ	1B0h	;4= 1200 baud
                     858    858 TBD2400	equ	1C0h	;5= 2400 baud
                     859    859 TBD4800	equ	190h	;6= 4800 baud
                     860    860 TBD9600	equ	180H	;7= 9600 baud
                     861    861 TBD192	equ	100h	;8= 19200 baud
                     862    862 TBD384	equ	0	;9= 38400 baud (not supported)
                     863    863 TBD576	equ	0	;a= 57600 baud (not supported)
                     864    864 TBD768	equ	0	;b= 76800 baud (not supported)
                     865    865 
                     866    866 TSBAUD	set	TRUE	;software transfer port baud control
                     867    867 BD192	set	TRUE	;19200 baud supported
                     868    868  endif ;CCS2718B
                     869    869 
                     870    870 ;-------------------------------------------------------
                     871    871 ;CCS 2719 Equates
                     872    872 ;
                     873    873 ;The CCS 2719 is built around a Z80-DART (dual UART) and
                     874    874 ;a Z80-CTC (counter/timer, which generates baud rates).
                     875    875 ;-------------------------------------------------------
                     876    876  if CC2719A or CC2719B or TC2719A or TC2719B
                     877    877 
                     878    878 DART	set	TRUE	;DART present
                     879    879 
                     880    880 DWR1	equ	1	;Write Register 1
                     881    881 DWR2	equ	2	;Write Register 2
                     882    882 DWR3	equ	3	;Write Register 3
                     883    883 DWR4	equ	4	;Write Register 4
                     884    884 DWR5	equ	5	;Write Register 5
                     885    885 
                     886    886 DART1S	equ	44h	;1 stop bit
                     887    887 DART2S	equ	4CH	;2 stop bits
                     888    888 
                     889    889 ;DART initialization sequence, both ports
                     890    890 ;note: INIT code assumes that DI7 is UNIQUE
                     891    891 
                     892    892 DI1	equ	28h	;channel Reset
                     893    893 DI2	equ	DWR1	;Access WR1
                     894    894 DI3	equ	00h	;Disable interrupts
                     895    895 DI4	equ	DWR3	;Access WR3
                     896    896 DI5	equ	0C1h	;Rx 8-bit bytes, enable Rx
                     897    897 DI6	equ	DWR5	;Access WR5
                     898    898 DI7	equ	0EAh	;Tx 8-bit bytes, enable Tx, 
                     899    899 			;handshakes true
                     900    900 
                     901    901  endif ;CC2719A or CC2719B or TC2719A or TC2719B
                     902    902 
                     903    903  if CC2719A
                     904    904 CCTC	equ	CBASE	;CTC channel for Console baud
                     905    905 CDATA	equ	CBASE+4	;channel A data
                     906    906 CSTAT	equ	CBASE+5	;channel A status
                     907    907 CCTRL	equ	CBASE+5	;channel A control
                     908    908  endif ;CC2719A
                     909    909 
                     910    910  if CC2719B
                     911    911 CCTC	equ	CBASE+1	;CTC channel for Console baud
                     912    912 CDATA	equ	CBASE+6	;channel B data
                     913    913 CSTAT	equ	CBASE+7	;channel B status
                     914    914 CCTRL	equ	CBASE+7	;channel B control
                     915    915  endif ;CC2719B
                     916    916 
                     917    917  if TC2719A
                     918    918 TCTC	equ	TBASE	;CTC channel for TR port baud
                     919    919 TDATA	equ	TBASE+4	;channel A data
                     920    920 TSTAT	equ	TBASE+5	;channel A status
                     921    921 TCTRL	equ	TBASE+5	;channel A control
                     922    922  endif ;TC2719A
                     923    923 
                     924    924  if TC2719B
                     925    925 TCTC	equ	TBASE+1	;CTC channel for TR port baud
                     926    926 TDATA	equ	TBASE+6	;channel B data
                     927    927 TSTAT	equ	TBASE+7	;channel B status
                     928    928 TCTRL	equ	TBASE+7	;channel B control
                     929    929  endif ;TC2719B
                     930    930 
                     931    931  if CC2719A or CC2719B
                     932    932 CTXRDY	  equ	  04h	 ;Console Tx ready bit
                     933    933 CRXRDY	  equ	  01h	 ;Console Rx ready bit
                     934    934 
                     935    935 ;Console Port baud rate values
                     936    936 ;high byte must be written 1st
                     937    937 
                     938    938 CBD110	equ	078DH	;0= 110 baud 2 stop bits
                     939    939 CBD150	equ	0768h	;1= 150 baud
                     940    940 CBD300	equ	0734h	;2= 300 baud
                     941    941 CBD600	equ	47C0h	;3= 600 baud
                     942    942 CBD1200	equ	4760h	;4= 1200 baud
                     943    943 CBD2400	equ	4730h	;5= 2400 baud
                     944    944 CBD4800	equ	4718h	;6= 4800 baud
                     945    945 CBD9600	equ	470CH	;7= 9600 baud
                     946    946 CBD192	equ	4706h	;8= 19200 baud
                     947    947 CBD384	equ	4703h	;9= 38400 baud
                     948    948 CBD576	equ	4702h	;a= 57600 baud
                     949    949 CBD768	equ	0	;b= 76800 baud (not supported)
                     950    950 
                     951    951 CSBAUD	set	TRUE	;software Console
                     952    952 			;..baud rate control
                     953    953 CSTOP1	equ	DART1S
                     954    954 CSTOP2	equ	DART2S
                     955    955 
                     956    956 CSTOPS	set	CSTOP2
                     957    957  endif ;CC2719A or CC2719B
                     958    958 
                     959    959   if (CC2719A or CC2719B) and ((0-CBAUD) SHR 15)
                     960    960 CSTOPS	set	CSTOP1
                     961    961  endif ;(CC2719A or CC2719B) and ((0-CBAUD) SHR 15)
                     962    962 
                     963    963  if TC2719A or TC2719B
                     964    964 TPORT	set	TRUE	;Transfer port is defined
                     965    965 
                     966    966 TTXRDY	  equ	  04h	;Transfer Port Tx ready bit
                     967    967 TRXRDY	  equ	  01h	;Transfer Port Rx ready bit
                     968    968 
                     969    969 ;Transfer Port baud rate values
                     970    970 ;high byte must be written 1st
                     971    971 
                     972    972 TBD110	equ	078DH	;0= 110 baud 2 stop bits
                     973    973 TBD150	equ	0768h	;1= 150 baud
                     974    974 TBD300	equ	0734h	;2= 300 baud
                     975    975 TBD600	equ	47C0h	;3= 600 baud
                     976    976 TBD1200	equ	4760h	;4= 1200 baud
                     977    977 TBD2400	equ	4730h	;5= 2400 baud
                     978    978 TBD4800	equ	4718h	;6= 4800 baud
                     979    979 TBD9600	equ	470CH	;7= 9600 baud
                     980    980 TBD192	equ	4706h	;8= 19200 baud
                     981    981 TBD384	equ	4703h	;9= 38400 baud
                     982    982 TBD576	equ	4702h	;a= 57600 baud
                     983    983 TBD768	equ	0	;b= 76800 baud (not supported)
                     984    984 
                     985    985 BD192	set	TRUE	;19200 baud supported
                     986    986 BD384	set	TRUE	;38400 baud supported
                     987    987 BD576	set	TRUE	;57600 baud supported
                     988    988 
                     989    989 BRATE0	equ	TCTC	;LOW baud byte goes here
                     990    990 BRATE1	equ	TCTC	;high baud byte goes here
                     991    991 
                     992    992 TMRCTC	set	TRUE	;Z80-CTC used as timer
                     993    993 TSBAUD	set	TRUE	;software Transfer Port
                     994    994 
                     995    995 TSTOP1	equ	DART1S
                     996    996 TSTOP2	equ	DART2S
                     997    997 
                     998    998 TSTOPS	set	TSTOP2
                     999    999  endif ;TC2719A or TC2719B
                    1000   1000 
                    1001   1001   if (TC2719A or TC2719B) and ((0-TBAUD) SHR 15)
                    1002   1002 TSTOPS	set	TSTOP1
                    1003   1003  endif ;(TC2719A or TC2719B) and ((0-TBAUD) SHR 15)
                    1004   1004 
                    1005   1005 ;--------------------------------------------------
                    1006   1006 ;CCS 2810 Serial Port Equates
                    1007   1007 ;
                    1008   1008 ;The serial port on the CCS 2810 CPU board is built
                    1009   1009 ;around the National Semiconductor INS8250 UART,
                    1010   1010 ;which has a buad rate generator built into it.
                    1011   1011 ;--------------------------------------------------
                    1012   1012 
                    1013   1013 ;CCS2810 serial port as the Console
                    1014   1014 
                    1015   1015  if CC2810
                    1016   1016 C8250	set	TRUE
                    1017   1017 CB8250	equ	CBASE
                    1018   1018  endif ;CC2810
                    1019   1019 
                    1020   1020 ;CCS2810 serial Port As the Transfer Port
                    1021   1021 
                    1022   1022  if TC2810
                    1023   1023 T8250	set	TRUE
                    1024   1024 TB8250	equ	TBASE
                    1025   1025  endif ;TC2810
                    1026   1026 
                    1027   1027 ;--------------------------------------------------------
                    1028   1028 ;Compupro Interfacer 1 Equates
                    1029   1029 ;
                    1030   1030 ;The Interfacer 1 is built around a pair of 1602-type
                    1031   1031 ;generic UARTs, with jumper selectable baud rate
                    1032   1032 ;generators and with external logic providing status
                    1033   1033 ;and control registers.
                    1034   1034 ;
                    1035   1035 ;Control bits are configured with jumpers. the board will
                    1036   1036 ;XOR whatever you write to the control port with the
                    1037   1037 ;jumper setting. This assumes all jumpers are set to 0.
                    1038   1038 ;--------------------------------------------------------
                    1039   1039  if CIFAC
                    1040   1040 CSTAT	equ	CBASE	;Console status
                    1041   1041 CCTRL	equ	CBASE	;Console control
                    1042   1042 CDATA	equ	CBASE+1	;Console data
                    1043   1043 
                    1044   1044 CTXRDY	  equ	  01h	;channel a Tx ready bit
                    1045   1045 CRXRDY	  equ	  02h	;channel a Rx ready bit
                    1046   1046  endif ;CIFAC
                    1047   1047 
                    1048   1048  if TIFAC
                    1049   1049 TPORT	set	TRUE	;Transfer port is defined
                    1050   1050 
                    1051   1051 TSTAT	equ	TBASE	;Transfer Port status
                    1052   1052 TCTRL	equ	TBASE	;Transfer Port control
                    1053   1053 TDATA	equ	TBASE+1	;Transfer Port data
                    1054   1054 
                    1055   1055 TTXRDY	  equ	  01h	;channel B Tx ready bit
                    1056   1056 TRXRDY	  equ	  02h	;channel B Rx ready bit
                    1057   1057  endif ;TIFAC
                    1058   1058 
                    1059   1059  if CIFAC or TIFAC
                    1060   1060 IFRST	equ	0ACH	;reset: 8 data, no parity, flow
                    1061   1061 			;..control outputs high, no ints
                    1062   1062  endif	;CIFAC or TIFAC
                    1063   1063 
                    1064   1064 ;---------------------------------------------------------
                    1065   1065 ;Compupro Interfacer II Equates
                    1066   1066 ;The Interfacer II is built around a  1602-type generic
                    1067   1067 ;UART, with jumper selectable baud rate generator and with
                    1068   1068 ;external logic providing status and control registers.
                    1069   1069 ;
                    1070   1070 ;Control bits are configured with jumpers. The board will
                    1071   1071 ;XOR whatever you write to the control port with the
                    1072   1072 ;jumper setting. This assumes all jumpers are set to 0.
                    1073   1073 ;---------------------------------------------------------
                    1074   1074  if CIFAC2
                    1075   1075 CSTAT	equ	CBASE	;Console status
                    1076   1076 CCTRL	equ	CBASE	;Console control
                    1077   1077 CDATA	equ	CBASE+1	;Console data
                    1078   1078 
                    1079   1079 CTXRDY	  equ	  01h	;Console Tx ready bit
                    1080   1080 CRXRDY	  equ	  02h	;Console Rx ready bit
                    1081   1081 
                    1082   1082 CIFRST	equ	0ACH	;reset: 8 data, no parity, flow
                    1083   1083 			;..control outputs high, no ints
                    1084   1084 
                    1085   1085  endif ;CIFAC2
                    1086   1086 
                    1087   1087  if TIFAC2
                    1088   1088 TPORT	set	TRUE	;Transfer port is defined
                    1089   1089 
                    1090   1090 TSTAT	equ	TBASE	;Transfer Port status
                    1091   1091 TCTRL	equ	TBASE	;Transfer Port control
                    1092   1092 TDATA	equ	TBASE+1	;Transfer Port data
                    1093   1093 
                    1094   1094 TTXRDY	  equ	  01h	;Transfer Port Tx ready bit
                    1095   1095 TRXRDY	  equ	  02h	;Transfer Port Rx ready bit
                    1096   1096 
                    1097   1097 TIFRST	equ	0ACH	;reset: 8 data, no parity,
                    1098   1098 			;..controls high, no ints
                    1099   1099  endif ;TIFAC2
                    1100   1100 
                    1101   1101 ;------------------------------------------------------
                    1102   1102 ;Cromemco TU-ART Equates
                    1103   1103 ;Cromemco 4FDC/16FDC/64FDC serial port Equates
                    1104   1104 ;
                    1105   1105 ;The TU-ART is built around a pair of TMS5511 UARTs
                    1106   1106 ;with integral software-settable baud rate generators.
                    1107   1107 ;
                    1108   1108 ;The serial ports on the Cromemco xFDC disk controllers
                    1109   1109 ;are built around the (very similar) TMS5501 UART
                    1110   1110 ;------------------------------------------------------
                    1111   1111  if CTUART or TTUART or CCFDCS or TCFDCS
                    1112   1112 TURST	equ	  01h	;reset UART
                    1113   1113 TUHBD	equ	  10h	;high baud rate
                    1114   1114  endif ;CTUART or TTUART or CCFDCS or TCFDCS
                    1115   1115 
                    1116   1116  if CTUART or CCFDCS
                    1117   1117 CSTAT	equ	CBASE	;Console status
                    1118   1118 CDATA	equ	CBASE+1	;Console data
                    1119   1119 TCPBAUD	equ	CBASE	;Console baud rate
                    1120   1120 TCCTRL	equ	CBASE+2	;Console control
                    1121   1121 TCINTE	equ	CBASE+3	;Console interrupt enable
                    1122   1122 
                    1123   1123 CRXRDY	equ	40h	;Console Rx data buffer full
                    1124   1124 CTXRDY	equ	80h	;Console Tx data buf available
                    1125   1125 
                    1126   1126 CSTOP1	equ	80h	;1 stop bit
                    1127   1127 CSTOP2	equ	0	;2 stop bits
                    1128   1128 
                    1129   1129 ;Console Port TU-ART baud rates
                    1130   1130 ; high byte is the command register value
                    1131   1131 ; low byte is the baud rate register value
                    1132   1132 ; bit 7 of the low byte selects 2 stop bits if 0
                    1133   1133 
                    1134   1134 CBD110	equ	0001h or CSTOP2	;110 baud
                    1135   1135 CBD150	equ	0002h or CSTOP1	;150 baud
                    1136   1136 CBD300	equ	0004h or CSTOP1	;300 baud
                    1137   1137 CBD600	equ	0 		;600 baud (not supported)
                    1138   1138 CBD1200	equ	0008h or CSTOP1	;1200 baud
                    1139   1139 CBD2400	equ	0010h or CSTOP1	;2400 baud
                    1140   1140 CBD4800	equ	0020h or CSTOP1	;4800 baud
                    1141   1141 CBD9600	equ	0040h or CSTOP1	;9600 baud
                    1142   1142 CBD192	equ	1010h or CSTOP1	;19200 baud
                    1143   1143 CBD384	equ	1020h or CSTOP1	;38400 baud
                    1144   1144 CBD576	equ	0 		;57600 baud (not supported)
                    1145   1145 CBD768	equ	1040h or CSTOP1	;76800 baud
                    1146   1146 
                    1147   1147 CSBAUD	set	TRUE	;software Console
                    1148   1148 			;..baud rate control
                    1149   1149 CSTOPS	set	CSTOP2
                    1150   1150  endif ;CTUART or CCFDCS
                    1151   1151 
                    1152   1152   if (CTUART or CCFDCS) and ((0-CBAUD) SHR 15)
                    1153   1153 CSTOPS	set	CSTOP1
                    1154   1154  endif ;(CTUART or CCFDCS) and ((0-CBAUD) SHR 15)
                    1155   1155 
                    1156   1156  if TTUART or TCFDCS
                    1157   1157 TPORT	set	TRUE	;Transfer port is defined
                    1158   1158 
                    1159   1159 TSTAT	equ	TBASE	;Transfer Port status
                    1160   1160 TDATA	equ	TBASE+1	;Transfer Port data
                    1161   1161 TTPBAUD	equ	TBASE	;Transfer Port baud rate
                    1162   1162 TTCTRL	equ	TBASE+2	;Transfer Port control
                    1163   1163 TTINTE	equ	TBASE+3	;Transfer Port interrupt enable
                    1164   1164 
                    1165   1165 TRXRDY	equ	40h	;Tx Port Rx data buffer full
                    1166   1166 TTXRDY	equ	80h	;Tx Port Tx data buf available
                    1167   1167 
                    1168   1168 BRATE0	equ	TTPBAUD	;LOW baud byte goes here
                    1169   1169 BRATE1	equ	TTCTRL	;high baud byte goes here
                    1170   1170 
                    1171   1171 TSTOP1	equ	80h	;1 stop bit
                    1172   1172 TSTOP0	equ	0	;2 stop bits
                    1173   1173 
                    1174   1174 ;Transfer Port TU-ART baud rates
                    1175   1175 ; high byte is the command register value
                    1176   1176 ; low byte is the baud rate register value
                    1177   1177 
                    1178   1178 TBD110	equ	0001h or TSTOP2	;110 baud
                    1179   1179 TBD150	equ	0002h or TSTOP1	;150 baud
                    1180   1180 TBD300	equ	0004h or TSTOP1	;300 baud
                    1181   1181 TBD600	equ	0		;600 baud (not supported)
                    1182   1182 TBD1200	equ	0008h or TSTOP1	;1200 baud
                    1183   1183 TBD2400	equ	0010h or TSTOP1	;2400 baud
                    1184   1184 TBD4800	equ	0020h or TSTOP1	;4800 baud
                    1185   1185 TBD9600	equ	0040h or TSTOP1	;9600 baud
                    1186   1186 TBD192	equ	1010h or TSTOP1	;19200 baud
                    1187   1187 TBD384	equ	1020h or TSTOP1	;38400 baud
                    1188   1188 TBD576	equ	0 		;57600 baud (not supported)
                    1189   1189 TBD768	equ	1040h or TSTOP1	;76800 baud
                    1190   1190 
                    1191   1191 BD192	set	TRUE	;19200 baud supported
                    1192   1192 BD384	set	TRUE	;38400 baud supported
                    1193   1193 BD768	set	TRUE	;76800 baud supported
                    1194   1194 
                    1195   1195 TSBAUD	set	TRUE	;software T-port baud rate control
                    1196   1196 T5511	set	TRUE	;Transfer port baud rates via TMS5511
                    1197   1197 
                    1198   1198 TSTOPS	set	TSTOP2
                    1199   1199  endif ;TTUART or TCFDCS
                    1200   1200 
                    1201   1201   if (TTUART or TCFDCS) and ((0-TBAUD) SHR 15)
                    1202   1202 TSTOPS	set	TSTOP1
                    1203   1203  endif ;(TTUART or TCFDCS) and ((0-TBAUD) SHR 15)
                    1204   1204 
                    1205   1205 ;-------------------------------------------------
                    1206   1206 ;Electronic Control Technology (ECT) R2I/O Equates
                    1207   1207 ;
                    1208   1208 ;The ECT R2I/O is built around three TMS6011
                    1209   1209 ;generic UARTS with jumper-selectable baud rates.
                    1210   1210 ;-------------------------------------------------
                    1211   1211  if CER2IO
                    1212   1212 CSTAT	equ	CBASE	;Console status
                    1213   1213 CDATA	equ	CBASE+1	;Console data
                    1214   1214 
                    1215   1215 CRXRDY	equ	01h	;Console Rx data buffer full
                    1216   1216 CTXRDY	equ	80h	;Console Tx data buf available
                    1217   1217 
                    1218   1218 CISTAT	set	TRUE	;Status bits are active-low
                    1219   1219  endif ;CER2IO
                    1220   1220 
                    1221   1221  if TER2IO
                    1222   1222 TPORT	set	TRUE	;Transfer port is defined
                    1223   1223 
                    1224   1224 TSTAT	equ	TBASE	;Transfer Port status
                    1225   1225 TDATA	equ	TBASE+1	;Transfer Port data
                    1226   1226 
                    1227   1227 TRXRDY	equ	01h	;Transfer port Rx data buffer full
                    1228   1228 TTXRDY	equ	80h	;Transfer port Tx data buf available
                    1229   1229 
                    1230   1230 TISTAT	set	TRUE	;Status bits are active-low
                    1231   1231  endif ;TER2IO
                    1232   1232 
                    1233   1233 ;--------------------------------------------------------------
                    1234   1234 ;Heathkit H8-4 Serial Port Equates
                    1235   1235 ;
                    1236   1236 ; The Heathkit H8-4 has 4 independent, seperately addressable
                    1237   1237 ; serial ports, each built around a National Semiconductor
                    1238   1238 ; INS8250 UART.
                    1239   1239 ;
                    1240   1240 ; CPU Interrupts must be enabled so that the Heathkit H8's
                    1241   1241 ; front panel will work correctly. The H8-4 may or may not be
                    1242   1242 ; connected to one of the interrupt lines. However, this code
                    1243   1243 ; disables the H8-4's interrupts in software, and polls its
                    1244   1244 ; UART(s) as with most other supported ports.
                    1245   1245 ;--------------------------------------------------------------
                    1246   1246 
                    1247   1247 ;H8-4 serial port as the Console
                    1248   1248 
                    1249   1249  if CH84
                    1250   1250 C8250	set	TRUE
                    1251   1251 CB8250	equ	CBASE
                    1252   1252  endif ;CH84
                    1253   1253 
                    1254   1254 ;H8-4 serial Port As the Transfer Port
                    1255   1255 
                    1256   1256  if TH84
                    1257   1257 T8250	set	TRUE
                    1258   1258 TB8250	equ	TBASE
                    1259   1259  endif ;TH84
                    1260   1260 
                    1261   1261 ;--------------------------------------------------------------
                    1262   1262 ;Heathkit H8-5 Serial Port Equates
                    1263   1263 ;
                    1264   1264 ; The H8-5 is built around an Intel 8251 (not the 8251A) UART,
                    1265   1265 ; which has some peculiarities when operating with interrupts.
                    1266   1266 ; In particular, disabling the transmitter (which is the only
                    1267   1267 ; way to disable the transmit interrupt) will stop transmitting
                    1268   1268 ; mid-byte, if the transmitter is busy. This makes the transmit
                    1269   1269 ; interrupt pretty worthless. Heathkit's recommended jumpers
                    1270   1270 ; only enable interrupts for receive data, not transmit. I
                    1271   1271 ; suspect it is for this reason.
                    1272   1272 ;
                    1273   1273 ; Memon/80 expects the H8-5 to be jumpered the standard way
                    1274   1274 ; (per the H8-5 manual):
                    1275   1275 ;
                    1276   1276 ;  Port Select            Serial Interrupt Select   
                    1277   1277 ;     T-3            (Jumper group labeled "SERIAL INT. S")
                    1278   1278 ;     W-7                        RXR
                    1279   1279 ;     X-2                       S-/I3
                    1280   1280 ;     Y-0                       INT ON
                    1281   1281 ;
                    1282   1282 ; Interrupts must be enabled so that the Heathkit H8's front
                    1283   1283 ; panel will work correctly. The H8-5 must be connected to
                    1284   1284 ; Interrupt level 3 so that other H8 software will work. There
                    1285   1285 ; is no way in software to disable the h8-5's interrupt, so
                    1286   1286 ; Memon/80 must use interrupts for receiving data from the
                    1287   1287 ; H8-5. Memon/80 assumes that either the PAM-8 or the XCON-8
                    1288   1288 ; ROM is installed in the H8 computer and maps the interrupts
                    1289   1289 ; to the standard PAM-8 vector addresses.
                    1290   1290 ;--------------------------------------------------------------
                    1291   1291  if CH85
                    1292   1292 C8251	set	TRUE	;8251 UART
                    1293   1293 CRXINT	set	TRUE	;Interrupt-driven receive (only)
                    1294   1294 CB8251	equ	CBASE	;Base of Console 8251 registers
                    1295   1295  endif ;CH85
                    1296   1296 
                    1297   1297  if TH85
                    1298   1298 TPORT	set	TRUE	;Transfer port is defined
                    1299   1299 T8251	set	TRUE	;8251 UART
                    1300   1300 TRXINT	set	TRUE	;Interrupt-driven receive (only)
                    1301   1301 TB8251	equ	CBASE	;Base of T-port 8251 registers
                    1302   1302  endif ;TH85
                    1303   1303 
                    1304   1304  if CH85 or TH85
                    1305   1305 P8INT3	equ	2025h	;Address of PAM-8/XCON-8 Int 3 vector 
                    1306   1306 
                    1307   1307  endif ;CH85 or TH85
                    1308   1308 
                    1309   1309 ;-----------------------------------------------------
                    1310   1310 ;IMSAI SIO-2 I/O Equates
                    1311   1311 ;
                    1312   1312 ;The SIO-2 is built around a pair of 8251A UARTs
                    1313   1313 ;with a jumper-selectable baud rate generator and
                    1314   1314 ;logic to provide an interrupt-control port.
                    1315   1315 ;The SIO-2 can be jumpered for either memory-mapped
                    1316   1316 ;I/O or port-mapped I/O. this assumes port-mapped I/O.
                    1317   1317 ;-----------------------------------------------------
                    1318   1318  if CISIO2A or CISIO2B
ffff  #             1319   1319 C8251	set	TRUE	;8251 UART
0002  =             1320   1320 CB8251	equ	CBASE	;Base of Console 8251 registers
                    1321   1321  endif ;CISIO2A or CISIO2B
                    1322   1322 
                    1323   1323  if TISIO2A or TISIO2B
ffff  #             1324   1324 TPORT	set	TRUE	;Transfer port is defined
ffff  #             1325   1325 T8251	set	TRUE	;8251 UART
0022  =             1326   1326 TB8251	equ	TBASE	;Base of T-port 8251 registers
                    1327   1327  endif ;TISIO2A or TISIO2B
                    1328   1328 
                    1329   1329  if CISIO2A or TISIO2A
0008  =             1330   1330 SIOCTL	equ	CBASE+6	;SIO-2 int control port
                    1331   1331  endif ;CISIO2A or TISIO2A
                    1332   1332 
                    1333   1333  if CISIO2B and not TISIO2A
                    1334   1334 SIOCTL	equ	CBASE+2	;SIO-2 int control port
                    1335   1335  endif ;CISIO2B and not TISIO2A
                    1336   1336 
                    1337   1337  if TISIO2B and not CISIO2A
                    1338   1338 SIOCTL	equ	TBASE+2	;SIO-2 int control port
                    1339   1339  endif ;TISIO2B and not CISIO2A
                    1340   1340 
                    1341   1341 ;-----------------------------------------------------
                    1342   1342 ;Ithaca Intersystems Series II VIO Serial Port Equates
                    1343   1343 ;
                    1344   1344 ;The two serial ports on the Series II VIO are built
                    1345   1345 ;around Signetics 2651 UARTS, which have internal baud
                    1346   1346 ;rate generators.
                    1347   1347 ;-----------------------------------------------------
                    1348   1348  if CIVIO2 or TIVIO2
                    1349   1349 
                    1350   1350 IVSTOP1	equ	04E00h	;1 stop bit
                    1351   1351 IVSTOP2	equ	0CE00h	;2 stop bits
                    1352   1352 
                    1353   1353 CTL2651	equ	27h	;Ctrl reg initialization value
                    1354   1354  endif ;CIVIO2 or TIVIO2
                    1355   1355 
                    1356   1356  if CIVIO2
                    1357   1357 CDATA	equ	CBASE
                    1358   1358 CSTAT	equ	CBASE+1
                    1359   1359 CMODE	equ	CBASE+1
                    1360   1360 CCTRL	equ	CBASE+3
                    1361   1361 
                    1362   1362 CTXRDY	equ	01h	;Console transmitter ready
                    1363   1363 CRXRDY	equ	02h	;Console receiver ready
                    1364   1364 
                    1365   1365 ;Console Port 2651 baud rates
                    1366   1366 
                    1367   1367 CBD110	equ	IVSTOP2 or 32h	;110 baud (2 stop bits)
                    1368   1368 CBD150	equ	IVSTOP1 or 34h	;150 baud
                    1369   1369 CBD300	equ	IVSTOP1 or 35h	;300 baud
                    1370   1370 CBD600	equ	IVSTOP1 or 36h	;600 baud
                    1371   1371 CBD1200	equ	IVSTOP1 or 37h	;1200 baud
                    1372   1372 CBD2400	equ	IVSTOP1 or 3Ah	;2400 baud
                    1373   1373 CBD4800	equ	IVSTOP1 or 3Ch	;4800 baud
                    1374   1374 CBD9600	equ	IVSTOP1 or 3Eh	;9600 baud
                    1375   1375 CBD192	equ	IVSTOP1 or 3Fh	;19200 baud
                    1376   1376 CBD384	equ	0		;38400 baud (Not supported)
                    1377   1377 CBD576	equ	0 		;57600 baud (not supported)
                    1378   1378 CBD768	equ	0		;76800 baud (Not supported)
                    1379   1379 
                    1380   1380 CSBAUD	set	TRUE	;software Console baud control
                    1381   1381 
                    1382   1382  endif ;CIVIO2
                    1383   1383 
                    1384   1384  if TIVIO2
                    1385   1385 TPORT	set	TRUE	;Transfer port is defined
                    1386   1386 
                    1387   1387 TDATA	equ	TBASE
                    1388   1388 TSTAT	equ	TBASE+1
                    1389   1389 TMODE	equ	TBASE+1
                    1390   1390 TCTRL	equ	TBASE+3
                    1391   1391 
                    1392   1392 BRATE0	equ	TMODE	;Low byte of baud rate goes here
                    1393   1393 BRATE1	equ	TMODE	;High byte of baud rate goes here
                    1394   1394 
                    1395   1395 TTXRDY	equ	01h	;Transfer Port transmitter ready
                    1396   1396 TRXRDY	equ	02h	;Transfer Port receiver ready
                    1397   1397 
                    1398   1398 ;Transfer Port 2651 baud rates
                    1399   1399 ;(The high byte of these words gets written first)
                    1400   1400 
                    1401   1401 TBD110	equ	IVSTOP2 or 32h	;110 baud (2 stop bits)
                    1402   1402 TBD150	equ	IVSTOP1 or 34h	;150 baud
                    1403   1403 TBD300	equ	IVSTOP1 or 35h	;300 baud
                    1404   1404 TBD600	equ	IVSTOP1 or 36h	;600 baud
                    1405   1405 TBD1200	equ	IVSTOP1 or 37h	;1200 baud
                    1406   1406 TBD2400	equ	IVSTOP1 or 3Ah	;2400 baud
                    1407   1407 TBD4800	equ	IVSTOP1 or 3Ch	;4800 baud
                    1408   1408 TBD9600	equ	IVSTOP1 or 3Eh	;9600 baud
                    1409   1409 TBD192	equ	IVSTOP1 or 3Fh	;19200 baud
                    1410   1410 TBD384	equ	0		;38400 baud (Not supported)
                    1411   1411 TBD576	equ	0 		;57600 baud (not supported)
                    1412   1412 TBD768	equ	0		;76800 baud (Not supported)
                    1413   1413 
                    1414   1414 BD192	set	TRUE	;19200 baud supported
                    1415   1415 
                    1416   1416 TSBAUD	set	TRUE	;software transfer port
                    1417   1417 			;..baud rate control
                    1418   1418  endif ;TIVIO2
                    1419   1419 
                    1420   1420 ;-----------------------------------------------------
                    1421   1421 ;Jade Serial/Parallel I/O Port Equates
                    1422   1422 ;
                    1423   1423 ;The serial port of the Jade Serial/Parallel board are
                    1424   1424 ;built around the AY61013A or TR1602B "generic" UART.
                    1425   1425 ;-----------------------------------------------------
                    1426   1426  if CJADSP or TJADSP
                    1427   1427 JRESET	equ	10110000B	;UART reset value
                    1428   1428  endif ;CJADSP or TJADSP
                    1429   1429 
                    1430   1430  if CJADSP
                    1431   1431 CDATA	equ	CBASE
                    1432   1432 CSTAT	equ	CBASE or 80h
                    1433   1433 CCTRL	equ	CBASE or 80h
                    1434   1434 
                    1435   1435 CTXRDY	equ	80h	;Console transmitter ready
                    1436   1436 CRXRDY	equ	10h	;Console receiver ready
                    1437   1437  endif ;CJADSP
                    1438   1438 
                    1439   1439  if TJADSP
                    1440   1440 TPORT	set	TRUE	;Transfer port is defined
                    1441   1441 
                    1442   1442 TDATA	equ	TBASE
                    1443   1443 TSTAT	equ	TBASE or 80h
                    1444   1444 TCTRL	equ	TBASE or 80h
                    1445   1445 
                    1446   1446 TTXRDY	equ	80h	;T-port transmitter ready
                    1447   1447 TRXRDY	equ	10h	;T-port receiver ready
                    1448   1448  endif ;TJADSP
                    1449   1449 
                    1450   1450 ;--------------------------------------------------
                    1451   1451 ;Micromation Doubler Serial Port Equates
                    1452   1452 ;
                    1453   1453 ;The serial port on the Doubler is built around the
                    1454   1454 ;Intel 8251 UART, with jumper-selectable baud rates.
                    1455   1455 ;This UART is accessed via memory accesses, rather
                    1456   1456 ;than the usual I/O accesses.
                    1457   1457 ;---------------------------------------------------
                    1458   1458  if CMDUBLR
                    1459   1459 C8251	set	TRUE	;8251 UART
                    1460   1460 CMEMAP	set	TRUE	;memory-mapped I/O
                    1461   1461 
                    1462   1462 CDATA	equ	CBASE+0602h	;Console data port
                    1463   1463 CSTAT	equ	CBASE+060Ah	;Console status port
                    1464   1464 CCTRL	equ	CBASE+060Ah	;Console control port
                    1465   1465 
                    1466   1466 CTXRDY	  equ	  01h	;Console transmitter ready
                    1467   1467 CRXRDY	  equ	  02h	;Console receiver ready
                    1468   1468 
                    1469   1469  endif ;CMDUBLR
                    1470   1470 
                    1471   1471  if TMDUBLR
                    1472   1472 TPORT	set	TRUE	;Transfer port is defined
                    1473   1473 T8251	set	TRUE	;8251 UART
                    1474   1474 TMEMAP	set	TRUE	;memory-mapped I/O
                    1475   1475 
                    1476   1476 TDATA	equ	TBASE+0602h	;Transfer data port
                    1477   1477 TSTAT	equ	TBASE+060Ah	;Transfer status port
                    1478   1478 TCTRL	equ	TBASE+060Ah	;Transfer control port
                    1479   1479 
                    1480   1480 TTXRDY	  equ	  01h	;Transfer transmitter ready
                    1481   1481 TRXRDY	  equ	  02h	;Transfer receiver ready
                    1482   1482 
                    1483   1483  endif ;TMDUBLR
                    1484   1484 
                    1485   1485 ;--------------------------------------------------
                    1486   1486 ;Tarbell 4044 4P2S Serial Port Equates
                    1487   1487 ;
                    1488   1488 ;The Tarbell 4044 is built around four Intel 8251A
                    1489   1489 ;UARTs, with switch-selectable baud rates.
                    1490   1490 ;--------------------------------------------------
                    1491   1491  if CTARBL
                    1492   1492 C8251	set	TRUE	;8251 UART
                    1493   1493 CB8251	equ	CBASE	;Base of Console 8251 registers
                    1494   1494  endif ;CTARBL
                    1495   1495 
                    1496   1496  if TTARBL
                    1497   1497 TPORT	set	TRUE	;Transfer port is defined
                    1498   1498 
                    1499   1499 T8251	set	TRUE	;8251 UART
                    1500   1500 TB8251	equ	TBASE	;Base of T-port 8251 registers
                    1501   1501  endif ;TTARBL
                    1502   1502 
                    1503   1503 ;------------------------------------------------------
                    1504   1504 ;Salota I/O 2+1 Serial Port Equates
                    1505   1505 ;
                    1506   1506 ;The Salota I/O 2+1's serial ports are built around two
                    1507   1507 ;Intel 8251A UARTs, with jumper-selectable baud rates.
                    1508   1508 ;------------------------------------------------------
                    1509   1509  if CSAL21
                    1510   1510 C8251	set	TRUE	;8251 UART
                    1511   1511 CB8251	equ	CBASE	;Base of Console 8251 registers
                    1512   1512  endif ;CSAL21
                    1513   1513 
                    1514   1514  if TSAL21
                    1515   1515 TPORT	set	TRUE	;Transfer port is defined
                    1516   1516 
                    1517   1517 T8251	set	TRUE	;8251 UART
                    1518   1518 TB8251	equ	TBASE	;Base of T-port 8251 registers
                    1519   1519  endif ;TSAL21
                    1520   1520 
                    1521   1521 ;--------------------------------------------------
                    1522   1522 ;SOlid State Music IO5 Serial Port Equates
                    1523   1523 ;
                    1524   1524 ;The IO5's serial ports are built around two Intel
                    1525   1525 ;8251A UARTs, with switch-selectable baud rates.
                    1526   1526 ;--------------------------------------------------
                    1527   1527  if CSIO5
                    1528   1528 C8251	set	TRUE	;8251 UART
                    1529   1529 CB8251	equ	CBASE	;Base of Console 8251 registers
                    1530   1530  endif ;CSIO5
                    1531   1531 
                    1532   1532  if TSIO5
                    1533   1533 TPORT	set	TRUE	;Transfer port is defined
                    1534   1534 
                    1535   1535 T8251	set	TRUE	;8251 UART
                    1536   1536 TB8251	equ	TBASE	;Base of T-port 8251 registers
                    1537   1537  endif ;TSIO5
                    1538   1538 
                    1539   1539 ;---------------------------------------------------
                    1540   1540 ;Processor Technology 3P+S Serial Port Equates
                    1541   1541 ;
                    1542   1542 ;The 3P+S is built around a TMS6011 or AMI S1883
                    1543   1543 ;UART, with a jumper selectable baud rate generator.
                    1544   1544 ;This board has many jumpers on it, allowing you to
                    1545   1545 ;set up the bits within the control port any way you
                    1546   1546 ;like. Memon/80 assumes it is set up the way that
                    1547   1547 ;Processor Technology'S CUTER expects it to be.
                    1548   1548 ;---------------------------------------------------
                    1549   1549  if CPT3PS
                    1550   1550 CSTAT	equ	CBASE	;Console status
                    1551   1551 CCTRL	equ	CBASE	;Console control
                    1552   1552 CDATA	equ	CBASE+1	;Console data
                    1553   1553 
                    1554   1554 CTXRDY	  equ	  80h	;transmitter buffer empty
                    1555   1555 CRXRDY	  equ	  40h	;receive data available
                    1556   1556 
                    1557   1557  endif ;CPT3PS
                    1558   1558 
                    1559   1559  if TPT3PS
                    1560   1560 TPORT	set	TRUE	;Transfer port is defined
                    1561   1561 
                    1562   1562 TSTAT	equ	TBASE	;Transfer Port status
                    1563   1563 TCTRL	equ	TBASE	;Transfer Port control
                    1564   1564 TDATA	equ	TBASE+1	;Transfer Port data
                    1565   1565 
                    1566   1566 TTXRDY	  equ	  80h	;transmitter buffer empty
                    1567   1567 TRXRDY	  equ	  40h	;receive data available
                    1568   1568  endif ;TPT3PS
                    1569   1569 
                    1570   1570 ;-----------------------------------------------
                    1571   1571 ;Vector Graphic BitStreamer Equates
                    1572   1572 ;
                    1573   1573 ;The BitStreamer is built around an 8251 UART,
                    1574   1574 ;with a jumper selectable baud rate generator.
                    1575   1575 ;-----------------------------------------------
                    1576   1576  if CBITS1
                    1577   1577 C8251	set	TRUE	;8251 UART
                    1578   1578 CB8251	equ	CBASE	;Base of Console 8251 registers
                    1579   1579  endif ;CBITS1
                    1580   1580 
                    1581   1581  if TBITS1
                    1582   1582 TPORT	set	TRUE	;Transfer port is defined
                    1583   1583 
                    1584   1584 T8251	set	TRUE	;8251 UART
                    1585   1585 TB8251	equ	TBASE	;Base of T-port 8251 registers
                    1586   1586  endif ;TBITS1
                    1587   1587 
                    1588   1588 ;---------------------------------------------------
                    1589   1589 ;Vector Graphic BitStreamer II Equates
                    1590   1590 ;
                    1591   1591 ;The BitStreamer II is built around three 8251A
                    1592   1592 ;UARTs with a jumper-selectable baud rate generator.
                    1593   1593 ;---------------------------------------------------
                    1594   1594  if CBITS2
                    1595   1595 C8251	set	TRUE	;8251 UART
                    1596   1596 CB8251	equ	CBASE	;Base of Console 8251 registers
                    1597   1597  endif ;CBITS2
                    1598   1598 
                    1599   1599  if TBITS2
                    1600   1600 TPORT	set	TRUE	;Transfer port is defined
                    1601   1601 
                    1602   1602 T8251	set	TRUE	;8251 UART
                    1603   1603 TB8251	equ	TBASE	;Base of T-port 8251 registers
                    1604   1604  endif ;TBITS2
                    1605   1605 
                    1606   1606 ;-------------------------------------------------------
                    1607   1607 ;Wameco IOB-1 Equates
                    1608   1608 ;
                    1609   1609 ;The serial port of the Wameco IOB-1 is built around
                    1610   1610 ;the Intel 8251 UART with a switch-selectable baud rate.
                    1611   1611 ;-------------------------------------------------------
                    1612   1612  if CWIOB1
                    1613   1613 C8251	set	TRUE	;8251 UART
                    1614   1614 CB8251	equ	CBASE	;Base of Console 8251 registers
                    1615   1615  endif ;CWIOB1
                    1616   1616 
                    1617   1617  if TWIOB1
                    1618   1618 TPORT	set	TRUE	;Transfer port is defined
                    1619   1619 
                    1620   1620 T8251	set	TRUE	;8251 UART
                    1621   1621 TB8251	equ	TBASE	;Base of T-port 8251 registers
                    1622   1622  endif ;TWIOB1
                    1623   1623 
                    1624   1624 ;---------------------------
                    1625   1625 ;General MC6850 ACIA Equates
                    1626   1626 ;---------------------------
                    1627   1627  if C6850 or T6850
                    1628   1628 ;MOTOROLA 6850 ACIA control/status values
                    1629   1629 U68RES	equ	00000011B	;master reset
                    1630   1630 U68ST2	equ	00010001B	;2 stop bits, /16
                    1631   1631 U68ST1	equ	00010101B	;1 stop bit, /16
                    1632   1632  endif ;C6850 or T6850
                    1633   1633 
                    1634   1634 ; MC6850 as the Console Port
                    1635   1635 
                    1636   1636  if C6850
                    1637   1637 CCTRL	equ	CB6850		;ACIA 0 control output port
                    1638   1638 CSTAT	equ	CB6850		;ACIA 0 status input port
                    1639   1639 CDATA	equ	CB6850+1	;ACIA 0 Rx & Tx data regs
                    1640   1640 
                    1641   1641 CRXRDY	equ	00000001B	;Console Rx data reg full
                    1642   1642 CTXRDY	equ	00000010B	;Console Tx data reg empty
                    1643   1643  endif ;C6850
                    1644   1644 
                    1645   1645 ;MC6850 as the Transfer Port
                    1646   1646 
                    1647   1647  if T6850
                    1648   1648 TCTRL	equ	TB6850		;ACIA 1 control output port
                    1649   1649 TSTAT	equ	TB6850		;ACIA 1 status input port
                    1650   1650 TDATA	equ	TB6850+1	;ACIA 1 Rx & Tx data regs
                    1651   1651 
                    1652   1652 TRXRDY	equ	00000001B	;Transfer Port Rx data reg full
                    1653   1653 TTXRDY	equ	00000010B	;Tr. Port Tx data reg empty
                    1654   1654  endif ;T6850
                    1655   1655 
                    1656   1656 ;----------------------------
                    1657   1657 ;General INS8250 UART Equates
                    1658   1658 ;----------------------------
                    1659   1659 
                    1660   1660 ;INS8250 UART as the Console Port
                    1661   1661 
                    1662   1662  if C8250
                    1663   1663 
                    1664   1664 CRXRDY	equ	00000001b	;Rx data ready
                    1665   1665 CTXRDY	equ	00100000b	;Tx buffer empty
                    1666   1666 CDLAB	equ	80h		;Baud rate access
                    1667   1667 
                    1668   1668 CSBAUD	set	TRUE	;software Console
                    1669   1669 			;..baud rate control
                    1670   1670 ;Console Port baud rates
                    1671   1671 
                    1672   1672 CBD110	equ	1047	;0= 110 baud (2 stop bits)
                    1673   1673 CBD150	equ	768	;1= 150 baud
                    1674   1674 CBD300	equ	384	;2= 300 baud
                    1675   1675 CBD600	equ	192	;3= 600 baud
                    1676   1676 CBD1200	equ	96	;4= 1200 baud
                    1677   1677 CBD2400	equ	48	;5= 2400 baud
                    1678   1678 CBD4800	equ	24	;6= 4800 baud
                    1679   1679 CBD9600	equ	12	;7= 9600 baud
                    1680   1680 CBD192	equ	6	;8= 19200 baud
                    1681   1681 CBD384	equ	3	;9= 38400 baud
                    1682   1682 CBD576	equ	0	;a= 57600 baud (not supported)
                    1683   1683 CBD768	equ	0	;b= 76800 baud (not supported)
                    1684   1684 
                    1685   1685 CSTOP1	equ	03h	;1 stop bit
                    1686   1686 CSTOP2	equ	07h	;2 stop bits
                    1687   1687 
                    1688   1688 CDATA	equ	CB8250	;data port
                    1689   1689 CSINTEN	equ	CDATA+1	;interrupt enable port
                    1690   1690 CSIDENT	equ	CDATA+2	;interrupt ID port
                    1691   1691 CSLCTRL	equ	CDATA+3	;line control port
                    1692   1692 CSMDMCT	equ	CDATA+4	;modem control port
                    1693   1693 CSTAT	equ	CDATA+5	;line status port
                    1694   1694 CMSTAT	equ	CDATA+6	;modem status port
                    1695   1695 
                    1696   1696 CSTOPS	set	CSTOP2
                    1697   1697  endif ;C8250
                    1698   1698 
                    1699   1699  if C8250 and ((0-CBAUD) SHR 15)
                    1700   1700 CSTOPS	set	CSTOP1
                    1701   1701  endif ;CC8250 and ((0-CBAUD) SHR 15)
                    1702   1702 
                    1703   1703 ;INS8250 UART as the Transfer Port
                    1704   1704 
                    1705   1705  if T8250
                    1706   1706 
                    1707   1707 TRXRDY	equ	00000001b	;Rx data ready
                    1708   1708 TTXRDY	equ	00100000b	;Tx buffer empty
                    1709   1709 TDLAB	equ	80h		;Baud rate access
                    1710   1710 
                    1711   1711 TPORT	set	TRUE	;Transfer port is defined
                    1712   1712 
                    1713   1713 TSBAUD	set	TRUE	;software Transfer Port
                    1714   1714 			;..baud rate control
                    1715   1715 
                    1716   1716 ;Transfer Port baud rates
                    1717   1717 
                    1718   1718 TBD110	equ	1047	;0= 110 baud (2 stop bits)
                    1719   1719 TBD150	equ	768	;1= 150 baud
                    1720   1720 TBD300	equ	384	;2= 300 baud
                    1721   1721 TBD600	equ	192	;3= 600 baud
                    1722   1722 TBD1200	equ	96	;4= 1200 baud
                    1723   1723 TBD2400	equ	48	;5= 2400 baud
                    1724   1724 TBD4800	equ	24	;6= 4800 baud
                    1725   1725 TBD9600	equ	12	;7= 9600 baud
                    1726   1726 TBD192	equ	6	;8= 19200 baud
                    1727   1727 TBD384	equ	3	;9= 38400 baud
                    1728   1728 TBD576	equ	0	;a= 57600 baud (not supported)
                    1729   1729 TBD768	equ	0	;b= 76800 baud (not supported)
                    1730   1730 
                    1731   1731 BD192	set	TRUE	;19200 baud supported
                    1732   1732 BD384	set	TRUE	;38400 baud supported
                    1733   1733 TSTOP1	equ	03h	;1 stop bit
                    1734   1734 TSTOP2	equ	07h	;2 stop bits
                    1735   1735 
                    1736   1736 TDATA	equ	TB8250	;data port
                    1737   1737 TSINTEN	equ	TDATA+1	;interrupt enable port
                    1738   1738 TSIDENT	equ	TDATA+2	;interrupt ID port
                    1739   1739 TSLCTRL	equ	TDATA+3	;line control port
                    1740   1740 TSMDMCT	equ	TDATA+4	;modem control port
                    1741   1741 TSTAT	equ	TDATA+5	;line status port
                    1742   1742 TMSTAT	equ	TDATA+6	;modem status port
                    1743   1743 
                    1744   1744 BRATE0	equ	TDATA	;Baud rate divisor low byte
                    1745   1745 BRATE1	equ	TSINTEN	;Baud rate divisor high byte
                    1746   1746 
                    1747   1747 TSTOPS	set	TSTOP2
                    1748   1748  endif ;T8250
                    1749   1749 
                    1750   1750  if T8250 and ((0-TBAUD) SHR 15)
                    1751   1751 TSTOPS	set	TSTOP1
                    1752   1752  endif ;T8250 and ((0-TBAUD) SHR 15)
                    1753   1753 
                    1754   1754 ;-------------------------------
                    1755   1755 ;General 8251/8251A UART Equates
                    1756   1756 ;-------------------------------
                    1757   1757 
                    1758   1758 ;Port Relative Addresses and Ready Bits for I/O-mapped 8251s
                    1759   1759 
                    1760   1760  if C8251 and (not CMEMAP)
0002  =             1761   1761 CDATA	equ	CB8251		;Console data
0003  =             1762   1762 CSTAT	equ	CB8251+1	;Console status
0003  =             1763   1763 CCTRL	equ	CB8251+1	;Console control
                    1764   1764 
0001  =             1765   1765 CTXRDY	  equ	  01h	  ;Console transmitter ready
0002  =             1766   1766 CRXRDY	  equ	  02h	  ;receiver ready
0004  =             1767   1767 CTXMTY	  equ	  04h	  ;Console Transmitter empty
                    1768   1768  endif ;C8251 and (not CMEMAP)
                    1769   1769 
                    1770   1770  if T8251 and (not TMEMAP)
0022  =             1771   1771 TDATA	equ	TB8251		;Transfer port data
0023  =             1772   1772 TSTAT	equ	TB8251+1	;Transfer port status
0023  =             1773   1773 TCTRL	equ	TB8251+1	;Transfer port control
                    1774   1774 
0001  =             1775   1775 TTXRDY	  equ	  01h	  ;Transfer port transmitter ready
0002  =             1776   1776 TRXRDY	  equ	  02h	  ;Transfer port receiver ready
0004  =             1777   1777 TTXMTY	  equ	  04h	  ;Transfer port Transmitter empty
                    1778   1778  endif ;T8251 and (not TMEMAP)
                    1779   1779 
                    1780   1780 ;initialization values for all 8251s
                    1781   1781 
                    1782   1782  if C8251 or T8251
004e  =             1783   1783 UMOD16	  equ	  4Eh	  ;8 bits, 1 stop, no parity, X16
0040  =             1784   1784 UCMDRE	  equ	  40h	  ;reset UART
0037  =             1785   1785 UCMDEN	  equ	  37h	  ;enable Tx & Rx, DTR, RTS ON
0036  =             1786   1786 UCMDEI	  equ	  36h	  ;enable Rx, disable Tx
                    1787   1787 
                    1788   1788 ;8251 reset sequence
                    1789   1789 ;note: code assumes UCMDEN is UNIQUE here
                    1790   1790 
00aa  =             1791   1791 SI21	equ	0AAh	;Fake SYNC chr
0040  =             1792   1792 SI22	equ	UCMDRE	;reset command
004e  =             1793   1793 SI23	equ	UMOD16	;Clock divisor, etc.
0037  =             1794   1794 SI24	equ	UCMDEN	;enable Rx & Tx
                    1795   1795  endif ;C8251 or T8251
                    1796   1796 
                    1797   1797 ;---------------------------
                    1798   1798 ;Compute Baud Rate Constants
                    1799   1799 ;---------------------------
                    1800   1800  if CSBAUD
                    1801   1801 CPBAUD	set	CBD110
                    1802   1802  endif ;CSBAUD
                    1803   1803 
                    1804   1804  if CSBAUD and ((0-CBAUD)SHR 15)
                    1805   1805 CPBAUD	set	CBD150
                    1806   1806  endif ;CSBAUD and ((0-CBAUD)SHR 15)
                    1807   1807 
                    1808   1808  if CSBAUD and ((1-CBAUD)SHR 15)
                    1809   1809 CPBAUD	set	CBD300
                    1810   1810  endif ;CSBAUD and ((1-CBAUD)SHR 15)
                    1811   1811 
                    1812   1812  if CSBAUD and ((2-CBAUD)SHR 15)
                    1813   1813 CPBAUD	set	CBD600
                    1814   1814  endif ;CSBAUD and ((2-CBAUD)SHR 15)
                    1815   1815 
                    1816   1816  if CSBAUD and ((3-CBAUD)SHR 15)
                    1817   1817 CPBAUD	set	CBD1200
                    1818   1818  endif ;CSBAUD and ((3-CBAUD)SHR 15)
                    1819   1819 
                    1820   1820  if CSBAUD and ((4-CBAUD)SHR 15)
                    1821   1821 CPBAUD	set	CBD2400
                    1822   1822  endif ;CSBAUD and ((4-CBAUD)SHR 15)
                    1823   1823 
                    1824   1824  if CSBAUD and ((5-CBAUD)SHR 15)
                    1825   1825 CPBAUD	set	CBD4800
                    1826   1826  endif ;CSBAUD and ((5-CBAUD)SHR 15)
                    1827   1827 
                    1828   1828  if CSBAUD and ((6-CBAUD)SHR 15)
                    1829   1829 CPBAUD	set	CBD9600
                    1830   1830  endif ;CSBAUD and ((6-CBAUD)SHR 15)
                    1831   1831 
                    1832   1832  if CSBAUD and ((7-CBAUD)SHR 15)
                    1833   1833 CPBAUD	set	CBD192
                    1834   1834  endif ;CSBAUD and ((7-CBAUD)SHR 15)
                    1835   1835 
                    1836   1836  if CSBAUD and ((8-CBAUD)SHR 15)
                    1837   1837 CPBAUD	set	CBD384
                    1838   1838  endif ;CSBAUD and ((8-CBAUD)SHR 15)
                    1839   1839 
                    1840   1840  if CSBAUD and ((9-CBAUD)SHR 15)
                    1841   1841 CPBAUD	set	CBD576
                    1842   1842  endif ;CSBAUD and ((9-CBAUD)SHR 15)
                    1843   1843 
                    1844   1844  if CSBAUD and ((0Ah-CBAUD)SHR 15)
                    1845   1845 CPBAUD	set	CBD768
                    1846   1846  endif ;CSBAUD and ((0Ah-CBAUD)SHR 15)
                    1847   1847 
                    1848   1848  if TSBAUD
                    1849   1849 TPBAUD	set	TBD110
                    1850   1850  endif ;TSBAUD
                    1851   1851 
                    1852   1852  if TSBAUD and ((0-TBAUD)SHR 15)
                    1853   1853 TPBAUD	set	TBD150
                    1854   1854  endif ;TSBAUD and ((0-TBAUD)SHR 15)
                    1855   1855 
                    1856   1856  if TSBAUD and ((1-TBAUD)SHR 15)
                    1857   1857 TPBAUD	set	TBD300
                    1858   1858  endif ;TSBAUD and ((1-TBAUD)SHR 15)
                    1859   1859 
                    1860   1860  if TSBAUD and ((2-TBAUD)SHR 15)
                    1861   1861 TPBAUD	set	TBD600
                    1862   1862  endif ;TSBAUD and ((2-TBAUD)SHR 15)
                    1863   1863 
                    1864   1864  if TSBAUD and ((3-TBAUD)SHR 15)
                    1865   1865 TPBAUD	set	TBD1200
                    1866   1866  endif ;TSBAUD and ((3-TBAUD)SHR 15)
                    1867   1867 
                    1868   1868  if TSBAUD and ((4-TBAUD)SHR 15)
                    1869   1869 TPBAUD	set	TBD2400
                    1870   1870  endif ;TSBAUD and ((4-TBAUD)SHR 15)
                    1871   1871 
                    1872   1872  if TSBAUD and ((5-TBAUD)SHR 15)
                    1873   1873 TPBAUD	set	TBD4800
                    1874   1874  endif ;TSBAUD and ((5-TBAUD)SHR 15)
                    1875   1875 
                    1876   1876  if TSBAUD and ((6-TBAUD)SHR 15)
                    1877   1877 TPBAUD	set	TBD9600
                    1878   1878  endif ;TSBAUD and ((6-TBAUD)SHR 15)
                    1879   1879 
                    1880   1880  if TSBAUD and ((7-TBAUD)SHR 15)
                    1881   1881 TPBAUD	set	TBD192
                    1882   1882  endif ;TSBAUD and ((7-TBAUD)SHR 15)
                    1883   1883 
                    1884   1884  if TSBAUD and ((8-TBAUD)SHR 15)
                    1885   1885 TPBAUD	set	TBD384
                    1886   1886  endif ;TSBAUD and ((8-TBAUD)SHR 15)
                    1887   1887 
                    1888   1888  if TSBAUD and ((9-TBAUD)SHR 15)
                    1889   1889 TPBAUD	set	TBD576
                    1890   1890  endif ;TSBAUD and ((9-TBAUD)SHR 15)
                    1891   1891 
                    1892   1892  if TSBAUD and ((0Ah-TBAUD)SHR 15)
                    1893   1893 TPBAUD	set	TBD768
                    1894   1894  endif ;TSBAUD and ((0Ah-TBAUD)SHR 15)
                    1895   1895 
                    1896   1896 ;******************************************************
                    1897   1897 ;Compute Memon80's RAM beginning for the banner message
                    1898   1898 ;******************************************************
                    1899   1899 
                    1900   1900  if not (TRXINT or CRXINT)
008f  =             1901   1901 RAMBEG	equ	STACK-STKSIZ-1
                    1902   1902  endif ;not (TRXINT or CRXINT)
                    1903   1903 
                    1904   1904 
                    1905   1905  if TRXINT or CRXINT
                    1906   1906 RAMBEG	equ	TRXBUF
                    1907   1907  endif ;TRXINT or CRXINT
                    1908   1908 
                    1909   1909 ;***************************
                    1910   1910 ;Disk Controller Definitions
                    1911   1911 ;***************************
                    1912   1912 ;Initialize some assembler vasriables
0000  #             1913   1913 BOOTER	set	FALSE		;Assume no BO command for now
0000  #             1914   1914 JMPBOT	set	FALSE
0000  #             1915   1915 WD179X	set	FALSE
                    1916   1916 
                    1917   1917 ;-----------------------------------------------------------
                    1918   1918 ;Altair 8800 Floppy Disk controller Equates (These are the
                    1919   1919 ;same for the 88-DCDD controller and the 88-MDS controller.)
                    1920   1920 ;-----------------------------------------------------------
                    1921   1921  if A88DCD or A88MCD
                    1922   1922 BOOTER	set	TRUE		;Boot command exists
                    1923   1923 
                    1924   1924 DENABL	equ	DIBASE		;Drive enable output
                    1925   1925 DDISBL	  equ	  80h		  ;disable disk controller
                    1926   1926 
                    1927   1927 DSTAT	equ	DIBASE		;status input (active low)
                    1928   1928 ENWDAT	  equ	  01h		  ;-enter write data
                    1929   1929 MVHEAD	  equ	  02h		  ;-Move Head OK
                    1930   1930 HDSTAT	  equ	  04h		  ;-Head status
                    1931   1931 DRVRDY	  equ	  08h		  ;-Drive Ready
                    1932   1932 INTSTA	  equ	  20h		  ;-interrupts enabled
                    1933   1933 TRACK0	  equ	  40h		  ;-Track 0 detected
                    1934   1934 NRDA	  equ	  80h		  ;-new Read data Available
                    1935   1935 
                    1936   1936 DCTRL	equ	DIBASE+1	;Drive control output
                    1937   1937 STEPIN	  equ	  01h		  ;Step-In
                    1938   1938 STEPOT	  equ	  02h		  ;Step-Out
                    1939   1939 HEDLOD	  equ	  04h		  ;8" disk: load head
                    1940   1940 				  ;Minidisk: restart
                    1941   1941 				  ;..6.4 S timer
                    1942   1942 HDUNLD	  equ	  08h		  ;unload head (8" only)
                    1943   1943 IENABL	  equ	  10h		  ;enable sector interrupt
                    1944   1944 IDSABL	  equ	  20h		  ;Disable interrupts
                    1945   1945 WENABL	  equ	  80h		  ;enable drive write circuits
                    1946   1946 
                    1947   1947 DSECTR	equ	DIBASE+1	;Sector position input
                    1948   1948 SVALID	  equ	  01h		  ;Sector valid (1st 30 uS
                    1949   1949 				  ;..of sector pulse)
                    1950   1950 SECMSK	  equ	  3Eh		  ;Sector mask for MDSEC
                    1951   1951 
                    1952   1952 DDATA	equ	DIBASE+2	;Disk data (input/output)
                    1953   1953 
                    1954   1954 ;Floppy Disk Parameters
                    1955   1955 
                    1956   1956 BPS	equ	128		;data bytes/sector
                    1957   1957 MDSPT	equ	16		;Minidisk sectors/track
                    1958   1958 				;this code assumes SPT for 8"
                    1959   1959 				;disks=MDSPT * 2.
                    1960   1960 
                    1961   1961 HDRSIZ	equ	3		;header bytes before data
                    1962   1962 TLRSIZ	equ	2		;trailer bytes read after data
                    1963   1963 
                    1964   1964 SECSIZ	equ	BPS+HDRSIZ+TLRSIZ ;total bytes/sector
                    1965   1965 
                    1966   1966 MAXTRYS	equ	16		;max retries per sector
                    1967   1967 
                    1968   1968 ;sector buffer component offsets
                    1969   1969 SFSIZE	equ	RAMBUF+1	;file size
                    1970   1970 SDATA	equ	RAMBUF+HDRSIZ	;sector data
                    1971   1971 SMARKR	equ	SDATA+BPS	;marker byte
                    1972   1972 SCKSUM	equ	SMARKR+1	;checksum byte
                    1973   1973  endif ;A88DCD or A88MCD
                    1974   1974 
                    1975   1975 ;------------------------
                    1976   1976 ;CCS 2422 Disk controller
                    1977   1977 ;------------------------
                    1978   1978  if CC2422
                    1979   1979 
                    1980   1980 BOOTER	set	TRUE		;Boot command exists
                    1981   1981 WD179X	set	TRUE		;WD1793-type controller
                    1982   1982 
                    1983   1983 MAXTRYS	equ	16		;max retries
                    1984   1984 SECSIZ	equ	128		;bytes/sector
                    1985   1985 BOTDSK	equ	0		;Boot disk
                    1986   1986 BOTSEC	equ	1		;Boot sector
                    1987   1987 BOTADR	equ	80h		;Load & Run boot sector here
                    1988   1988 				;Code assumes xx80h
                    1989   1989 
                    1990   1990 ;CCS 2422 floppy disk controller addresses
                    1991   1991 
                    1992   1992 BCTRL	equ	4		;Control port 2
                    1993   1993 BSTAT	equ	4		;status port 2
                    1994   1994 DSTAT	equ	30h		;disk status port
                    1995   1995 DCMMD	equ	DSTAT		;disk command port
                    1996   1996 DTRCK	equ	DSTAT+1		;track port
                    1997   1997 DSCTR	equ	DSTAT+2		;sector port
                    1998   1998 DDATA	equ	DSTAT+3		;data port
                    1999   1999 DFLAG	equ	DSTAT+4		;disk flag port
                    2000   2000 DCTRL	equ	DSTAT+4		;disk control port
                    2001   2001 
                    2002   2002 ;Control register 1 (DCTRL) output bits
                    2003   2003 
                    2004   2004 DCDS1	equ	00000001b	;drive select 1
                    2005   2005 DCDS2	equ	00000010b	;drive select 2
                    2006   2006 DCDS3	equ	00000100b	;drive select 3
                    2007   2007 DCDS4	equ	00001000b	;drive select 4
                    2008   2008 DCMAXI	equ	00010000b	;0=Minidisk, 1=8" disk
                    2009   2009 DCMDMO	equ	00100000b	;Minidisk motor on
                    2010   2010 DCDDEN	equ	01000000b	;double density enable
                    2011   2011 DCAUTOW	equ	10000000b	;autowait
                    2012   2012 
                    2013   2013 ;Control register 2 (BCTRL) output bits
                    2014   2014 
                    2015   2015 BCEJECT	equ	00000100b	;remote eject control (PerSci)
                    2016   2016 BCFSEEK	equ	00010000b	;fast seek: voicecoil drives
                    2017   2017 BCSIDE0	equ	01000000b	;0=side 1, 1=side 0
                    2018   2018 BCROMEN	equ	10000000b	;enable onboard ROM
                    2019   2019 
                    2020   2020 ;Composite BCTRL values used to select disk side
                    2021   2021 ; Note: ROM is actually disabled via the page register
                    2022   2022 ; Note: fast seek disabled via hardware jumper
                    2023   2023 
                    2024   2024 SIDE0	equ	BCROMEN+BCFSEEK+BCSIDE0
                    2025   2025 SIDE1	equ	BCROMEN+BCFSEEK
                    2026   2026 
                    2027   2027 ;Status register 1 (DFLAG) input bits
                    2028   2028 
                    2029   2029 DFINTRQ	equ	00000001b	;WD1793 INTRQ signal,
                    2030   2030 				;active high
                    2031   2031 DFDS1	equ	00000010b	;DS1 in control reg 1
                    2032   2032 DFDS2	equ	00000100b	;DS2 in control reg 1
                    2033   2033 DFDS3	equ	00001000b	;DS3 in control reg 1
                    2034   2034 DFDS4	equ	00010000b	;DS4 in control reg 1
                    2035   2035 DFSHLD	equ	00100000b	;WD1793 HLD signal, active high
                    2036   2036 DFAUTOB	equ	01000000b	;autoboot jumper, 0=autoboot
                    2037   2037 DFSDRQ	equ	10000000b	;WD1793 DRQ signal, 1=ready
                    2038   2038 
                    2039   2039 ;Status reg 2 (BSTAT) input bits
                    2040   2040 
                    2041   2041 BTRK0	equ	00000001b	;when on track 0: 1=8" disk
                    2042   2042 BMINI	equ	00000010b	;-DCTRL reg bit: 1=Minidisk
                    2043   2043 BWPRT	equ	00000100b	;0=disk is write-protected
                    2044   2044 BSIDE0	equ	00001000b	;SIDE0 bit in control reg 2
                    2045   2045 BINDEX	equ	00010000b	;index signal, active low
                    2046   2046 BDDEN	equ	00100000b	;DDEN signal in ctrl register 1
                    2047   2047 BSIDED	equ	01000000b	;0=selected disk is 2-sided
                    2048   2048 
                    2049   2049  endif ;CC2422
                    2050   2050 
                    2051   2051 ;---------------------------------
                    2052   2052 ;Cromemco 4FDC/16FDC/64FDC Equates
                    2053   2053 ;---------------------------------
                    2054   2054  if C4FDC or C16FDC or C64FDC
                    2055   2055 
                    2056   2056 BOOTER	set	TRUE		;Boot command exists
                    2057   2057 WD179X	set	TRUE		;WD1793-type controller
                    2058   2058 
                    2059   2059 MAXDRV	equ	3		;drives 0-3 allowed
                    2060   2060 BOTADR	equ	0080h		;boot and run address
                    2061   2061 				;(code assumes xx80h)
                    2062   2062 BOTSEC	equ	1		;boot sector
                    2063   2063 MAXTRYS	equ	10		;boot retries
                    2064   2064 
                    2065   2065 ;16FDC Ports & Bits
                    2066   2066 
                    2067   2067 ASTAT	equ	04h		;Aux stat input
                    2068   2068 ACTRL	equ	04h		;Auxiliary cmd output
                    2069   2069 DSTAT	equ	30h		;Status input
                    2070   2070 DCMMD	equ	30h		;cmd output
                    2071   2071 DTRCK	equ	31h		;Track I/O
                    2072   2072 DSCTR	equ	32h		;Sector I/O
                    2073   2073 DDATA	equ	33h		;Data I/O
                    2074   2074 DFLAG	equ	34h		;Flags input
                    2075   2075 DCTRL	equ	34h		;Control output
                    2076   2076 
                    2077   2077 ;DCTRL output bits
                    2078   2078 
                    2079   2079 DCDS0	equ	00000001B ;Drive Select 0
                    2080   2080 DCDS1	equ	00000010B ;Drive Select 1
                    2081   2081 DCDS2	equ	00000100B ;Drive Select 2
                    2082   2082 DCDS3	equ	00001000B ;Drive Select 3
                    2083   2083 DCSMSK	equ	11110000B ;Drive Select mask
                    2084   2084 DCMAXI	equ	00010000B ;0=Mini, 1=Maxi
                    2085   2085 DCMOTO	equ	00100000B ;Motor On
                    2086   2086 DCMMSK	equ	11011111B ;Motor mask
                    2087   2087 DCDDEN	equ	01000000B ;Enable Double Density
                    2088   2088 DCAUTO	equ	10000000B ;Enable auto-wait
                    2089   2089 
                    2090   2090 ;ACTRL output bits (These are active-low)
                    2091   2091 
                    2092   2092 ACSID0	 equ	00000010B ;-Side select
                    2093   2093 ACCTRL	 equ	00000100B ;-Control Out
                    2094   2094 ACRSTR	 equ	00001000B ;-Restore
                    2095   2095 ACFSEK	 equ	00010000B ;-Fast Seek
                    2096   2096 ACDSO	 equ	00100000B ;-Drive Select Override
                    2097   2097 ACEJCT	 equ	01000000B ;-EJECT
                    2098   2098 
                    2099   2099 ;DFLAG input bits
                    2100   2100 
                    2101   2101 DFSEOJ  equ	00000001B ;Disk cmd complete
                    2102   2102 DFAWTO	equ	00000010B ;Auto-wait timeout
                    2103   2103 DFSMTO	equ	00000100B ;Motor timeout
                    2104   2104 DFSMON	equ	00001000B ;1793 is requesting motors on
                    2105   2105 DSFhLD	equ	00100000B ;1793 is requesting head load
                    2106   2106 DSFDRQ	equ	10000000B ;1793 is requesting data
                    2107   2107 
                    2108   2108 ;ASTAT bits
                    2109   2109 
                    2110   2110 DASSIP	equ	01000000B ;Seek in progress
                    2111   2111 DASDRQ	equ	10000000B ;Data Request
                    2112   2112 
                    2113   2113  endif ;C4FDC or C16FDC or C64FDC
                    2114   2114 
                    2115   2115 ;-------------------------
                    2116   2116 ;IMSAI FIF Disk Controller
                    2117   2117 ;-------------------------
                    2118   2118  if IFIF
                    2119   2119 
ffff  #             2120   2120 BOOTER	set	TRUE		;Boot command exists
                    2121   2121 
0010  =             2122   2122 MAXTRYS	equ	16		;max retries
                    2123   2123 
                    2124   2124 ;Disk Command Port
                    2125   2125 
00fd  =             2126   2126 IDISK	equ	DIBASE
                    2127   2127 
                    2128   2128 ;Command Port Commands
                    2129   2129 
0000  =             2130   2130 IEXEC0	equ	0		;Execute string command 0
0010  =             2131   2131 ISSPTR	equ	10h		;Set string pointer 0
0021  =             2132   2132 IRESTR	equ	21h		;Reestore to track 0
                    2133   2133 
                    2134   2134 ;RAM string commands
                    2135   2135 
0021  =             2136   2136 IRDSEC	equ	21h		;Read sector
                    2137   2137 
                    2138   2138 ;RAM location for command strings
                    2139   2139 
0080  =             2140   2140 IBCMD	equ	80h		;Beginning of disc command string
                    2141   2141 				;..and command byte therEOF
0081  =             2142   2142 IBSTAT	equ	IBCMD+1		;Status byte
0082  =             2143   2143 IBTRK	equ	IBCMD+2		;Track (2 bytes)
0084  =             2144   2144 IBSECT	equ	IBCMD+4		;Sector
0085  =             2145   2145 IBUFAD	equ	IBCMD+5		;Buffer Address
                    2146   2146 
                    2147   2147 ;Disk status
                    2148   2148 
0001  =             2149   2149 ISUCCS	equ	01h		;Success
                    2150   2150 
                    2151   2151  endif ;IFIF
                    2152   2152 
                    2153   2153 ;------------------------------------------
                    2154   2154 ;Micropolis FD controller B Disk Controller
                    2155   2155 ;------------------------------------------
                    2156   2156  if MICROP
                    2157   2157 
                    2158   2158 BOOTER	set	TRUE		;Boot command exists
                    2159   2159 
                    2160   2160 FDCMD	equ	DMBASE+200h	;Command register
                    2161   2161 FDSECT	equ	DMBASE+200h	;Sector register
                    2162   2162 FDSTAT	equ	DMBASE+201h	;Status register
                    2163   2163 FDDATA	equ	DMBASE+203h	;Data in/out	
                    2164   2164 
                    2165   2165 SCLEN 	equ	268	;sector len without sync byte and checksum
                    2166   2166 PTROFF	equ	010Ah	;offset of load address
                    2167   2167 			;..pointer within sector 0
                    2168   2168 EXEOFF	equ	0CH	;offset into sector data for execution
                    2169   2169 
                    2170   2170 MAXTRYS	equ	16	;max retries
                    2171   2171 
                    2172   2172 ;Sector register is at FDCBASE+0
                    2173   2173 
                    2174   2174 SMASK	equ	00Fh	;Sector mask
                    2175   2175 SFLG	equ	080h	;sector start flag
                    2176   2176 SIFLG	equ	040h	;sector interrupt flag
                    2177   2177 DTMR	equ	020h	;2mhz/4mhz jumper for timers
                    2178   2178 
                    2179   2179 ;Status register is at FDCBASE+1
                    2180   2180 
                    2181   2181 TFLG	equ	80h	;transfer flag
                    2182   2182 INTE	equ	40h	;S-100 INTE signal
                    2183   2183 RDY	equ	20h	;disk ready
                    2184   2184 WPT	equ	10h	;write protect
                    2185   2185 TK0	equ	08h	;track zero
                    2186   2186 USLT	equ	04h	;unit selected
                    2187   2187 
                    2188   2188 ;Command register at FDCBASE+0 (and again at FDCBASE+1)
                    2189   2189 ;  bits 1-0 command modifier
                    2190   2190 ;  bits 7-5 command
                    2191   2191 
                    2192   2192 SLUN	equ	020h	;select unit
                    2193   2193 			;Modifier is unit address
                    2194   2194 
                    2195   2195 SINT	equ	040h	;set interrupt
                    2196   2196 			;Modifier=1 enable int
                    2197   2197 			;  	    0 disable int
                    2198   2198 
                    2199   2199 STEP	equ	060h	;step carriage
                    2200   2200 STEPO	equ	000h	;step out modifier
                    2201   2201 STEPI	equ	001h	;step in modifier
                    2202   2202 
                    2203   2203 WTCMD	equ	080h	;enable write
                    2204   2204 			;No modifier used
                    2205   2205 
                    2206   2206 FRESET	equ	0A0h	;reset FDC
                    2207   2207 			;No modifier used
                    2208   2208 
                    2209   2209 ;RAM locations that must be initialized for DOS
                    2210   2210 
                    2211   2211 ROMADR	equ	00A0h	;onboard ROM base address
                    2212   2212 FDCADR	equ	00A2h	;Save FDC address here for DOS
                    2213   2213 LODADR	equ	00A4h	;load address of sector
                    2214   2214 RDSEC	equ	00A6h	;Read Sector subroutine
                    2215   2215 			;..(once its moved)
                    2216   2216 
                    2217   2217 RDSECH	equ	RDSEC+3	;enter here with hl=FDC address
                    2218   2218 			;(entry point used during boot)
                    2219   2219 
                    2220   2220  endif ;MICROP
                    2221   2221 
                    2222   2222 ;--------------------------------------------------------
                    2223   2223 ;Northstar MDC-A and MDS-A Single-Density Disk Controller
                    2224   2224 ;--------------------------------------------------------
                    2225   2225  if NSTARS
                    2226   2226 
                    2227   2227 BOOTER	set	TRUE		;Boot command exists
                    2228   2228 
                    2229   2229 ;The Northstar MDC-A and MDS-A disk controllers work by reading
                    2230   2230 ;and writing to memory addresses - no INs or outs occur.
                    2231   2231 ;Commands are encoded into the low byte of the address.
                    2232   2232 
                    2233   2233 ;Disk controller memory space allocation
                    2234   2234 
                    2235   2235 ROMADR	equ	DMBASE+100h	;Standard ROM address
                    2236   2236 CTLADR	equ	DMBASE+300h	;Disk Control base address
                    2237   2237 
                    2238   2238 ;controller commands (are at memory addresses)
                    2239   2239 
                    2240   2240 CTLDS0	  equ	  CTLADR+00h	  ;Select drive 0 (illegal)
                    2241   2241 CTLDS1	  equ	  CTLADR+01h	  ;Select drive 1
                    2242   2242 CTLDS2	  equ	  CTLADR+02h	  ;Select drive 2
                    2243   2243 CTLDS3	  equ	  CTLADR+03h	  ;Select drive 3
                    2244   2244 CTLWRT	  equ	  CTLADR+04h	  ;Initiate write
                    2245   2245 CTLSTC	  equ	  CTLADR+08h	  ;Clear track-step f-f
                    2246   2246 CTLSTS	  equ	  CTLADR+09h	  ;Set track-step f-f
                    2247   2247 CTLDI	  equ	  CTLADR+0CH	  ;Disarm interrupts
                    2248   2248 CTLEI	  equ	  CTLADR+0DH	  ;Arm interrupts
                    2249   2249 CTLNOP	  equ	  CTLADR+10h	  ;No operation
                    2250   2250 CTLRSF	  equ	  CTLADR+14h	  ;Reset sector flag
                    2251   2251 CTLRES	  equ	  CTLADR+18h	  ;Reset controller
                    2252   2252 CTLSTO	  equ	  CTLADR+1CH	  ;select step out
                    2253   2253 CTLSTI	  equ	  CTLADR+1DH	  ;Select step in
                    2254   2254 CTLBST	  equ	  CTLADR+20h	  ;Read B status
                    2255   2255 CTLRD	  equ	  CTLADR+40h	  ;Read Data
                    2256   2256 CTLMO	  equ	  CTLADR+80h	  ;Drive motors on command
                    2257   2257 
                    2258   2258 ;A-Status Bits
                    2259   2259 
                    2260   2260 SATR0	  equ	  01h		  ;Track 0
                    2261   2261 SAWP	  equ	  02h		  ;Write protect
                    2262   2262 SABDY	  equ	  04h		  ;Sync chr found
                    2263   2263 SAWRT	  equ	  08h		  ;Ready for write data
                    2264   2264 SAMO	  equ	  10h		  ;Motor is on
                    2265   2265 SAWN	  equ	  40h		  ;Status read during window
                    2266   2266 SASF	  equ 	  80h		  ;Sector flag
                    2267   2267 
                    2268   2268 ;B-Status Bits
                    2269   2269 
                    2270   2270 SBSECT	  equ	  0Fh		  ;Sector position mask
                    2271   2271 SBMO	  equ	  10h		  ;Motor is on
                    2272   2272 SBWN	  equ	  40h		  ;Status read during window
                    2273   2273 SBSF	  equ 	  80h		  ;Sector flag
                    2274   2274 
                    2275   2275 ;Constants
                    2276   2276 
                    2277   2277 UNINIT	equ	59h		;uinitialized RAM value
                    2278   2278 MAXTRYS	equ	10		;Max retries
                    2279   2279 BDRIVE	equ	1		;Boot drive
                    2280   2280 				;..(Code assumes this is 01.)
                    2281   2281 BTRACK	equ	0		;Boot track
                    2282   2282 BSECTR	equ	4		;Boot sector
                    2283   2283 LODADR	equ	2000h		;Standard MDS-A load address
                    2284   2284 EXEADR	equ	2000h		;..and execution address
                    2285   2285 
                    2286   2286  endif ;NSTARS
                    2287   2287 
                    2288   2288 ;----------------------------------------------
                    2289   2289 ;Northstar MDS-D Double-Density Disk Controller
                    2290   2290 ;----------------------------------------------
                    2291   2291  if NSTARD
                    2292   2292 
                    2293   2293 BOOTER	set	TRUE		;Boot command exists
                    2294   2294 
                    2295   2295 ;The Northstar MDS-D disk controller works by reading and
                    2296   2296 ;writing to memory addresses - no INs or outs occur.
                    2297   2297 ;Commands are encoded into the low byte of the address.
                    2298   2298 
                    2299   2299 ;-----------------------------
                    2300   2300 ;MDS-D Disk Controller Equates
                    2301   2301 ;-----------------------------
                    2302   2302 CTLWD	equ	DMBASE+100h	;Write data
                    2303   2303 CTLORD	equ	DMBASE+200h	;controller Orders
                    2304   2304 CTLCMD	equ	DMBASE+300h	;controller Commands
                    2305   2305 
                    2306   2306 ;Order Register Bits
                    2307   2307 
                    2308   2308 ORDDS0	equ	00		;No drive selected
                    2309   2309 ORDDS1	equ	01h		;Select drive 1
                    2310   2310 ORDDS2	equ	02h		;Select dribe 2
                    2311   2311 ORDDS3	equ	04h		;Select drive 3
                    2312   2312 ORDDS4	equ	08h		;Select drive 4
                    2313   2313 ORDST	equ	10h		;Step level
                    2314   2314 ORDSIN	equ	20h		;Step in
                    2315   2315 ORDSS	equ	40h		;Disk side
                    2316   2316 ORDDD	equ	80h		;Double-density
                    2317   2317 
                    2318   2318 ;Control register bits
                    2319   2319 
                    2320   2320 CTLRSF	equ	01h		;reset sector flag
                    2321   2321 CTLDI	equ	02h		;Disarm interrupt
                    2322   2322 CTLEI	equ	03h		;Arm interrupt
                    2323   2323 CTlsb	equ	04h		;Set Body (diag)
                    2324   2324 CTLMO	equ	05h		;Motors on
                    2325   2325 CTLWR	equ	06h		;Begin write
                    2326   2326 CTLRES	equ	07h		;reset controller
                    2327   2327 
                    2328   2328 CTLAS	equ	10h		;Select A-Status
                    2329   2329 CTLBS	equ	20h		;Select B-Status
                    2330   2330 CTLCS	equ	30h		;Select C-Status
                    2331   2331 CTLRD	equ	40h		;Select read data
                    2332   2332 
                    2333   2333 ;A-Status Bits
                    2334   2334 
                    2335   2335 SABD	equ	01h		;sync chr detected (body)
                    2336   2336 SARE	equ	04h		;Read enabled
                    2337   2337 SAWI	equ	08h		;Sector window
                    2338   2338 SAMO	equ	10h		;Motor on
                    2339   2339 SADD	equ	20h		;Double density detected
                    2340   2340 SAIX	equ	40h		;Index hole on previous sector
                    2341   2341 SASF	equ	80h		;Sector flag
                    2342   2342 				;..(cleared by software)
                    2343   2343 
                    2344   2344 ;B-Status Bits
                    2345   2345 
                    2346   2346 SBT0	equ	01h		;Track 0 detected
                    2347   2347 SBWP	equ	02h		;Write protected
                    2348   2348 SBWR	equ	08h		;Write operation in progress
                    2349   2349 SBMO	equ	10h		;Motor on
                    2350   2350 SBDD	equ	20h		;Double density detected
                    2351   2351 SBIX	equ	40h		;Index hole on previous sector
                    2352   2352 SBSF	equ	80h		;Sector flag
                    2353   2353 				;..(cleared by software)
                    2354   2354 
                    2355   2355 ;C-Status Bits
                    2356   2356 
                    2357   2357 SCSM	equ	0Fh		;Sector mask
                    2358   2358 SCMO	equ	10h		;Motor on
                    2359   2359 SCDD	equ	20h		;Double density detected
                    2360   2360 SCIX	equ	40h		;Index hole on previous sector
                    2361   2361 SCSF	equ	80h		;Sector flag
                    2362   2362 				;..(cleared by software)
                    2363   2363 
                    2364   2364 ;---------
                    2365   2365 ;Constants
                    2366   2366 ;---------
                    2367   2367 MAXTRYS	equ	10		;max retries
                    2368   2368 DDBSCR	equ	4		;Double-density boot sector
                    2369   2369 SDBSCR	equ	8		;Single-density boot sector
                    2370   2370 
                    2371   2371  endif ;NSTARD
                    2372   2372 
                    2373   2373 ;-----------------------------------------
                    2374   2374 ;SD Systems Versafloppy and Versafloppy II
                    2375   2375 ;Single- or Double-Density Disk Controller
                    2376   2376 ;for minidisks or 8" disks
                    2377   2377 ;-----------------------------------------
                    2378   2378  if VERSA1 or VERSA2 or SALFDC
                    2379   2379 
                    2380   2380 BOOTER	set	TRUE		;Boot command exists
                    2381   2381 WD179X	set	TRUE		;WD179x (or WD177x)
                    2382   2382 
                    2383   2383 SECSIZ	equ	128		;boot sector size
                    2384   2384 VLOAD	equ	0800h		;Boot code Load address
                    2385   2385 VBOOT	equ	0080H		;Boot code exec address
                    2386   2386 MAXTRYS	equ	16		;Max retries
                    2387   2387 
                    2388   2388 ;Port addresses
                    2389   2389 
                    2390   2390 VDRSEL	equ	DIBASE+3	;Drive select port
                    2391   2391 VDCOM	equ	DIBASE+4	;WD1793 Command port
                    2392   2392 VDSTAT	equ	DIBASE+4	;WD1793 Status port
                    2393   2393 VTRACK	equ	DIBASE+5	;WD1793 Track port
                    2394   2394 VSECT	equ	DIBASE+6	;WD1793 Sector Register
                    2395   2395 VDDATA	equ	DIBASE+7	;WD1793 Data Register
                    2396   2396 
                    2397   2397  endif ;VERSA1 or VERSA2 or SALFDC
                    2398   2398 
                    2399   2399  if VERSA1
                    2400   2400 ;Versafloppy VDRSEL bit assignments (all active-low)
                    2401   2401 
                    2402   2402 VDSEL0N	equ	00000001b	;select drive 0
                    2403   2403 VDSEL1N	equ	00000010b	;select drive 1
                    2404   2404 VDSEL2N	equ	00000100b	;select drive 2
                    2405   2405 VDSEL3N	equ	00001000b	;select drive 3
                    2406   2406 VSIDE1N	equ	00010000b	;Select side 1
                    2407   2407 VRSTORN	equ	00100000b	;optional Restore
                    2408   2408 VWAITN	equ	01000000b	;Enable auto-wait circuit
                    2409   2409 VINTEN	equ	10000000b	;Interrupt Enable
                    2410   2410  endif ;VERSA1
                    2411   2411 
                    2412   2412  if VERSA2 or SALFDC
                    2413   2413 ;Versafloppy II VDRSEL bit assignments (all active-high)
                    2414   2414 
                    2415   2415 VDSEL0	equ	00000001b	;select drive 0
                    2416   2416 VDSEL1	equ	00000010b	;select drive 1
                    2417   2417 VDSEL2	equ	00000100b	;select drive 2
                    2418   2418 VDSEL3	equ	00001000b	;select drive 3
                    2419   2419 VSIDE1	equ	00010000b	;Select side 1
                    2420   2420 VMINI	equ	00100000b	;Set up for minidisk
                    2421   2421 VDDEN	equ	01000000b	;Enable double-density
                    2422   2422 VWAIT	equ	10000000b	;Enable auto-wait circuit
                    2423   2423  endif ;VERSA2 or SALFDC
                    2424   2424 
                    2425   2425 ;-------------------------------------------------
                    2426   2426 ;Tarbell Single- or Double-Density Disk Controller
                    2427   2427 ;-------------------------------------------------
                    2428   2428  if TARBL1 or TARBL2
                    2429   2429 
                    2430   2430 BOOTER	set	TRUE		;Boot command exists
                    2431   2431 WD179X	set	TRUE		;WD179x (or WD177x)
                    2432   2432 
                    2433   2433 SBOOT	equ	007DH		;Boot code exec address
                    2434   2434 SLOAD	equ	0		;Code load address
                    2435   2435 MAXTRYS	equ	16		;Max retries
                    2436   2436 
                    2437   2437 TDCOM	equ	DIBASE		;WD1793 Command port
                    2438   2438 TDSTAT	equ	DIBASE		;WD1793 Status port
                    2439   2439 TTRACK	equ	DIBASE+1	;WD1793 Track port
                    2440   2440 TSECT	equ	DIBASE+2	;WD1793 Sector Register
                    2441   2441 TDDATA	equ	DIBASE+3	;WD1793 Data Register
                    2442   2442 TWAIT	equ	DIBASE+4	;Wait Input Register
                    2443   2443  endif ;TARBL1 or TARBL2
                    2444   2444 
                    2445   2445  if TARBL1
                    2446   2446 TEXTP	equ	DIBASE+4h	;Extended Output Port
                    2447   2447 
                    2448   2448 ;Extended Output Port bits
                    2449   2449 
                    2450   2450 TPADE32	equ	00000000b	;Write to option pad E-32
                    2451   2451 TOUTSO	equ	00000001b	;Write to SOn line
                    2452   2452 TDSEL	equ	00000010b	;Write to Drive Select latch
                    2453   2453 TDSEL1N	equ	00010000b	;Drive Select 1, active low
                    2454   2454 TDSEL2N	equ	00100000b	;Drive Select 2, active low
                    2455   2455 TDSEL3N	equ	01000000b	;Drive Select 3, active low
                    2456   2456 TDSEL4N	equ	10000000b	;Drive Select 4, active low
                    2457   2457 
                    2458   2458 TSEL0	equ	TDSEL + (TDSEL1N xor 0F0h) ;select drive 0	
                    2459   2459  endif ;TARBL1
                    2460   2460 
                    2461   2461  if TARBL2
                    2462   2462 TEXTP0	equ	DIBASE+4h	;Extended Output Port 0
                    2463   2463 TEXTP1	equ	DIBASE+5h	;Ext. Out Port 1 (bank select)
                    2464   2464 
                    2465   2465 ;Extended Output Port 0 bits
                    2466   2466 
                    2467   2467 TDDEN	equ	00001000b	;Double density enable
                    2468   2468 TDSEL	equ	00110000b	;Drive select mask
                    2469   2469 TSIDE1	equ	01000000b	;Side 1 select
                    2470   2470  endif ;TARBL2
                    2471   2471 
                    2472   2472 ;-------------------------------------------
                    2473   2473 ;Common Western digital WD179x Constants
                    2474   2474 ;(Also correct for WD177x-type controllers.)
                    2475   2475 ;-------------------------------------------
                    2476   2476  if WD179X
                    2477   2477 
                    2478   2478 ;WD1793 Commands
                    2479   2479 
                    2480   2480 RSTRCM	equ	00000000B ;(I)Restore
                    2481   2481 SEEKCM	equ	00010000B ;(I)Seek
                    2482   2482 STEPCM	equ	00100000B ;(I)Step
                    2483   2483 STPICM	equ	01000000B ;(I)Step In
                    2484   2484 STPOCM	equ	01100000B ;(I)Step Out
                    2485   2485 RSECCM	equ	10000000B ;(II)Read Record
                    2486   2486 WSECCM	equ	10100000B ;(II)Write Record
                    2487   2487 RADRCM	equ	11000000B ;(III)Read addr
                    2488   2488 RTRKCM	equ	11100000B ;(III)Read track
                    2489   2489 WTRKCM	equ	11110000B ;(III)Write track
                    2490   2490 FINTCM	equ	11010000B ;(IV)Force int
                    2491   2491 
                    2492   2492 ;1793 Command Options (1st letter matches 1793 spec)
                    2493   2493 
                    2494   2494 RS03MS	equ	00000000b ;(I) 3 mS step rate
                    2495   2495 RS06MS	equ	00000001b ;(I) 6 mS step rate
                    2496   2496 RS10MS	equ	00000010b ;(I) 10 mS step rate
                    2497   2497 RS15MS	equ	00000011b ;(I) 15 mS step rate
                    2498   2498 VERTRK	equ	00000100b ;(I) verify on destination track
                    2499   2499 HDLOAD	equ	00001000b ;(I) head load
                    2500   2500 UPDTTR	equ	00010000b ;(I) update track reg
                    2501   2501 F1SCMP	equ	00000010b ;(II)enable side compare
                    2502   2502 F2SCS1	equ	00001000b ;(II)side compare, side 1
                    2503   2503 MULTCM	equ	00010000b ;(II) read/write multiple
                    2504   2504 ED15MS	equ	00000100b ;(II & III) settling delay
                    2505   2505 A0DDM	equ	00000001B ;(III)Write deleted-data mark
                    2506   2506 
                    2507   2507 ;Composite 1793 commands
                    2508   2508 ;Note: For some controllers, disk will always appear
                    2509   2509 ;ready if not HDLOAD.
                    2510   2510 
                    2511   2511 RESTOR	equ	RSTRCM+RS15MS+HDLOAD ;Restore
                    2512   2512 RDSECT	equ	RSECCM+ED15MS+F1SCMP ;read sector, side 0
                    2513   2513 
                    2514   2514 ;WD1793 status after a command
                    2515   2515 
                    2516   2516 SBUSY	equ	00000001b ;(All) busy
                    2517   2517 SCRCER	equ	00001000b ;(All) CRC error
                    2518   2518 SWPROT	equ	01000000b ;(All) write protect
                    2519   2519 SNORDY	equ	10000000b ;(All) drive not ready
                    2520   2520 SINDEX	equ	00000010b ;(I) index
                    2521   2521 STRAK0	equ	00000100b ;(I) track 0
                    2522   2522 SSEKER	equ	00010000b ;(I) seek error
                    2523   2523 SHEADL	equ	00100000b ;(I) head loaded
                    2524   2524 SWFALT	equ	00100000b ;(Write cmds) write fault
                    2525   2525 SDATRQ	equ	00000010b ;(II & III) data request state
                    2526   2526 SLOSTD	equ	00000100b ;(II & III) lost data error
                    2527   2527 SRNFER	equ	00010000b ;(II & III) record not found
                    2528   2528 SRCTYF	equ	00100000b ;(II & III) record type fault
                    2529   2529 SWFALT	equ	00100000b ;(II & III) Write fault
                    2530   2530 
                    2531   2531  endif ;WD179x
                    2532   2532 
                    2533   2533 ;==================
                    2534   2534 ;End of Definitions
                    2535   2535 ;==================
                    2536   2536 
                    2537   2537 ;========================================
                    2538   2538 ;= Memon/80 fixed-location Entry points =
                    2539   2539 ;= These are organized so that most of  =
                    2540   2540 ;= them align with CP/M BIOS offsets:   =
                    2541   2541 ;= MEINIT ~ BOOT                        =
                    2542   2542 ;= MECSTA ~ CONST                       =
                    2543   2543 ;= MECIN  ~ CONOUT                      =
                    2544   2544 ;= MECOUT ~ CONOUT                      =
                    2545   2545 ;= METPDO ~ PUNCH                       =
                    2546   2546 ;= METPDI ~ READER                      =
                    2547   2547 ;========================================
                    2548   2548 	org	MEBASE		;Memon/80 ROM start
                    2549   2549 
f800  f3            2550   2550 MEINIT:	di			;(00)Cold-start entry point
                    2551   2551 				;ints off for a little while
                    2552   2552 
f801  af            2553   2553 	xra	a
f802  57            2554   2554 	mov	d,a		;So code can recognize Memon
                    2555   2555 	
f803  c3 1f f8      2556   2556 MEWARM:	jmp	INIT
                    2557   2557 
                    2558   2558 ;the following 7 entry points can be called by CP/M,
                    2559   2559 ;and have been designed with minimal stack usage.
                    2560   2560 
f806  c3 df fd      2561   2561 MECSTA:	jmp	KSTAT		;(06)Test Console keyboard
                    2562   2562 				;Z set, 0 means no data
                    2563   2563 				;Z clear, a=FF if data AVAIL
f809  c3 d4 fd      2564   2564 MECIN:	jmp	KDATA		;(09)Get Console chr in a
f80c  c3 c7 fd      2565   2565 MECOUT:	jmp	PRINTC		;(0C)Send C to Console
                    2566   2566 				;a=c=chr on ret
                    2567   2567 
                    2568   2568  if TPORT
f80f  c3 e7 fd      2569   2569 METPSI:	jmp	TPISTA		;(0F)Test Transfer Port input
                    2570   2570 				;Z set, a=0 if no data
                    2571   2571 				;Z clear, a=FF if data
f812  c3 0f fe      2572   2572 METPDO:	jmp	TPDATC		;(12)Send C to  Transfer Port
f815  c3 ee fd      2573   2573 METPDI:	jmp	TPIDAT		;(15)Get Transfer Port chr in a
f818                2574   2574 METPSO:				;Get T-Port output status
                    2575   2575 				;a=0 & Z set if not ready
                    2576   2576 				;a=FF & Z clear if ready
                    2577   2577 
                    2578   2578 ;Fall into TPOSTA
                    2579   2579  endif ;TPORT
                    2580   2580 
                    2581   2581 ;***CP/M External Subroutine************************
                    2582   2582 ;Get Transfer Port Output Status
                    2583   2583 ;On Exit:
                    2584   2584 ;  Z clear and a=FFh if the printer can accept a chr
                    2585   2585 ;  Z set and a=0 of the print queue is full
                    2586   2586 ;***************************************************
f818                2587   2587 TPOSTA:
                    2588   2588 
                    2589   2589  if TPORT and (not TMEMAP)
f818  db 23         2590   2590 	in	TSTAT
                    2591   2591  endif ;TPORT and (not TMEMAP)
                    2592   2592 
                    2593   2593  if TPORT and TMEMAP
                    2594   2594 	lda	TSTAT
                    2595   2595  endif ;TPORT and TMEMAP
                    2596   2596 
                    2597   2597  if TPORT and TISTAT
                    2598   2598 	cma			;inverted status bit
                    2599   2599  endif ;TPORT and TISTAT
                    2600   2600 
                    2601   2601  if TPORT
f81a  e6 01         2602   2602 	ani	TTXRDY
f81c  c3 e3 fd      2603   2603 	jmp	DOSTAT
                    2604   2604 
                    2605   2605  endif ;TPORT
                    2606   2606 
                    2607   2607 ;=============================
                    2608   2608 ;= Cold-Start Initialization =
                    2609   2609 ;=============================
                    2610   2610 ;On Entry:
                    2611   2611 ;  a=0
                    2612   2612 ;  Interrupts are disabled
                    2613   2613 ;-----------------------------
f81f                2614   2614 INIT:
                    2615   2615 
                    2616   2616 ;****************************************
                    2617   2617 ;Serial Port Initialization
                    2618   2618 ;(conditional assembly depending on which
                    2619   2619 ;serial port options are selected above)
                    2620   2620 ;****************************************
                    2621   2621 
                    2622   2622 ;------------------------------------------------------
                    2623   2623 ;Initialize RAM flags for any interrupt-driven I/O port
                    2624   2624 ;On Entry and Exit:
                    2625   2625 ;  a=0
                    2626   2626 ;------------------------------------------------------
                    2627   2627  if CRXINT
                    2628   2628 	sta	CIFLAG
                    2629   2629  endif ;CRXINT
                    2630   2630 
                    2631   2631  if TRXINT
                    2632   2632 	sta	TIFLAG
                    2633   2633  endif ;TRXINT
                    2634   2634 
                    2635   2635 ;--------------------------------
                    2636   2636 ;Initialize any/all INS8250 UARTs
                    2637   2637 ;On Entry:
                    2638   2638 ; a=0
                    2639   2639 ;--------------------------------
                    2640   2640 ;INS8250 as Console
                    2641   2641 
                    2642   2642  if C8250 and (not T8250)
                    2643   2643 	out	CSINTEN		;Interrupts off
                    2644   2644 	out	CSTAT
                    2645   2645 
                    2646   2646 	mvi	a,0Fh		;modem control reg
                    2647   2647 	out	CSMDMCT		;Handshakes true
                    2648   2648 
                    2649   2649 	mvi	a,CSTOPS or CDLAB ;baud rate divisor access
                    2650   2650 	out	CSLCTRL		;and default stop bits
                    2651   2651 
                    2652   2652 	mvi	a,cPBAUD SHR 8	;Divisor high byte
                    2653   2653 	out	CSINTEN
                    2654   2654 	mvi	a,cPBAUD and 0FFh
                    2655   2655 	out	CDATA		;Divisor low byte
                    2656   2656 
                    2657   2657 	mvi	a,CSTOPS	;stop pointing to divisor
                    2658   2658 	out	CSLCTRL
                    2659   2659 
                    2660   2660  endif ;C8250 and (not T8250)
                    2661   2661 
                    2662   2662 ;INS8250 as Transfer Port
                    2663   2663 
                    2664   2664  if T8250 and (not C8250)
                    2665   2665 	out	TSINTEN		;Interrupts off
                    2666   2666 	out	TSTAT
                    2667   2667 
                    2668   2668 	mvi	a,0Fh		;modem control reg
                    2669   2669 	out	TSMDMCT		;Handshakes true
                    2670   2670 
                    2671   2671 	mvi	a,TSTOPS or TDLAB ;baud rate divisor access
                    2672   2672 	out	TSLCTRL		;and default stop bits
                    2673   2673 
                    2674   2674 	mvi	a,TPBAUD SHR 8	;Divisor high byte
                    2675   2675 	out	TSINTEN
                    2676   2676 	mvi	a,TPBAUD and 0FFh
                    2677   2677 	out	TDATA		;Divisor low byte
                    2678   2678 
                    2679   2679 	mvi	a,TSTOPS	;stop pointing to divisor
                    2680   2680 	out	TSLCTRL
                    2681   2681  endif ;T8250 and (not C8250)
                    2682   2682 
                    2683   2683  if C8250 and T8250
                    2684   2684 	out	CSINTEN		;Interrupts off
                    2685   2685 	out	CSTAT
                    2686   2686 	out	TSINTEN
                    2687   2687 	out	TSTAT
                    2688   2688 
                    2689   2689 	mvi	a,0Fh		;modem control reg
                    2690   2690 	out	CSMDMCT		;Handshakes true
                    2691   2691 	out	TSMDMCT		;Handshakes true
                    2692   2692 
                    2693   2693 	mvi	a,CSTOPS or CDLAB ;baud rate divisor access
                    2694   2694 	out	CSLCTRL		;and default stop bits
                    2695   2695 
                    2696   2696 	mvi	a,cPBAUD SHR 8	;Divisor high byte
                    2697   2697 	out	CSINTEN
                    2698   2698 	mvi	a,cPBAUD and 0FFh
                    2699   2699 	out	CDATA		;Divisor low byte
                    2700   2700 
                    2701   2701 	mvi	a,CSTOPS	;stop pointing to divisor
                    2702   2702 	out	CSLCTRL
                    2703   2703 
                    2704   2704 
                    2705   2705 	mvi	a,TSTOPS or TDLAB ;baud rate divisor access
                    2706   2706 	out	TSLCTRL		;and default stop bits
                    2707   2707 
                    2708   2708 	mvi	a,TPBAUD SHR 8	;Divisor high byte
                    2709   2709 	out	TSINTEN
                    2710   2710 	mvi	a,TPBAUD and 0FFh
                    2711   2711 	out	TDATA		;Divisor low byte
                    2712   2712 
                    2713   2713 	mvi	a,TSTOPS	;stop pointing to divisor
                    2714   2714 	out	TSLCTRL
                    2715   2715 
                    2716   2716  endif ;C8250 and T8250
                    2717   2717 
                    2718   2718 ;---------------------------------------------
                    2719   2719 ;Initialize any/all I/O or memory-mapped 8251
                    2720   2720 ;UARTs for async polled access, no interrupts.
                    2721   2721 ; On Exit:
                    2722   2722 ;   a=0
                    2723   2723 ;---------------------------------------------
                    2724   2724  if C8251 or T8251
f81f  21 1b fe      2725   2725 	lxi	h,IN8251	;8251 INIT table
                    2726   2726 
f822  7e            2727   2727 SI2LUP:	mov	a,m
                    2728   2728  endif ;C8251 or T8251
                    2729   2729 
                    2730   2730  if C8251 and (not CMEMAP)
f823  d3 03         2731   2731 	out	CCTRL		;I/O-mapped 8251
                    2732   2732  endif ;C8251 and (not CMEMAP)
                    2733   2733 
                    2734   2734  if C8251 and CMEMAP
                    2735   2735 	sta	CCTRL		;memory-mapped 8251
                    2736   2736  endif ;C8251 and CMEMAP
                    2737   2737 
                    2738   2738  if T8251 and (not TMEMAP)
f825  d3 23         2739   2739 	out	TCTRL		;I/O-mapped 8251
                    2740   2740  endif ;T8251 and (not TMEMAP)
                    2741   2741 
                    2742   2742  if T8251 and TMEMAP
                    2743   2743 	sta	TCTRL		;memory-mapped 8251
                    2744   2744  endif ;T8251 and TMEMAP
                    2745   2745 
                    2746   2746  if C8251 or T8251
f827  23            2747   2747 	inx	h
f828  ee 37         2748   2748 	xri	SI24		;last one?
f82a  c2 22 f8      2749   2749 	jnz	SI2LUP
                    2750   2750  endif ;C8251 or T8251
                    2751   2751 
                    2752   2752  if CISIO2A or CISIO2B or TISIO2A or TISIO2B
f82d  d3 08         2753   2753 	out	SIOCTL		;a=0: disable SIO-2 interrupts
                    2754   2754  endif ;CISIO2A or CISIO2B or TISIO2A or TISIO2B
                    2755   2755 
                    2756   2756 ;-------------------------------
                    2757   2757 ;Initialize any/all MC6850 ACIAs
                    2758   2758 ;-------------------------------
                    2759   2759  if C6850 or T6850
                    2760   2760 	mvi	a,U68RES	;ACIA reset
                    2761   2761  endif ;C6850 or T6850 
                    2762   2762 
                    2763   2763  if C6850
                    2764   2764 	out	CCTRL		;2SIO port
                    2765   2765  endif ;C6850
                    2766   2766 
                    2767   2767  if T6850
                    2768   2768 	out	TCTRL		;2SIO port
                    2769   2769  endif ;T6850
                    2770   2770 
                    2771   2771  if C6850 or T6850
                    2772   2772 	mvi	a,U68ST2	;Port set up
                    2773   2773  endif ;C6850 or T6850 
                    2774   2774 
                    2775   2775  if C6850
                    2776   2776 	out	CCTRL		;2SIO port
                    2777   2777  endif ;C6850
                    2778   2778 
                    2779   2779  if T6850
                    2780   2780 	out	TCTRL		;2SIO port
                    2781   2781  endif ;T6850
                    2782   2782 ;------------------------------------------------------------
                    2783   2783 ;Initialize the baud rates for both CCS 2718 serial channels,
                    2784   2784 ;including setting their baud rates. (If port B is used, it
                    2785   2785 ;will be initialized in the 8251 initialization below.) If
                    2786   2786 ;one of the CCS 2718 serial ports is not used, then its baud
                    2787   2787 ;rate will default to a value of 0, which is 19200 baud.
                    2788   2788 ;------------------------------------------------------------
0000  #             2789   2789 CBD18	set	0
0000  #             2790   2790 TBD18	set	0
                    2791   2791  if CC2718A or CC2718B
                    2792   2792 CBD18	set	CPBAUD
                    2793   2793 BASE18	set	CBASE
                    2794   2794  endif ;CC2718A or CC2718B
                    2795   2795 
                    2796   2796  if TC2718A or TC2718B
                    2797   2797 TBD18	set	TPBAUD
                    2798   2798 BASE18	set	TBASE
                    2799   2799  endif ;TC2718A or TC2718B
                    2800   2800 
                    2801   2801  if CC2718A or CC2718B or TC2718A or TC2718B
                    2802   2802 	mvi	a,(CBD18 or TBD18) and 0FFh
                    2803   2803 	out	BASE18
                    2804   2804  endif ;CC2718A or CC2718B or TC2718A or TC2718B	
                    2805   2805 
                    2806   2806 ;----------------------------------
                    2807   2807 ;Initialize both CCS 2719 channels,
                    2808   2808 ;including setting their baud rates
                    2809   2809 ;----------------------------------
                    2810   2810  if DART
                    2811   2811 
                    2812   2812 ;Initialize both DART channels
                    2813   2813 
                    2814   2814 	lxi	h,DITAB
                    2815   2815 
                    2816   2816 DILOOP:	mov	a,m
                    2817   2817 	inx	h
                    2818   2818  endif ;DART
                    2819   2819 
                    2820   2820  if CC2719A or CC2719B
                    2821   2821 	out	CCTRL
                    2822   2822  endif ;CC2719A or CC2719B
                    2823   2823 
                    2824   2824  if TC2719A or TC2719B
                    2825   2825 	out	TCTRL
                    2826   2826  endif ;TC2719A or TC2719B
                    2827   2827 
                    2828   2828  if DART
                    2829   2829 	cpi	DI7		;last one?
                    2830   2830 	jnz	DILOOP
                    2831   2831 
                    2832   2832 ;set the stop bits for each channel
                    2833   2833 
                    2834   2834 	mvi	a,DWR4
                    2835   2835  endif ;DART
                    2836   2836 
                    2837   2837  if CC2719A or CC2719B
                    2838   2838 	out	CCTRL
                    2839   2839  endif ;CC2719A or CC2719B
                    2840   2840 
                    2841   2841  if TC2719A or TC2719B
                    2842   2842 	out	TCTRL
                    2843   2843  endif ;TC2719A or TC2719B
                    2844   2844 
                    2845   2845  if CC2719A or CC2719B
                    2846   2846 	mvi	a,CSTOPS
                    2847   2847 	out	CCTRL
                    2848   2848  endif ;CC2719A or CC2719B
                    2849   2849 
                    2850   2850  if TC2719A or TC2719B
                    2851   2851 	mvi	a,TSTOPS
                    2852   2852 	out	TCTRL
                    2853   2853  endif ;TC2719A or TC2719B
                    2854   2854 
                    2855   2855 ;Initialize baud rates in the CTC
                    2856   2856 
                    2857   2857  if CC2719A or CC2719B
                    2858   2858 	mvi	a,cPBAUD SHR 8	;set up Console baud
                    2859   2859 	out	CCTC
                    2860   2860 	mvi	a,cPBAUD and 0FFh
                    2861   2861 	out	CCTC
                    2862   2862  endif ;CC2719A or CC2719B
                    2863   2863 
                    2864   2864  if TC2719A or TC2719B
                    2865   2865 	mvi	a,TPBAUD SHR 8	;set up Transfer Port baud
                    2866   2866 	out	TCTC
                    2867   2867 	mvi	a,TPBAUD and 0FFh
                    2868   2868 	out	TCTC
                    2869   2869  endif ;TC2719A or TC2719B
                    2870   2870 
                    2871   2871 ;--------------------------------------------
                    2872   2872 ;Initialize both Compupro Interfacer channels
                    2873   2873 ;--------------------------------------------
                    2874   2874  if CIFAC or TIFAC
                    2875   2875 	mvi	a,IFRST
                    2876   2876  endif ;CIFAC or TIFAC
                    2877   2877 
                    2878   2878  if CIFAC
                    2879   2879 	out	CCTRL
                    2880   2880  endif ;CIFAC
                    2881   2881 
                    2882   2882  if TIFAC
                    2883   2883 	out	TCTRL	
                    2884   2884  endif ;TIFAC
                    2885   2885 
                    2886   2886 ;---------------------------------
                    2887   2887 ;Initialize Compupro Interfacer II
                    2888   2888 ;---------------------------------
                    2889   2889  if CIFAC2
                    2890   2890 	mvi	a,CIFRST
                    2891   2891 	out	CCTRL	
                    2892   2892  endif ;CIFAC2
                    2893   2893 
                    2894   2894  if TIFAC2
                    2895   2895 	mvi	a,TIFRST
                    2896   2896 	out	TCTRL	
                    2897   2897  endif ;TIFAC2
                    2898   2898 
                    2899   2899 ;----------------------------------------
                    2900   2900 ;Initialize both Cromemco TU-ART channels
                    2901   2901 ;----------------------------------------
                    2902   2902  if CTUART or TTUART
                    2903   2903 	mvi	a,TURST		;reset
                    2904   2904  endif ;CTUART or TTUART
                    2905   2905 
                    2906   2906  if CTUART
                    2907   2907 	out	TCCTRL
                    2908   2908  endif ;CTUART
                    2909   2909 
                    2910   2910  if TTUART
                    2911   2911 	out	TTCTRL
                    2912   2912  endif ;TTUART
                    2913   2913 
                    2914   2914  if CTUART or TTUART
                    2915   2915 	xra	a		;disable interrupts
                    2916   2916  endif ;CTUART or TTUART
                    2917   2917 
                    2918   2918  if CTUART
                    2919   2919 	out	TCINTE
                    2920   2920  endif ;CTUART
                    2921   2921 
                    2922   2922  if TTUART
                    2923   2923 	out	TTINTE
                    2924   2924  endif ;TTUART
                    2925   2925 
                    2926   2926  if CTUART
                    2927   2927 	mvi	a,cPBAUD SHR 8	;Console high baud rate bit
                    2928   2928 	out	TCCTRL
                    2929   2929 
                    2930   2930 	mvi	a,cPBAUD and 0FFh ;set Console baud rate
                    2931   2931 	out	TCPBAUD
                    2932   2932  endif ;CTUART
                    2933   2933 
                    2934   2934  if TTUART
                    2935   2935 	mvi	a,TPBAUD SHR 8	;Transfer PT high baud rate bit
                    2936   2936 	out	TTCTRL
                    2937   2937 
                    2938   2938 	mvi	a,TPBAUD and 0FFh ;set Transfer Port baud rate
                    2939   2939 	out	TTPBAUD	
                    2940   2940  endif ;TTUART
                    2941   2941 
                    2942   2942 ;----------------------------------------
                    2943   2943 ;Install jump vectors for H8-5 interrupts
                    2944   2944 ;----------------------------------------
                    2945   2945  if CH85
                    2946   2946 ;	mvi	a,JMP
                    2947   2947 	mvi	a,0C3H
                    2948   2948 	sta	P8INT3	;addrss of PAM-8/XCON-8 Int 3 vector
                    2949   2949 	lxi	h,CONINT
                    2950   2950 	shld	P8INT3+1
                    2951   2951  endif ;CH85
                    2952   2952 
                    2953   2953  if TH85
                    2954   2954 ;	mvi	a,JMP
                    2955   2955 	mvi	a,0C3H
                    2956   2956 	sta	P8INT3	;addrss of PAM-8/XCON-8 Int 3 vector
                    2957   2957 	lxi	h,TBINT
                    2958   2958 	shld	P8INT3+1
                    2959   2959  endif ;TH85
                    2960   2960 
                    2961   2961 ;----------------------------------
                    2962   2962 ;Initialize the Ithaca Intersystems
                    2963   2963 ;Series II VIO serial port(s)
                    2964   2964 ;----------------------------------
                    2965   2965  if CIVIO2
                    2966   2966 	in	CCTRL		;reset mode byte flipflop
                    2967   2967 
                    2968   2968 	mvi	a,CPBAUD shr 8 ;set Console baud rate
                    2969   2969 	out	CMODE		;<MR17:MR10>
                    2970   2970 
                    2971   2971 	mvi	a,CPBAUD and 0FFh
                    2972   2972 	out	CMODE		;<MR27:MR20>
                    2973   2973  endif ;CIVIO2
                    2974   2974 
                    2975   2975  if TIVIO2
                    2976   2976 	in	TCTRL		;reset mode byte flipflop
                    2977   2977 
                    2978   2978 	mvi	a,TPBAUD shr 8 ;default t-port baud rate
                    2979   2979 	out	TMODE		;<MR17:MR10>
                    2980   2980 
                    2981   2981 	mvi	a,TPBAUD and 0FFh
                    2982   2982 	out	TMODE		;<MR27:MR20>
                    2983   2983  endif ;TIVIO2
                    2984   2984 
                    2985   2985  if CIVIO2 or TIVIO2
                    2986   2986 	mvi	a,CTL2651	;Control reg initialization
                    2987   2987  endif ;CIVIO2 or TIVIO2
                    2988   2988 
                    2989   2989  if CIVIO2
                    2990   2990 	out	CCTRL
                    2991   2991  endif ;CIVIO2
                    2992   2992 
                    2993   2993  if TIVIO2
                    2994   2994 	out	TCTRL
                    2995   2995  endif ;TIVIO2
                    2996   2996 
                    2997   2997 ;---------------------------------------------------------
                    2998   2998 ;Initialize any/all Jade Serial/Parallel I/O  serial ports
                    2999   2999 ;---------------------------------------------------------
                    3000   3000  if CJADSP or TJADSP
                    3001   3001 	mvi	a,JRESET
                    3002   3002  endif ;CJADSP or TJADSP
                    3003   3003 
                    3004   3004  if CJADSP
                    3005   3005 	out	CCTRL
                    3006   3006  endif ;CJADSP
                    3007   3007 
                    3008   3008  if TJADSP
                    3009   3009 	out	TCTRL
                    3010   3010  endif ;TJADSP
                    3011   3011 
                    3012   3012 ;*********************************
                    3013   3013 ;End of Serial Port Initialization
                    3014   3014 ;*********************************
                    3015   3015 
                    3016   3016 ;----------------------------------------------------
                    3017   3017 ;Hunt for the highest contiguous RAM page, and create
                    3018   3018 ;a stack at its top. (This assumes memory comes in
                    3019   3019 ;256-byte pageS.) Leave all memory as we found it.
                    3020   3020 ;If Memon/80 is running in low memory (e.g. for
                    3021   3021 ;debugging) then don't hunt in Memon's memory space.
                    3022   3022 ;----------------------------------------------------
00b0  #             3023   3023 HUNTA	set	STACK		;Hunt starting at 0
                    3024   3024 
                    3025   3025  if RAMCOD			;Running in low memory?
                    3026   3026 HUNTA	set	(CODEND and 0FF00h) or STACK
                    3027   3027 				;y: Hunt after Memon/80
                    3028   3028  endif ;RAMCOD
                    3029   3029 
                    3030   3030  if RAMHNT
f82f  21 b0 00      3031   3031 	lxi	h,HUNTA
                    3032   3032 
f832  24            3033   3033 FSLOOP:	inr	h		;next RAM page
f833  ca 3f f8      3034   3034 	jz	FSEND		;end of RAM?
                    3035   3035 
f836  7e            3036   3036 	mov	a,m		;get original RAM
f837  47            3037   3037 	mov	b,a		;and remember it
f838  2f            3038   3038 	cma
f839  77            3039   3039 	mov	m,a		;write the inverse
f83a  be            3040   3040 	cmp	m		;Did it write right?
f83b  70            3041   3041 	mov	m,b		;Put original RAM back
f83c  ca 32 f8      3042   3042 	jz	FSLOOP		;keep looking if RAM OK
f83f                3043   3043 FSEND:
                    3044   3044 
f83f  25            3045   3045 	dcr	h		;last RAM page
f840  f9            3046   3046 	sphl			;stack in RAM page
                    3047   3047 
f841  2e 8f         3048   3048 	mvi	l,RAMBEG	;For announcement
                    3049   3049 
                    3050   3050  endif ;RAMHNT
                    3051   3051 
                    3052   3052  if not RAMHNT
                    3053   3053 ;Set up stack in RAM, and load hl with our 1st RAM address
                    3054   3054 
                    3055   3055 	lxi	sp, STACK
                    3056   3056 	lxi	h,RAMBEG	;For announcement
                    3057   3057  endif ;not RAMHNT
                    3058   3058 
                    3059   3059  if TPORT
                    3060   3060 ;set up default: Transfer Port enabled (H<>0 here)
                    3061   3061 
f843  e5            3062   3062 	push	h		;h=port flag at top of stack
                    3063   3063  endif ;TPORT
                    3064   3064 
                    3065   3065 ;-------------------
                    3066   3066 ;print Signon Banner
                    3067   3067 ;-------------------
f844  cd 59 fd      3068   3068 	call	CILPRT		;Enables ints too, if ENINTS
f847  4d 65 6d 6f   3069   3069 	db	'Memon/80 '
f84b  6e 2f 38 30   3069   3070
f84f  20            3069   3071
f850  32 2e         3070   3072 	db	((VERSION and 0F0h)/16)+'0','.'
f852  36            3071   3073 	db	(VERSION and 0Fh) +'0'
f853  20 62 79 20   3072   3074 	db	' by M.Eberhard',CR
f857  4d 2e 45 62   3072   3075
f85b  65 72 68 61   3072   3076
f85f  72 64 0d      3072   3077
                    3073   3078 
                    3074   3079  if not HELPC	;HELPC option also adds LF's after CR's
                    3075   3080 	db	LF
                    3076   3081  endif ;not HELPC
                    3077   3082 
f862  52 41 4d 3a   3078   3083 	db	'RAM:',' '+80h
f866  a0            3078   3084
                    3079   3085 
                    3080   3086 ;Announce RAM location. hl currently points
                    3081   3087 ;tO the address of MEMON's 1st RAM usage
                    3082   3088 
f867  cd 9d fd      3083   3089 	call	PHLCHX		;Trashes bc
                    3084   3090 
                    3085   3091 ;Fall into MAIN
                    3086   3092 
                    3087   3093 ;***************************
                    3088   3094 ;Command Processor Main Loop
                    3089   3095 ;Get and process commands
                    3090   3096 ;***************************
                    3091   3097 
                    3092   3098 ;Print the prompt, and get a line of keyboard input
                    3093   3099 
f86a  01 6a f8      3094   3100 MAIN:	lxi	b,MAIN		;create command-return
f86d  c5            3095   3101 	push	b		;..address on the stack
                    3096   3102 
f86e  cd 59 fd      3097   3103 	call	CILPRT		;print CR,LF, prompt
f871  be            3098   3104 	db	PROMPT+80h	;Enables ints too, if ENINTS
                    3099   3105 
f872  cd 12 fd      3100   3106 	call	GETLIN		;get user input line
                    3101   3107 				;de=beginning of line
                    3102   3108 				;Z set if no chr found
                    3103   3109 				;0 at end of line
                    3104   3110 
f875  d8            3105   3111 	rc			;No command? just ignore.
                    3106   3112 
                    3107   3113 ;Search the command list, and execute a command if found
                    3108   3114 
f876  eb            3109   3115 	xchg			;command address to hl
f877  11 a7 fe      3110   3116 	lxi	d,COMTAB-1	;point to command table
                    3111   3117 
f87a  4e            3112   3118 	mov	c,m		;1st command byte in c
f87b  23            3113   3119 	inx	h		;2nd command byte in m
                    3114   3120 
                    3115   3121 ;Search through table at de for a 2-chr match of c,m. Note
                    3116   3122 ;that c & m have their parity bits stripped. The msb of the
                    3117   3123 ;2nd table chr is the high bit of the address offset, so
                    3118   3124 ;that the range of address offsets is 512 bytes.
                    3119   3125 
f87c  13            3120   3126 NXTCOM:	inx	d		;skip over address offset
                    3121   3127 
f87d  1a            3122   3128 	ldax	d
f87e  b7            3123   3129 	ora	a		;test for table end
f87f  ca 07 fd      3124   3130 	jz	CMDERR		;not in table
                    3125   3131 
f882  a9            3126   3132 	xra	c		;test 1st chr
                    3127   3133 
f883  47            3128   3134 	mov	b,a		;temp save result
f884  13            3129   3135 	inx	d		;2nd table chr
                    3130   3136 
f885  1a            3131   3137 	ldax	d
f886  ae            3132   3138 	xra	m		;test 2nd chr
f887  13            3133   3139 	inx	d		;point to address offset
                    3134   3140 
f888  b0            3135   3141 	ora	b		;both chrs match?
                    3136   3142 
                    3137   3143  if LOWERC
f889  e6 df         3138   3144 	ani	('a'-'A') xor 0FFh ;lowercase ok
                    3139   3145  endif ;LOWERC
                    3140   3146 
f88b  07            3141   3147 	rlc			;address offset msb to lsb
f88c  fe 02         3142   3148 	cpi	2		;0 or 1 means match
f88e  d2 7c f8      3143   3149 	jnc	NXTCOM
                    3144   3150 
                    3145   3151 ;Got a match. Compute routine address and put it on stack
                    3146   3152 ;a=msb of address offset. Z is clear here, due to cpi above
                    3147   3153 
f891  23            3148   3154 	inx	h		;skip past 2nd command letter
                    3149   3155 
f892  47            3150   3156 	mov	b,a		;offset msb
f893  eb            3151   3157 	xchg			;(hl)=offset addr of routine
                    3152   3158 				;de=input buffer pointer
                    3153   3159 
f894  4e            3154   3160 	mov	c,m		;bc=address offset (b=0 or 1)
f895  21 c6 f8      3155   3161 	lxi	h,CMDBAS	;base of command routines
f898  09            3156   3162 	dad	b		;hl=address of routine
                    3157   3163 
f899  e5            3158   3164 	push	h		;command address on stack
                    3159   3165 
                    3160   3166 ;Special case: the TE command gets a non-hex parameter.
                    3161   3167 ;The address offset for the TE command is 0. a=msb, c=lsb.
                    3162   3168 
                    3163   3169  if (TPORT and (not ROM2K)) or (ROM2K and (not TPORT))
                    3164   3170 	ora	c
                    3165   3171 	rz
                    3166   3172  endif ;(TPORT and (not ROM2K)) or (ROM2K and (not TPORT))
                    3167   3173 
                    3168   3174 ;ROM2K and TPORT special case: the 1st 2 commands have a non-
                    3169   3175 ;hex 1st parameter, and the 1st 1 is only a jmp (3 bytes).
                    3170   3176 ; CE <command line text> (execute a CP/M program)
                    3171   3177 ; TE <exit chr>  (terminal mode)
                    3172   3178 
                    3173   3179  if ROM2K and TPORT 
f89a  0f            3174   3180 	rrc			;put msb in high bit
f89b  b1            3175   3181 	ora	c		;combine low bits
f89c  e6 fc         3176   3182 	ani	0FCh		;0 if offset = 0 or 3
f89e  c8            3177   3183 	rz
                    3178   3184  endif ;ROM2K and TPORT
                    3179   3185 
                    3180   3186 ;Get following hex parameter (if any) and put it in hl. Set the
                    3181   3187 ;carry flag if no parameter present. Leave de pointing to the
                    3182   3188 ;1st chr after the 1st parameter. 'return' to the command
                    3183   3189 ;routine on the stack.
                    3184   3190 
f89f  21            3185   3191 	db	21h		;"LXI H" opcode skips 2
                    3186   3192 
                    3187   3193 ;Skip over PHFHEX and into FNDHEX
                    3188   3194 
                    3189   3195 ;***Subroutine*************************************
                    3190   3196 ;Push h, then scan past spaces and get a hex value
                    3191   3197 ;On Entry:
                    3192   3198 ;  de=address of next item in the input line buffer
                    3193   3199 ;On Exit:
                    3194   3200 ;  Top-of-stack=original HL value
                    3195   3201 ;  hl=value from input buffer
                    3196   3202 ;  de advanced past chr
                    3197   3203 ;  Z set, carry clear if value found
                    3198   3204 ;  carry set, a=0 if no value found
                    3199   3205 ;**************************************************
f8a0  e3            3200   3206 PHFHEX:	xthl			;push hl
f8a1  e5            3201   3207 	push	h		;..beneath return address
                    3202   3208 
                    3203   3209 ;Fall into FNDHEX
                    3204   3210 
                    3205   3211 ;***Subroutine*************************************
                    3206   3212 ;Scan past spaces and get a hex value
                    3207   3213 ;On Entry:
                    3208   3214 ;  de=address of next item in the input line buffer
                    3209   3215 ;On Exit:
                    3210   3216 ;  hl=value of last 4 digits found, defaults to 0
                    3211   3217 ;  Z set
                    3212   3218 ;  de advanced past last digit found
                    3213   3219 ;  carry clear if value found
                    3214   3220 ;  carry set if no value found
                    3215   3221 ;**************************************************
f8a2  21 00 00      3216   3222 FNDHEX:	lxi	h,0		;default & initial value
                    3217   3223 
f8a5  cd 28 fd      3218   3224 FHEXLP:	call	SSPACE		;skip spaces, get 1st digit
f8a8  d8            3219   3225 	rc			;carry set if no digits
                    3220   3226 
f8a9  29            3221   3227 	dad	h		;make room for the new digit
f8aa  29            3222   3228 	dad	h
f8ab  29            3223   3229 	dad	h
f8ac  29            3224   3230 	dad	h
                    3225   3231 
                    3226   3232  if LOWERC
f8ad  fe 61         3227   3233 	cpi	'a'		;Lowercase letter?
f8af  da b4 f8      3228   3234 	jc	FXHL1
f8b2  e6 df         3229   3235 	ani	('a'-'A') xor 0FFh ;y: convert to uppercase
f8b4                3230   3236 FXHL1:
                    3231   3237  endif ;LOWERC
                    3232   3238 
f8b4  cd 4c fd      3233   3239 	call	HEXCON		;convert a to binary
f8b7  d2 07 fd      3234   3240 	jnc	CMDERR		;not valid hexidecimal value?
                    3235   3241 
f8ba  85            3236   3242 	add	l
f8bb  6f            3237   3243 	mov	l,a		;move new digit in
f8bc  13            3238   3244 	inx	d		;bump the pointer
                    3239   3245 
f8bd  1a            3240   3246 	ldax	d		;get next character
f8be  b7            3241   3247 	ora	a		;End of line?
f8bf  c8            3242   3248 	rz			;Y: a=0, carry clear
                    3243   3249 
f8c0  d6 20         3244   3250 	sui	' '		;value separator?
f8c2  c2 a5 f8      3245   3251 	jnz	FHEXLP		;N: it's another hex digit
                    3246   3252 
f8c5  c9            3247   3253 	ret			;a=0 for exit, keep carry clear
                    3248   3254 
                    3249   3255 ;=========================
                    3250   3256 ;base address for commands
                    3251   3257 ;=========================
f8c6  =             3252   3258 CMDBAS	equ	$
                    3253   3259 
                    3254   3260 ;***ROM2K Command Routine*******************************
                    3255   3261 ;CE Command Entry
                    3256   3262 ;Jump to actual routine, more than 512 bytes from CMDBAS
                    3257   3263 ; ---> Must be first, at CMDBAS <---
                    3258   3264 ;*******************************************************
                    3259   3265  if ROM2K
f8c6  c3 b8 fa      3260   3266 CECMD:	jmp	GCECMD
                    3261   3267  endif ;ROM2K
                    3262   3268 
                    3263   3269  if TPORT
                    3264   3270 ;***Command Routine************************************
                    3265   3271 ;TE [<EXchr>] (Simple Terminal mode)
                    3266   3272 ;
                    3267   3273 ; --->not ROM2K: TECMD must be first, at CMDBAS<---
                    3268   3274 ; --->ROM2K: TECMD must be second, at CMDBAS+3<---
                    3269   3275 ;
                    3270   3276 ;Send all Console keyboard data to Transfer Port, and
                    3271   3277 ;send all Transfer Port data to the Console. <EXchr>
                    3272   3278 ;from the keyboard exits. (default to DTEXIT.)
                    3273   3279 ;On Entry:
                    3274   3280 ;  de=points to the 1st chr in RAMBUF past the 'TE' cmd
                    3275   3281 ;******************************************************
f8c9  cd 59 fd      3276   3282 TECMD:	call	CILPRT		;announce exit chr
f8cc  45 78 69 74   3277   3283 	db	'Exit ','^'+80h
f8d0  20 de         3277   3284
                    3278   3285 
f8d2  cd 28 fd      3279   3286 	call	SSPACE		;get optional exit character
f8d5  b7            3280   3287 	ora	a		;nothing entered?
f8d6  c2 db f8      3281   3288 	jnz	TMNL1		;got an exit value in a
f8d9  3e 03         3282   3289 	mvi	a,DTEXIT	;default exit chr
                    3283   3290 
                    3284   3291 ;Convert exit chr to uppercase, non-control,
                    3285   3292 ;and print exit character message
                    3286   3293 
f8db  e6 1f         3287   3294 TMNL1:	ani	1Fh		;make it a CTRL chr
f8dd  6f            3288   3295 	mov	l,a		;remember exit chr
                    3289   3296 
f8de  f6 40         3290   3297 	ori	'C'-CTRLC	;make it printable
f8e0  cd c8 fd      3291   3298 	call	PRINTA
                    3292   3299 
f8e3  cd 59 fd      3293   3300 	call	CILPRT		;CR,LF,CR to be pretty
f8e6  8d            3294   3301 	db	CR+80h		;(start on a new line)
                    3295   3302 
                    3296   3303 ;Be a Terminal until we get an exit character=l
                    3297   3304 
f8e7  cd df fd      3298   3305 TLOOP:	call	KSTAT		;anything typed?
f8ea  c4 d4 fd      3299   3306 	cnz	KDATA		;Y:get the kbd data
                    3300   3307 
f8ed  bd            3301   3308 	cmp	l		;exit chr?
f8ee  c8            3302   3309 	rz			;Y: done
                    3303   3310 
f8ef  b7            3304   3311 	ora	a		;typed chr? (ignore null)
f8f0  c4 10 fe      3305   3312 	cnz	PBODAT		;kbd data to Transfer Port
                    3306   3313 
f8f3  cd e7 fd      3307   3314 	call	TPISTA		;any Transfer Port data?
                    3308   3315 				;NZ if so
                    3309   3316 
f8f6  c4 ee fd      3310   3317 	cnz	TPIDAT		;get Transfer Port data
                    3311   3318 				;always returnS w/ NZ
f8f9  c4 c8 fd      3312   3319 	cnz	PRINTA		;and send it to Console
f8fc  c3 e7 f8      3313   3320 	jmp	TLOOP
                    3314   3321  endif ;TPORT
                    3315   3322 
                    3316   3323 ;***Command Routine*************************************
                    3317   3324 ;? Command Entry
                    3318   3325 ;Jump to actual routine, more than 512 bytes from CMDBAS
                    3319   3326 ;*******************************************************
                    3320   3327  if HELPC
f8ff  c3 1f fe      3321   3328 HELP:	jmp	GHELP
                    3322   3329  endif ;HELPC
                    3323   3330 
                    3324   3331 ;***ROM2K Command Routine*******************************
                    3325   3332 ;MT Command Entry
                    3326   3333 ;Jump to actual routine, more than 512 bytes from CMDBAS
                    3327   3334 ;*******************************************************
                    3328   3335  if ROM2K
f902  c3 63 fb      3329   3336 MTCMD:	jmp	GMTCMD
                    3330   3337  endif ;ROM2K
                    3331   3338 
                    3332   3339 ;***ROM2K Command Routine*******************************
                    3333   3340 ;SE Command Entry
                    3334   3341 ;Jump to actual routine, more than 512 bytes from CMDBAS
                    3335   3342 ;*******************************************************
                    3336   3343  if ROM2K
f905  c3 d5 fa      3337   3344 SECMD:	jmp	GSECMD
                    3338   3345  endif ;ROM2K
                    3339   3346 
                    3340   3347 ;***ROM2K Command Routine*******************************
                    3341   3348 ;TB Command Entry
                    3342   3349 ;Jump to actual routine, more than 512 bytes from CMDBAS
                    3343   3350 ;*******************************************************
                    3344   3351  if ROM2K and  TSBAUD
                    3345   3352 TBCMD:	jmp	GTBCMD
                    3346   3353  endif ;ROM2K and  TSBAUD
                    3347   3354 
                    3348   3355 ;***Command Routine*************************************
                    3349   3356 ;BO Command Entry
                    3350   3357 ;Jump to actual routine, more than 512 bytes from CMDBAS
                    3351   3358 ;*******************************************************
f908                3352   3359 BOCMD:
ffff  #             3353   3360 JMPBOT	set	TRUE
                    3354   3361 
                    3355   3362  if H17R or MDUBLR or MICROR or NSTRSR or NSTRDR or IMD8R or IMDMR
                    3356   3363 BOOTER	set	TRUE
                    3357   3364 JMPBOT	set	FALSE
                    3358   3365  endif ;H17R or MDUBLR or MICROR or NSTRSR or NSTRDR or IMD8R or IMDMR
                    3359   3366 
                    3360   3367  if ROM2K and BOOTER
f908  cd 59 fd      3361   3368 	call	CILPRT		;2K ROM, so be verbose
f90b  42 6f 6f 74   3362   3369 	db	'Booting',CR+80h
f90f  69 6e 67 8d   3362   3370
                    3363   3371  endif ;ROM2K and BOOTER
                    3364   3372 
                    3365   3373 ;----------------------------------------
                    3366   3374 ;Boot using disk controller's onboard ROM
                    3367   3375 ;----------------------------------------
                    3368   3376  if H17R or MDUBLR or MICROR or NSTRSR or NSTRDR
                    3369   3377 	jmp	DMBASE	;use the H17's onboard boot code
                    3370   3378  endif ;H17R or MDUBLR or MICROR or NSTRSR or NSTRDR
                    3371   3379 
                    3372   3380 ;-------------------------------------------------------
                    3373   3381 ;Boot from IMSAI MDC-DIO Floppy Controller's onboard ROM
                    3374   3382 ;(Boot address depend on 8" or minidisk)
                    3375   3383 ;-------------------------------------------------------
                    3376   3384  if IMD8R
                    3377   3385 DBOOT	equ	DMBASE		;Boot from 8" disk
                    3378   3386  endif ;IMD8R
                    3379   3387 
                    3380   3388  if IMDMR
                    3381   3389 DBOOT	equ	DMBASE+3	;Boot from minidisk
                    3382   3390  endif ;IMDMR
                    3383   3391 
                    3384   3392  if IMD8R or IMDMR
                    3385   3393 IDRSEL	equ	DIBASE+0Eh	;disable controller, enable RAM
                    3386   3394 IDCSEL	equ	DIBASE+0Fh	;disable RAM, enable controller
                    3387   3395 
                    3388   3396 	out	IDCSEL	;disable RAM, enable controller
                    3389   3397 			;(a's value doesn't matter)
                    3390   3398 
                    3391   3399 	jmp	DBOOT	;Use onboard boot code
                    3392   3400 
                    3393   3401  endif ;IMD8R or IMDMR
                    3394   3402 
                    3395   3403 ;------------------------------------------
                    3396   3404 ;The boot code might be too big to fit here
                    3397   3405 ;------------------------------------------
                    3398   3406  if BOOTER and JMPBOT
f913  c3 47 fc      3399   3407 	jmp	GBOCMD
                    3400   3408  endif ;BOOTER and JMPBOT
                    3401   3409 
                    3402   3410 ;***Command Routine**************************************
                    3403   3411 ;EN [<ADR>] (enter data into memory)
                    3404   3412 ;
                    3405   3413 ;Get hex values from the keyboard and enter them
                    3406   3414 ;Sequuentially into memory, starting at <ADR>. a blank
                    3407   3415 ;line ends the routine and returns control to the
                    3408   3416 ;command mode. Values may be separated by spaces or CR'S.
                    3409   3417 ;Print the current address at the beginning of each line.
                    3410   3418 ;On Entry:
                    3411   3419 ;  hl=address, defaultING to 0
                    3412   3420 ;  carry set if none entered
                    3413   3421 ;********************************************************
f916  cd 90 fd      3414   3422 ENCMD:	call	PHLADR		;print hl as an address
                    3415   3423 				;trash c, b=0
                    3416   3424 
f919  cd 12 fd      3417   3425 	call	GETLIN		;get a line of user input
f91c  d8            3418   3426 	rc			;Z=blank line terminates
                    3419   3427 
                    3420   3428 ;Get hex data from the user input line and write it to memory
                    3421   3429 
f91d  cd a0 f8      3422   3430 ENLOOP:	call	PHFHEX		;push memory address and
                    3423   3431 				;..get/convert next value
                    3424   3432 
f920  7d            3425   3433 	mov	a,l		;get low byte as converted
                    3426   3434 
f921  e1            3427   3435 	pop	h		;recover memory address
f922  77            3428   3436 	mov	m,a		;put in the value
f923  23            3429   3437 	inx	h		;next address
                    3430   3438 
f924  cd 28 fd      3431   3439 	call	SSPACE		;scan to next input value
f927  d2 1d f9      3432   3440 	jnc	ENLOOP		;not end of line: continue
                    3433   3441 
f92a  c3 16 f9      3434   3442 	jmp	ENCMD		;END of line: start new line
                    3435   3443 
                    3436   3444 ;***Command Routine*********************************
                    3437   3445 ;FI [<ADR> [<BCNT> [<VAL>]]] (fill memory)
                    3438   3446 ;
                    3439   3447 ;Fill <BCNT> bytes of memory with <VAL> from <ADR>.
                    3440   3448 ;If <VAL> is not provided, then fill the specified
                    3441   3449 ;range with 00. If <BCNT> is not provided, then fill
                    3442   3450 ;memory until fill reaches the RAM page. If <ADR> is
                    3443   3451 ;not provided, then fill from 0.
                    3444   3452 ;On Entry:
                    3445   3453 ;  hl=<ADR>
                    3446   3454 ;  Carry set if none entered
                    3447   3455 ;  de points to <BCNT>, <VAL> follows, if any
                    3448   3456 ;***************************************************
f92d                3449   3457 FICMD:
                    3450   3458 
                    3451   3459  if RAMCOD			;Running in low memory?
                    3452   3460 	push	h
                    3453   3461 	lxi	b,-CODEND	;Will this wipe out Memon/80?
                    3454   3462 	dad	b		;16-bit compare
                    3455   3463 	pop	h
                    3456   3464 	jnc	CMDERR		;y: error
                    3457   3465  endif ;RAMCOD
                    3458   3466 
f92d  cd a0 f8      3459   3467 	call	PHFHEX		;push address and
                    3460   3468 				;..get hl=byte count default=0
                    3461   3469 
f930  cd a0 f8      3462   3470 	call	PHFHEX		;push byte count and
                    3463   3471 				;..get fill data, default 0
f933  55            3464   3472 	mov	d,l		;fill data in d
                    3465   3473 
f934  c1            3466   3474 	pop	b		;bc has byte count
                    3467   3475 
                    3468   3476  if RAMHNT
f935  cd b3 fa      3469   3477 	call	RAMPAG		;get h=RAM page
f938  5c            3470   3478 	mov	e,h
                    3471   3479  endif ;RAMHNT
                    3472   3480 
                    3473   3481  if not RAMHNT
                    3474   3482 	mvi	e,RAMEND/256
                    3475   3483  endif ;not RAMHNT
                    3476   3484 
f939  e1            3477   3485 	pop	h		;hl has start address
                    3478   3486 
f93a  7c            3479   3487 FILOOP:	mov	a,h		;filling Memon/80's RAM page?
f93b  bb            3480   3488 	cmp	e
f93c  c8            3481   3489 	rz			;Y: done
                    3482   3490 
f93d  72            3483   3491 	mov	m,d		;fill data
                    3484   3492 
f93e  23            3485   3493 	inx	h
f93f  0b            3486   3494 	dcx	b		;done yet?
f940  78            3487   3495 	mov	a,b
f941  b1            3488   3496 	ora	c
f942  c2 3a f9      3489   3497 	jnz	FILOOP
                    3490   3498 
f945  c9            3491   3499 	ret
                    3492   3500 
                    3493   3501 ;***Command Routine********************
                    3494   3502 ;HD <ADR> <BCNT> (Intel hex dump)
                    3495   3503 ;
                    3496   3504 ;Dump the specified memory range to the
                    3497   3505 ;Transfer Port as an Intel hex file
                    3498   3506 ;On Entry:
                    3499   3507 ;  hl=ADR
                    3500   3508 ;  de points to <BCNT>
                    3501   3509 ;**************************************
f946  cd 02 fd      3502   3510 HDCMD:	call	GETHEX		;save 1st address
                    3503   3511 				;get hl=byte count
                    3504   3512 
f949  d1            3505   3513 	pop	d		;recover start address
f94a  eb            3506   3514 	xchg			;hl has start, de has count
                    3507   3515 
                    3508   3516 ;Loop to send requested data in HDRLEN-byte records
                    3509   3517 
                    3510   3518 ;Send record-start
                    3511   3519 
f94b  cd 01 fe      3512   3520 HDLINE:	call	TPCRLF		;send CRLF to Transfer Port
                    3513   3521 
f94e  01 00 10      3514   3522 	lxi	b,hDRLEN*256	;b=bytes/line, 
                    3515   3523 				;..b<>0 for TPOUT,
                    3516   3524 				;..c=0 initial checksum
                    3517   3525 
f951  3e 3a         3518   3526 	mvi	a,':'		;record start
f953  cd 08 fe      3519   3527 	call	TPOUT
                    3520   3528 
                    3521   3529 ;Compute this record length (b=HDRLEN here)
                    3522   3530 	
f956  7b            3523   3531 	mov	a,e		;short last line?
f957  90            3524   3532 	sub	b		;normal bytes/line
f958  7a            3525   3533 	mov	a,d		;16-bit subtract
f959  99            3526   3534 	sbb	c		;c=0 here
f95a  d2 5e f9      3527   3535 	jnc	HDLIN1		;N: full line
                    3528   3536 
f95d  43            3529   3537 	mov	b,e		;Y:short line
f95e                3530   3538 HDLIN1:
                    3531   3539 
                    3532   3540 ;If byte count is 0 then go finish EOF record
                    3533   3541 
f95e  78            3534   3542 	mov	a,b
f95f  b7            3535   3543 	ora	a
f960  ca f7 fd      3536   3544 	jz	HDEOF
                    3537   3545 
                    3538   3546 ;Send record byte count=a to the Transfer Port (b<>0)
                    3539   3547 ;checksum=0 in c here
                    3540   3548 
f963  cd a6 fd      3541   3549 	call	PAHCSM		;send byte count
                    3542   3550 
                    3543   3551 ;Send the address at the beginning of each line,
                    3544   3552 ;computing the checksum in c
                    3545   3553 
f966  cd 9f fd      3546   3554 	call	PHLHEX		;hl=address, b<>0
                    3547   3555 
                    3548   3556 ;Send the record type (00), checksum in C
                    3549   3557 
f969  af            3550   3558 	xra	a
f96a  cd a6 fd      3551   3559 	call	PAHCSM
                    3552   3560 
                    3553   3561 ;Send b bytes of hex data on each line, computing
                    3554   3562 ;the checksum in c
                    3555   3563 
f96d  cd a5 fd      3556   3564 HDLOOP:	call	PMHCSM		;send chr to Transfer Port
                    3557   3565 
f970  1b            3558   3566 	dcx	d
f971  23            3559   3567 	inx	h
f972  05            3560   3568 	dcr	b		;next
f973  c2 6d f9      3561   3569 	jnz	HDLOOP
                    3562   3570 
                    3563   3571 ;Compute & send the checksum
                    3564   3572 
f976  af            3565   3573 	xra	a
f977  91            3566   3574 	sub	c
f978  04            3567   3575 	inr	b		;To Transfer Port
f979  cd a6 fd      3568   3576 	call	PAHCSM
                    3569   3577 
                    3570   3578 ;Give the user a chance to break in at the end of each line
                    3571   3579 
f97c  cd d1 fc      3572   3580 	call	CHKKBD
f97f  c3 4b f9      3573   3581 	jmp	HDLINE		;next record
                    3574   3582 
                    3575   3583 ;***Command Routine******************************
                    3576   3584 ;IN <PORT> (input from port)
                    3577   3585 ;
                    3578   3586 ;On Entry:
                    3579   3587 ;  l=PORT
                    3580   3588 ;Creates this routine on the stack, then executes
                    3581   3589 ;it, then returns through PCAHEX to print value
                    3582   3590 ;
                    3583   3591 ;    nop
                    3584   3592 ;    in   <PORT>
                    3585   3593 ;    ret
                    3586   3594 ;    <PCAHEX address for return>
                    3587   3595 ;*************************************************
f982  cd 97 fd      3588   3596 INCMD:	call	PCCOLS		;': ' as separator
                    3589   3597 
f985  11 ab fd      3590   3598 	lxi	d,PCAHEX	;create return address
f988  d5            3591   3599 	push	d		;ret through PCAHEX
                    3592   3600 
                    3593   3601 ;	mvi	h,RET		;opcode
f989  26 c9         3594   3602 	mvi	h,0C9H
f98b  e5            3595   3603 	push	h		;l=<PORT>
                    3596   3604 
                    3597   3605 ;	lxi	h,IN*256	;NOP, in opcodes
f98c  21 00 db      3598   3606 	lxi	h,0DBH*256
                    3599   3607 
f98f  c3 9b f9      3600   3608 	jmp	IOCMD		;recycle some code
                    3601   3609 
                    3602   3610 ;***Command Routine*********************************
                    3603   3611 ;OT <PORT> <data> (output to port)
                    3604   3612 ;
                    3605   3613 ;On Entry:
                    3606   3614 ;  l=PORT
                    3607   3615 ;  de points to data
                    3608   3616 ;
                    3609   3617 ;Creates this routine on the stack, then executes it
                    3610   3618 ;   NOP
                    3611   3619 ;   OUT  <PORT>
                    3612   3620 ;   RET
                    3613   3621 ;**************************************************
f992                3614   3622 OTCMD:
                    3615   3623 ;	mvi	h,RET		;ret opcode, l=PORT
f992  26 c9         3616   3624 	mvi	h,0C9H
                    3617   3625 
f994  cd 02 fd      3618   3626 	call	GETHEX		;push <PORT>, RET opcode
                    3619   3627 				;get l=<data>
                    3620   3628 
f997  7d            3621   3629 	mov	a,l		;port data
                    3622   3630 
                    3623   3631 ;	lxi	h,out*256	;NOP, out opcodes
f998  21 00 d3      3624   3632 	lxi	h,0D3H*256
                    3625   3633 
                    3626   3634 ;Fall into IOCMD
                    3627   3635 
                    3628   3636 ;--------------------
                    3629   3637 ;Recycle some code
                    3630   3638 ;On Entry:
                    3631   3639 ;  l=0
                    3632   3640 ;  h=IN or OUT opcode
                    3633   3641 ;--------------------
f99b  e5            3634   3642 IOCMD:	push	h		;install IN or OUT opcode
                    3635   3643 
                    3636   3644  if EXOPT
f99c  c3 ab f9      3637   3645 	jmp	EXSTK		;recycle some code
                    3638   3646  endif ;EXOPT
                    3639   3647 
                    3640   3648  if not EXOPT
                    3641   3649 	mov	h,l		;hl=0
                    3642   3650 	dad	sp		;hl points to routine
                    3643   3651 
                    3644   3652 	pop	d		;repair sp so that
                    3645   3653 	pop	d		;..we can return
                    3646   3654 
                    3647   3655 ;Fall into EXCMD to execute RAM routine at (hl)
                    3648   3656  endif ;not EXOPT
                    3649   3657 
                    3650   3658 ;***Command Routine******************************************
                    3651   3659 ;EX [<ADR> [<OPT>]](execute)
                    3652   3660 ;
                    3653   3661 ;EXOPT=TRUE adds <OPT> to optionally disable the EPROM on an
                    3654   3662 ;Altair-type board (such as on the Turnkey Module or my own
                    3655   3663 ;88-2SIOJP) on the way to executing at the requested address.
                    3656   3664 ;On Entry:
                    3657   3665 ;  hl=address, default to 0
                    3658   3666 ;  Carry set if none entered
                    3659   3667 ;  Top-of-stack has main address
                    3660   3668 ;************************************************************
                    3661   3669  if not EXOPT
                    3662   3670 EXCMD:	pchl
                    3663   3671  endif ;not EXOPT
                    3664   3672 
                    3665   3673  if EXOPT
f99f  cd a0 f8      3666   3674 EXCMD:	call	PHFHEX		;push <ADR>, get l=<OPT>
f9a2  2d            3667   3675 	dcr	l		;Anything but 1 just
f9a3  c0            3668   3676 	rnz			;..executes at <ADR>
                    3669   3677 
                    3670   3678 ;Fall into EXECDP
                    3671   3679 
                    3672   3680 ;***Subroutine****************************************
                    3673   3681 ;Execute 'IN FF' from RAM to disable PROM, then return
                    3674   3682 ;(Some boards disable PROM on any IN FF)
                    3675   3683 ;*****************************************************
f9a4                3676   3684 EXECDP:
                    3677   3685 ;	mvi	e,RET		;ret, don't care
f9a4  1e c9         3678   3686 	mvi	e,0C9H
f9a6  d5            3679   3687 	push	d
                    3680   3688 
f9a7  11 db ff      3681   3689 	lxi	d,0FFDBh	;IN FF opcode
f9aa  d5            3682   3690 	push	d
                    3683   3691 
                    3684   3692 ;Fall into EXSTK
                    3685   3693 
                    3686   3694 ;***Subroutine************
                    3687   3695 ;Execute code on the stack
                    3688   3696 ;*************************
f9ab  21 00 00      3689   3697 EXSTK:	lxi	h,0		;Find our RAM page to find
f9ae  39            3690   3698 	dad	sp		;..the code we just pushed
                    3691   3699 
f9af  d1            3692   3700 	pop	d		;restore stack
f9b0  d1            3693   3701 	pop	d
                    3694   3702 
f9b1  e9            3695   3703 	pchl			;execute the code we pushed
                    3696   3704  endif ;EXOPT
                    3697   3705 
                    3698   3706  if TPORT
                    3699   3707 ;***Command Routine****************************
                    3700   3708 ;TP [<0/1>] enable/disable Transfer Port
                    3701   3709 ;
                    3702   3710 ;0 means disabled (use Console), anything else
                    3703   3711 ;means Transfer Port enabled.
                    3704   3712 ;On Entry:
                    3705   3713 ;  l=enable state
                    3706   3714 ;  Top-of-stack=return address to MAIN
                    3707   3715 ;  next-on-stack=TP flag word
                    3708   3716 ;**********************************************
f9b2  7d            3709   3717 TPCMD:	mov	a,l		;get state
f9b3  21 03 00      3710   3718 	lxi	h,3		;TP flag is 3 back
f9b6  39            3711   3719 	dad	sp		;..on the stack
f9b7  77            3712   3720 	mov	m,a		;New state
                    3713   3721 
f9b8  c9            3714   3722 	ret
                    3715   3723  endif ;TPORT
                    3716   3724 
                    3717   3725 ;***Command Routine**********************************
                    3718   3726 ;DU [<ADR> [<BCNT>]] (dump memory)
                    3719   3727 ;
                    3720   3728 ;Print <BCNT> bytes of memory contents from <ADR> on
                    3721   3729 ;the Console in HEX.  If no count is specified, then
                    3722   3730 ;then print the contents of all memory, 10000h bytes.
                    3723   3731 ;Pause with the space bar, abort with control-C.
                    3724   3732 ;
                    3725   3733 ;On Entry:
                    3726   3734 ;  hl=address
                    3727   3735 ;  de points to <BCNT>, if anY
                    3728   3736 ;****************************************************
f9b9  cd a0 f8      3729   3737 DUCMD:	call	PHFHEX		;push address and
                    3730   3738 				;..get hl=byte count or 0
                    3731   3739 				;a=0
f9bc  8d            3732   3740 	adc	l		;carry set if none entered
f9bd  6f            3733   3741 	mov	l,a		;hl defaults to 1
                    3734   3742 
f9be  d1            3735   3743 	pop	d		;recover start address
f9bf  eb            3736   3744 	xchg			;hl has start, de has count
                    3737   3745 
                    3738   3746 ;Print the address at the beginning of each line
                    3739   3747 
f9c0  cd 90 fd      3740   3748 DULINE:	call	PHLADR		;print hl as an address
                    3741   3749 				;Trashes c, sets b=0
f9c3  48            3742   3750 	mov	c,b		;line byte counter=0
                    3743   3751 
                    3744   3752 ;Print up to 16 bytes of hex data
                    3745   3753 ;(separated by spaces) on each line
                    3746   3754 
f9c4  e5            3747   3755 	push	h		;save mem pointer for ASCII dump
                    3748   3756 
f9c5  7e            3749   3757 DULOOP:	mov	a,m
f9c6  cd ab fd      3750   3758 	call	PCAHEX		;chr to Console in hex, trash b
f9c9  0c            3751   3759 	inr	c		;line byte counter
                    3752   3760 
f9ca  cd 5d fd      3753   3761 	call	ILPRNT		;space separates bytes
f9cd  a0            3754   3762 	db	' '+80h
f9ce  23            3755   3763 	inx	h
                    3756   3764 
f9cf  1b            3757   3765 	dcx	d		;all done with DU data?
f9d0  7a            3758   3766 	mov	a,d
f9d1  b3            3759   3767 	ora	e
f9d2  ca db f9      3760   3768 	jz	DLDONE		;Y: print last ASCII too
                    3761   3769 
f9d5  3e 0f         3762   3770 	mvi	a,0Fh		;all done with row?
f9d7  a5            3763   3771 	ana	l		;new line Every XXX0 hex
f9d8  c2 c5 f9      3764   3772 	jnz	DULOOP
f9db                3765   3773 DLDONE:
                    3766   3774 
                    3767   3775  if DUPRTY
                    3768   3776 ;Pad out the rest of the line so that the ASCII lines up
                    3769   3777 ;for short lines. c=number of bytes printed so far
                    3770   3778 ;(This just makes the display a little prettier.)
                    3771   3779 
f9db  3e 10         3772   3780 	mvi	a,10h		;a full line has 16 bytes
f9dd  91            3773   3781 	sub	c		;how short is this line?
f9de  ca ec f9      3774   3782 	jz	DNOPAD		;No pading for full lines
                    3775   3783 
f9e1  47            3776   3784 	mov	b,a		;loop counter
                    3777   3785 
f9e2  cd 5d fd      3778   3786 DPLOOP:	call	ILPRNT
f9e5  20 20 a0      3779   3787 	db	'  ',' '+80h	;3 bytes per hex digit
f9e8  05            3780   3788 	dcr	b
f9e9  c2 e2 f9      3781   3789 	jnz	DPLOOP
f9ec                3782   3790 DNOPAD:
                    3783   3791  endif ;DUPRTY
                    3784   3792 
                    3785   3793 ;print up to 16 ASCII characters, or '.' if unprintable
                    3786   3794 
f9ec  e1            3787   3795 	pop	h		;recover this line's address
                    3788   3796 
f9ed  7e            3789   3797 ADLOOP:	mov	a,m		;get a character
f9ee  3c            3790   3798 	inr	a		;DEL (7Fh) is also non-printing
f9ef  e6 7f         3791   3799 	ani	7Fh		;strip high (parity) bit
f9f1  fe 21         3792   3800 	cpi	' '+1		;Everything below space
f9f3  d2 f8 f9      3793   3801 	jnc	PRNTBL		;..is non-printing
                    3794   3802 
f9f6  3e 2f         3795   3803 	mvi	a,'.'+1		;A dot for non-printing chr
                    3796   3804 
f9f8  3d            3797   3805 PRNTBL:	dcr	a		;undo inc
f9f9  cd c8 fd      3798   3806 	call	PRINTA
                    3799   3807 
f9fc  23            3800   3808 	inx	h		;next byte on this ROW
f9fd  0d            3801   3809 	dcr	c		;this line's byte count
f9fe  c2 ed f9      3802   3810 	jnz	ADLOOP
                    3803   3811 
fa01  7a            3804   3812 	mov	a,d		;all done with dump?
fa02  b3            3805   3813 	ora	e
fa03  c8            3806   3814 	rz			;done with DU command
                    3807   3815 	
                    3808   3816 ;Give the user a chance to break in at the end of each line.
                    3809   3817 ;Pause if anything except ^C typed. abort if ^C.
fa04  cd c1 fc      3810   3818 	call	CPAUSE
fa07  c3 c0 f9      3811   3819 	jmp	DULINE		;next line
                    3812   3820 
                    3813   3821 ;***Command Routine***************************************
                    3814   3822 ;HL [<OFST>] (Intel Hex Load)
                    3815   3823 ;
                    3816   3824 ;Load an Intel hex file from the Transfer Port into memory
                    3817   3825 ;AT the addresses specified in the hex file, with optional
                    3818   3826 ;address offset <OFST>. Ends with any record with 0 data
                    3819   3827 ;bytes, or if control-C is typed.
                    3820   3828 ;
                    3821   3829 ;HLRECS=TRUE adds record counting, with a report of the
                    3822   3830 ;total number of records received when done.
                    3823   3831 ;
                    3824   3832 ;ROM2K will enable RAM read-back test when writing to RAM
                    3825   3833 ;
                    3826   3834 ;On Entry:
                    3827   3835 ;  hl=offset (defaults to 0)
                    3828   3836 ;
                    3829   3837 ;Register usage during hex load:
                    3830   3838 ;  b: Scratch
                    3831   3839 ;  c: record byte count
                    3832   3840 ;  d: record checksum
                    3833   3841 ;  e: RAM page address
                    3834   3842 ;  hl: memory address
                    3835   3843 ;  top of stack: address offset
                    3836   3844 ;  Next on stack: Record count
                    3837   3845 ;*********************************************************
fa0a                3838   3846 HLCMD:
                    3839   3847 
                    3840   3848  if HLRECS
fa0a  11 00 00      3841   3849 	lxi	d,0		;initialize record count
fa0d  d5            3842   3850 	push	d		;keep it on the stack
                    3843   3851  endif ;HLRECS
                    3844   3852 
fa0e  e5            3845   3853 	push	h		;address offset onto stack
                    3846   3854 
                    3847   3855 ;Eat all chrs until we get record-start colon
                    3848   3856 
fa0f  cd 7c fd      3849   3857 GETCOL:	call	GETTPD
fa12  fe 3a         3850   3858 	cpi	':'
fa14  c2 0f fa      3851   3859 	jnz	GETCOL
                    3852   3860 
                    3853   3861 ;Restart checksum, then get 4-byte record header: (a=0 here)
                    3854   3862 ; c gets 1st byte=data byte count
                    3855   3863 ; h gets 2nd byte=address high byte
                    3856   3864 ; l gets 3rd byte=address low byte
                    3857   3865 ; b gets 4th byte=record type (ignored)
                    3858   3866 ; d computes checksum
                    3859   3867 
fa17  11 04 00      3860   3868 	lxi	d,4		;Initialize checksum in d
                    3861   3869 				;get e=4 header bytes
                    3862   3870 
                    3863   3871 ;Shift in the four header bytes: c <- h <- l <- b
                    3864   3872 
fa1a  4c            3865   3873 HLHDR:	mov	c,h		;c=byte 1: byte count
fa1b  65            3866   3874 	mov	h,l		;h=byte 2: address msb
fa1c  68            3867   3875 	mov	l,b		;l=byte 3: address lsb
fa1d  cd de fc      3868   3876 	call	GTPBYT		;get header byte, do checksum
fa20  1d            3869   3877 	dcr	e
fa21  c2 1a fa      3870   3878 	jnz	HLHDR
                    3871   3879 
                    3872   3880 ;Offset the record address by the value on top of the stack
                    3873   3881 ;a=checksum so far here
                    3874   3882 
fa24  d1            3875   3883 	pop	d		;get offset
                    3876   3884 
                    3877   3885  if HLRECS
fa25  e3            3878   3886 	xthl			;bump record count
fa26  23            3879   3887 	inx	h
fa27  e3            3880   3888 	xthl
                    3881   3889  endif ;HLRECS
                    3882   3890 
fa28  19            3883   3891 	dad	d		;offset the address
fa29  d5            3884   3892 	push	d		;save offset
                    3885   3893 
                    3886   3894  if RAMCOD			;Running in low memory?
                    3887   3895 	push	h
                    3888   3896 	lxi	d,-CODEND	;Wipe out Memon/80?
                    3889   3897 	dad	d		;16-bit compare
                    3890   3898 	pop	h
                    3891   3899 	jnc	OVMERR		;y: error
                    3892   3900  endif ;RAMCOD
                    3893   3901 
fa2a  57            3894   3902 	mov	d,a		;d=checksum so far
                    3895   3903 
                    3896   3904 ;c=byte count
                    3897   3905 ;d=checksum so far
                    3898   3906 ;hl=RAM address for this record=record address+offset
                    3899   3907 
                    3900   3908 ;Test for 0-byte record, which is the EOF
                    3901   3909 
fa2b  79            3902   3910 	mov	a,c		;c=byte count
fa2c  b7            3903   3911 	ora	a		;0-byte record?
fa2d  ca 4a fa      3904   3912 	jz	GETCSM		;Y: done
                    3905   3913 
                    3906   3914 ;Get e=RAM page address to test for overwriting. this
                    3907   3915 ;bocks out a 256-byte region of memory Wherever this
                    3908   3916 ;program found RAM for its stack.
                    3909   3917 
                    3910   3918  if RAMHNT
fa30  e5            3911   3919 	push	h
fa31  cd b3 fa      3912   3920 	call	RAMPAG		;get h=RAM page
fa34  5c            3913   3921 	mov	e,h
fa35  e1            3914   3922 	pop	h
                    3915   3923  endif ;RAMHNT
                    3916   3924 
                    3917   3925  if not RAMHNT
                    3918   3926 	mvi	e,RAMEND/256
                    3919   3927  endif ;not RAMHNT
                    3920   3928 
                    3921   3929 ;Loop to get data into memory at hl.
                    3922   3930 
fa36  7c            3923   3931 HLLOOP:	mov	a,h		;overwrite our RAM?
fa37  bb            3924   3932 	cmp	e
fa38  ca 25 fc      3925   3933 	jz	OVMERR		;Y: abort load
                    3926   3934 
fa3b  cd de fc      3927   3935 	call	GTPBYT		;data byte in b, cksum in d
fa3e  70            3928   3936 	mov	m,b
                    3929   3937 
                    3930   3938  if ROM2K
fa3f  78            3931   3939 	mov	a,b		;readback compare
fa40  be            3932   3940 	cmp	m		;successful write?
fa41  c2 2e fc      3933   3941 	jnz	MEMERR		;N: error
                    3934   3942  endif ;ROM2K
                    3935   3943 
fa44  23            3936   3944 	inx	h
fa45  0d            3937   3945 	dcr	c
fa46  c2 36 fa      3938   3946 	jnz	HLLOOP
                    3939   3947 
fa49  0c            3940   3948 	inr	c		;remember >0 data bytes
                    3941   3949 
                    3942   3950 ;Get and test record checksum
                    3943   3951 
fa4a  cd de fc      3944   3952 GETCSM:	call	GTPBYT		;get checksum in Z
fa4d  c2 1c fc      3945   3953 	jnz	CSMERR		;NZ means checksum error
                    3946   3954 
                    3947   3955 ;All done with this record. Check its data byte count
                    3948   3956 ;On Entry: c=0 for 0-byte record, c=1 otherwise
                    3949   3957 
fa50  cd 5d fd      3950   3958 	call	ILPRNT		;pacifier on Console
fa53  ae            3951   3959 	db	PCFIER+80h
                    3952   3960 
fa54  0d            3953   3961 	dcr	c		;0-byte record?
fa55  ca 0f fa      3954   3962 	jz	GETCOL		;N: go get another record
                    3955   3963 
fa58  e1            3956   3964 	pop	h		;remove offset from stack
                    3957   3965 
                    3958   3966  if HLRECS
fa59  e1            3959   3967 	pop	h		;record count
fa5a  cd 59 fd      3960   3968 	call	 CILPRT
fa5d  52 65 63 73   3961   3969 	db	'Recs:',' '+80h
fa61  3a a0         3961   3970
fa63  c3 9d fd      3962   3971 	jmp	PHLCHX		;hl in hex on Console
                    3963   3972  endif ;HLRECS
                    3964   3973 
                    3965   3974  if not HLRECS
                    3966   3975 	ret			;done:return to MAIN
                    3967   3976  endif ;not HLRECS
                    3968   3977 
                    3969   3978 ;***Command Routine********************
                    3970   3979 ;VE <SRC> <DST> <BCNT> (verify memory)
                    3971   3980 ;
                    3972   3981 ;Compare <BCNT> bytes of memory from
                    3973   3982 ;<SRC> to <DST> and report differences
                    3974   3983 ;On Entry:
                    3975   3984 ;  hl=<SRC>
                    3976   3985 ;  carry set if none entered
                    3977   3986 ;  de points to <DST>, <BCNT> follows
                    3978   3987 ;*************************************
fa66  cd fe fc      3979   3988 VECMD:	call	GETHX2		;save source address
                    3980   3989 				;get & save destination
                    3981   3990 				;get byte count
                    3982   3991 
fa69  e5            3983   3992 	push	h		;save byte count
                    3984   3993 
fa6a  c3 98 fa      3985   3994 	jmp	VERIFY		;actually verify
                    3986   3995 
                    3987   3996 ;***command Routine Continuation****************
                    3988   3997 ;CO <SRC> <DST> <BCNT> [<RPT>](copy memory)
                    3989   3998 ; (RPT only available if CORPT is TRUE)
                    3990   3999 ;
                    3991   4000 ;Copy <BCNT> bytes of memory from <SRC> to <DST>
                    3992   4001 ;repeat <RPT> times (for EPROM programming)
                    3993   4002 ;On Entry:
                    3994   4003 ;  hl=<SRC>
                    3995   4004 ;  carry set if none entered
                    3996   4005 ;  de points to <DST>, <BCNT>, <RPT> follow
                    3997   4006 ;***********************************************
fa6d  cd fe fc      3998   4007 COCMD:	call	GETHX2		;save source address
                    3999   4008 				;get & save destination
                    4000   4009 				;get byte count
                    4001   4010 
                    4002   4011 
                    4003   4012  if CORPT
fa70  cd 59 fd      4004   4013 	call	CILPRT
fa73  43 6f 70 79   4005   4014 	db	'Copyin','g'+80h
fa77  69 6e e7      4005   4015
                    4006   4016 
fa7a  cd a0 f8      4007   4017 	call	PHFHEX		;push byte count and
                    4008   4018 				;..get repeat count
fa7d  8d            4009   4019 	adc	l		;On ret, a=0
                    4010   4020 				;carry set if no value given
                    4011   4021 
                    4012   4022 ;Repeat copy the specified number of times (for
                    4013   4023 ;programming an EPROM, e.g. a 2708 on a bytesaver)
                    4014   4024 
fa7e                4015   4025 CORLUP:
                    4016   4026  endif ;CORPT
                    4017   4027 
fa7e  c1            4018   4028 	pop	b		;bc=count
fa7f  d1            4019   4029 	pop	d		;de=destination
fa80  e1            4020   4030 	pop	h		;hl=source
                    4021   4031 
fa81  e5            4022   4032 	push	h		;save source
fa82  d5            4023   4033 	push	d		;save destination
fa83  c5            4024   4034 	push	b		;save count
                    4025   4035 
                    4026   4036  if CORPT
fa84  f5            4027   4037 	push	psw		;save a=repeat count
                    4028   4038  endif ;CORPT
                    4029   4039 
                    4030   4040 ;Loop to copy bc bytes from (hl) to (de)
                    4031   4041 
fa85  7e            4032   4042 COLOOP:	mov	a,m
fa86  12            4033   4043 	staX	d
fa87  23            4034   4044 	inx	h
fa88  13            4035   4045 	inx	d
fa89  0b            4036   4046 	dcx	b
fa8a  78            4037   4047 	mov	a,b
fa8b  b1            4038   4048 	ora	c
fa8c  c2 85 fa      4039   4049 	jnz	COLOOP
                    4040   4050 
                    4041   4051  if CORPT
                    4042   4052 ;Repeat the copy as requested by the user
                    4043   4053 
fa8f  cd 5d fd      4044   4054 	call	ILPRNT		;pacifier on Console
fa92  ae            4045   4055 	db	PCFIER+80h
                    4046   4056 
fa93  f1            4047   4057 	pop	psw		;recover repeat count
                    4048   4058 
fa94  3d            4049   4059 	dcr	a		;repeat as requested
fa95  c2 7e fa      4050   4060 	jnz	CORLUP
                    4051   4061  endif ;CORPT
                    4052   4062 
                    4053   4063 ;Fall into VERIFY to verify the copy
                    4054   4064 
                    4055   4065 ;***Subroutine End***********************
                    4056   4066 ;Verify memory. Report errors to Console.
                    4057   4067 ;On Entry:
                    4058   4068 ;  top of stack=byte count
                    4059   4069 ;  next on stack=destination address
                    4060   4070 ;  next on stack - source address
                    4061   4071 ;  next on stack=return address (to MAIN)
                    4062   4072 ;****************************************
fa98  c1            4063   4073 VERIFY:	pop	b		;byte count
fa99  d1            4064   4074 	pop	d		;de=destination
fa9a  e1            4065   4075 	pop	h		;hl=source
                    4066   4076 
                    4067   4077  if CORPT
fa9b  cd 59 fd      4068   4078 	call	CILPRT
fa9e  63 68 65 63   4069   4079 	db	'checkin','g'+80h
faa2  6b 69 6e e7   4069   4080
                    4070   4081  endif ;CORPT
                    4071   4082 
                    4072   4083 ;Loop to compare memory, reporting mismatches
                    4073   4084 
faa6  1a            4074   4085 VELOOP:	ldax	d
faa7  be            4075   4086 	cmp	m		;match?
faa8  c4 ad fc      4076   4087 	cnz	VERROR		;N:done
                    4077   4088 
faab  23            4078   4089 	inx	h
faac  13            4079   4090 	inx	d
faad  0b            4080   4091 	dcx	b
faae  78            4081   4092 	mov	a,b
faaf  b1            4082   4093 	ora	c
fab0  c2 a6 fa      4083   4094 	jnz	VELOOP
                    4084   4095 
                    4085   4096 ;Fall into RAMPAG to save a byte on the way
                    4086   4097 ;TO returning to MAIN
                    4087   4098 
                    4088   4099 ;***Subroutine********************
                    4089   4100 ;Get high byte of RAM page address
                    4090   4101 ;On Entry:
                    4091   4102 ;  sp is valid
                    4092   4103 ;On Exit:
                    4093   4104 ;  h=RAM page
                    4094   4105 ;Trashes l
                    4095   4106 ;*********************************
                    4096   4107  if RAMHNT
fab3  21 00 00      4097   4108 RAMPAG:	lxi	h,0
fab6  39            4098   4109 	dad	sp
                    4099   4110  endif ;RAMHNT
                    4100   4111 
fab7  c9            4101   4112 	ret
                    4102   4113 
                    4103   4114 ;***ROM2K Command Routine Continuation*****************
                    4104   4115 ;CE [command line] 
                    4105   4116 ;
                    4106   4117 ;Execute CP/M program
                    4107   4118 ; 1. Move command line into COMBUF
                    4108   4119 ; 2. Install WBOOT jump at 0
                    4109   4120 ; 3. Jump to USAREA
                    4110   4121 ;On Entry:
                    4111   4122 ;  de=points to the 1st chr in RAMBUF past the 'CE' cmd
                    4112   4123 ;  top-of-stack points to MAIN
                    4113   4124 ;******************************************************
                    4114   4125  if ROM2K
                    4115   4126 
fab8                4116   4127 GCECMD:
                    4117   4128 
                    4118   4129 ;Copy null-terminated command line to CP/M's
                    4119   4130 ;command line buffer
                    4120   4131 
fab8  21 80 00      4121   4132 	lxi	h,COMBUF
fabb  e5            4122   4133 	push	h
fabc  06 ff         4123   4134 	mvi	b,0FFh		;chr count (minus null term)
                    4124   4135 
fabe  23            4125   4136 CLLOOP:	inx	h
fabf  1a            4126   4137 	ldax	d
fac0  77            4127   4138 	mov	m,a
fac1  13            4128   4139 	inx	d
fac2  04            4129   4140 	inr	b		;count chrs
                    4130   4141 
fac3  b7            4131   4142 	ora	a		;copy 'till null termination
fac4  c2 be fa      4132   4143 	jnz	CLLOOP
                    4133   4144 
fac7  e1            4134   4145 	pop	h		;install chr count
fac8  70            4135   4146 	mov	m,b		;..at 1st position in buffer
                    4136   4147 
                    4137   4148 ;Install WBOOT jump at 0
                    4138   4149 ;a=0 here
                    4139   4150 
fac9  6f            4140   4151 	mov	l,a		;hl=0
                    4141   4152 ;	mvi	m,JMP
faca  36 c3         4142   4153 	mvi	m,0C3H
                    4143   4154 
facc  21 03 f8      4144   4155 	lxi	h,MEWARM
facf  22 01 00      4145   4156 	shld	WBOOTA
                    4146   4157 
                    4147   4158 ;Execute
                    4148   4159 
fad2  c3 00 01      4149   4160 	jmp	USAREA
                    4150   4161  endif ;ROM2K
                    4151   4162 
                    4152   4163 ;***ROM2K Command Routine Continuation*********
                    4153   4164 ;TB <BAUD> 
                    4154   4165 ;
                    4155   4166 ;Set and announce the Transfer Port's baud Rate
                    4156   4167 ;(Only available for serial port boards with
                    4157   4168 ;software-set baud rates)
                    4158   4169 ;On Entry:
                    4159   4170 ;  l=<BAUD>
                    4160   4171 ;**********************************************
                    4161   4172  if TSBAUD and ROM2K
                    4162   4173 
                    4163   4174 GTBCMD:	jc	CMDERR		;Must supply baud rate
                    4164   4175 
                    4165   4176 ;Look up entry in baud rate table
                    4166   4177 
                    4167   4178 	mov	a,l		;User selection
                    4168   4179 	add	a		;Table has 4 bytes
                    4169   4180 	add	a		;..per entry
                    4170   4181 	cpi	BTEND-BTABLE
                    4171   4182 	jnc	CMDERR
                    4172   4183 
                    4173   4184 	mov	c,a		;c=selection*4 (0 for 110 baud)
                    4174   4185 	mvi	b,0
                    4175   4186 	lxi	h,BTABLE
                    4176   4187 	dad	b		;hl points to entry
                    4177   4188 
                    4178   4189 ;Get c=BRATE0 and m=BRATE1 from the table. check
                    4179   4190 ;for unsupported baud rate (BRATE0 & BRATE1 are 0)
                    4180   4191 ;b=0
                    4181   4192 
                    4182   4193 	mov	d,m		;Value for BRATE0
                    4183   4194 	inx	h
                    4184   4195 
                    4185   4196 	mov	a,m		;value for BRATE1
                    4186   4197 	ora	d
                    4187   4198 	jz	CMDERR
                    4188   4199 
                    4189   4200 ;Set baud rate, and set the stop bits to 1
                    4190   4201 ;except for 110 baud, which gets 2 stop bits
                    4191   4202 ;b=0
                    4192   4203 
                    4193   4204  endif ;TSBAUD and ROM2K
                    4194   4205 
                    4195   4206  if TSBAUD and ROM2K and (TC2718A or TC2718B)
                    4196   4207 ;Both CCS2718 serial ports use the same I/O port for
                    4197   4208 ;setting their baud rates. Here, we combine the fixed
                    4198   4209 ;Console baud rate (if any) with the new transfer port
                    4199   4210 ;baud rate.
                    4200   4211 	mvi	a,CBD18 and 0FFh ;default Console baud
                    4201   4212 	ora	d		;new baud rate
                    4202   4213 	out	BASE18
                    4203   4214  endif ;TSBAUD and ROM2K and (TC2718A or TC2718B)
                    4204   4215 
                    4205   4216  if TSBAUD and ROM2K and (TIVIO2)
                    4206   4217 ;Reset mode byte flipflop before setting baud rate
                    4207   4218 
                    4208   4219 	in	TCTRL		;reset mode byte flipflop
                    4209   4220 
                    4210   4221 	mov	a,m 		;stop bits, etc,
                    4211   4222 	out	BRATE1		;<MR17:MR10>
                    4212   4223 
                    4213   4224 	mov	a,d		;baud rate
                    4214   4225 	out	BRATE0		;<MR27:MR20>
                    4215   4226 
                    4216   4227  endif ;TSBAUD and ROM2K and (TIVIO2)
                    4217   4228 
                    4218   4229  if TSBAUD and ROM2K and T5511
                    4219   4230 ;Stop bits are encoded with the baud rates.
                    4220   4231 
                    4221   4232 	mov	a,m
                    4222   4233 	out	BRATE1		;Divisor high byte
                    4223   4234 	mov	a,d
                    4224   4235 	out	BRATE0		;Divisor low byte
                    4225   4236  endif ;TSBAUD and ROM2K and T5511
                    4226   4237 
                    4227   4238  if TSBAUD and ROM2K and TMRCTC
                    4228   4239 	mvi	a,DWR4		;point to DART
                    4229   4240 	out	TCTRL		;..write register 4
                    4230   4241 
                    4231   4242 	mov	a,c		;110 baud (c=0)?
                    4232   4243 	ora	a
                    4233   4244 	mvi	a,DART1S	;1 stop bit
                    4234   4245 	jnz	TBC1
                    4235   4246 	mvi	a,DART2S	;110 baud gets 2 stop bits
                    4236   4247 TBC1:	out	TCTRL		;set the DART stop bits
                    4237   4248 
                    4238   4249 	mov	a,m
                    4239   4250 	out	BRATE1		;CTC Divisor high byte
                    4240   4251 				;(must be 1st)
                    4241   4252 	mov	a,d
                    4242   4253 	out	BRATE0		;CTC Divisor low byte
                    4243   4254  endif ;TSBAUD and ROM2K and TMRCTC
                    4244   4255 
                    4245   4256  if TSBAUD and ROM2K and T8250
                    4246   4257 	mov	a,c		;110 baud (c=0)?
                    4247   4258 	ora	a
                    4248   4259 	mvi	a,TDLAB or TSTOP1 ;baud rate access, 1 stop bit
                    4249   4260 	jnz	TBC1
                    4250   4261 	mvi	a,TDLAB or TSTOP2 ;110 baud gets 2 stop bits
                    4251   4262 TBC1:	out	TSLCTRL
                    4252   4263 	mov	e,a		;temp save
                    4253   4264 
                    4254   4265 	mov	a,m
                    4255   4266 	out	BRATE1		;Baud rate divisor high byte
                    4256   4267 	mov	a,d
                    4257   4268 	out	BRATE0		;Baud rate divisor low byte
                    4258   4269 
                    4259   4270 	mov	a,e		;stop pointing to divisor
                    4260   4271 	xri	TDLAB
                    4261   4272 	out	TSLCTRL
                    4262   4273 
                    4263   4274  endif ;TSBAUD and ROM2K and T8250
                    4264   4275 
                    4265   4276  if TSBAUD and ROM2K
                    4266   4277 
                    4267   4278 ;Print resulting baud rate, using BCD from BTABLE,
                    4268   4279 ;suppressing up to 2 leading zeros, and appending
                    4269   4280 ;a 0. b=0 here (for PAHEX1)
                    4270   4281 
                    4271   4282 	call	CILPRT
                    4272   4283 	db	CR+80h
                    4273   4284 
                    4274   4285 	inx	h	;point to the rate BCD
                    4275   4286 
                    4276   4287 	mov	a,m
                    4277   4288 
                    4278   4289 	rrc		;high nibble
                    4279   4290 	rrc
                    4280   4291 	rrc
                    4281   4292 	rrc
                    4282   4293 	ani	0Fh	;Leading 0 to suppress?
                    4283   4294 	cnz	PAHEX1	;n: print it
                    4284   4295 
                    4285   4296 	mov	a,m
                    4286   4297 	ora	a	;2 leading 0s to suppress?
                    4287   4298 	cnz	PAHEX1	;(Strips off high nibble)
                    4288   4299 
                    4289   4300 	inx	h	;low byte
                    4290   4301 	mov	a,m
                    4291   4302 	call	PAHEX2	;..always gets printed
                    4292   4303 
                    4293   4304 	call	ILPRNT
                    4294   4305 	db	'0 Bau','d'+80h
                    4295   4306 
                    4296   4307 	ret
                    4297   4308  endif ;TSBAUD and ROM2K
                    4298   4309 
                    4299   4310 ;***ROM2K Command Routine Continuation**************
                    4300   4311 ;SE <ADR> <byte1> [<byte2> [<byten>]]]
                    4301   4312 ;
                    4302   4313 ;    Search for string of bytes, starting at <ADR>
                    4303   4314 ;    <byten> can be either hex byte or 'text string'
                    4304   4315 ;
                    4305   4316 ;On Entry:
                    4306   4317 ;  hl=<ADR>
                    4307   4318 ;  Carry set if none entered
                    4308   4319 ;  de points to <bytes>
                    4309   4320 ;***************************************************
                    4310   4321  if ROM2K
fad5  e5            4311   4322 GSECMD:	push	h		;remember <ADR>
                    4312   4323 
                    4313   4324 ;Get search string from input buffer, convert each byte
                    4314   4325 ;to binary, and save result in the RAM buffer
                    4315   4326  endif ;ROM2K
                    4316   4327 
                    4317   4328  if RAMHNT and ROM2K
fad6  cd b3 fa      4318   4329 	call	RAMPAG		;Find our line buffer
fad9  2e b0         4319   4330 	mvi	l,RAMBUF	;Overwrite with converted data		
                    4320   4331  endif ;RAMHNT and ROM2K
                    4321   4332 
                    4322   4333  if not RAMHNT and ROM2K
                    4323   4334 	lxi	h,RAMBUF
                    4324   4335  endif ;not RAMHNT and ROM2K
                    4325   4336 
                    4326   4337  if ROM2K
                    4327   4338 
fadb  e5            4328   4339 	push	h		;binary string address
fadc  01 27 00      4329   4340 	lxi	b,QUOTE		;b=byte count, c=QUOTE
                    4330   4341 	
                    4331   4342 ;--------------------------------------
                    4332   4343 ;Loop to get either a 2-digit hex value
                    4333   4344 ;or a text string (in quotes) each pass
                    4334   4345 ;--------------------------------------
fadf  cd 28 fd      4335   4346 SCHLUP:	call	SSPACE		;returns a=found chr, 0 if none
                    4336   4347 
fae2  b9            4337   4348 	cmp	c		;is 1st chr a quote?
fae3  cc 47 fb      4338   4349 	cz	SSTRNG		;y:search for a string
fae6  c4 54 fb      4339   4350 	cnz	SCHHEX		;n: search for hex
                    4340   4351 				;returns carry set if end
fae9  d2 df fa      4341   4352 	jnc	SCHLUP		;loop to get all input
                    4342   4353 
                    4343   4354 ;----------------------------------------	
                    4344   4355 ;Search RAM for the requested string
                    4345   4356 ; b=string length
                    4346   4357 ; top-of-stack=binary string address
                    4347   4358 ; next-on-stack=starting search address
                    4348   4359 ;----------------------------------------
faec  d1            4349   4360 	pop	d		;binary string address
faed  e1            4350   4361 	pop	h		;search start address
                    4351   4362 
faee  78            4352   4363 	mov	a,b		;anything to search for?
faef  b7            4353   4364 	ora	a
faf0  ca 07 fd      4354   4365 	jz	CMDERR		;error if not
                    4355   4366 
faf3  e5            4356   4367 SLOOP1:	push	h		;search start address
faf4  d5            4357   4368 	push	d		;binary string address
                    4358   4369 
faf5  48            4359   4370 	mov	c,b		;string byte count
                    4360   4371 
                    4361   4372 ;Loop through all bytes of the requested string
                    4362   4373 ;until either all bytes match or 1st non-matching byte
                    4363   4374 
faf6  7a            4364   4375 SLOOP2:	mov	a,d
faf7  bc            4365   4376 	cmp	h		;don't search our own RAM page
faf8  ca 32 fb      4366   4377 	jz	NOMTCH
                    4367   4378 
fafb  1a            4368   4379 	ldax	d		;search string
fafc  be            4369   4380 	cmp	m		;current RAM
fafd  c2 32 fb      4370   4381 	jnz	NOMTCH
                    4371   4382 
fb00  23            4372   4383 	inx	h		;test next byte
fb01  13            4373   4384 	inx	d
fb02  0d            4374   4385 	dcr	c		;tested all bytes yet?
fb03  c2 f6 fa      4375   4386 	jnz	SLOOP2
                    4376   4387 
                    4377   4388 ;String match found. Print address, ask to continue search
                    4378   4389 
fb06  d1            4379   4390 	pop	d		;binary string address
fb07  e1            4380   4391 	pop	h		;search start address
                    4381   4392 
fb08  cd 59 fd      4382   4393 	call	CILPRT
fb0b  46 6f 75 6e   4383   4394 	db	'Found',' '+80h
fb0f  64 a0         4383   4395
fb11  c5            4384   4396 	push	b
fb12  cd 9d fd      4385   4397 	call	PHLCHX		;print match address, trash bc
fb15  c1            4386   4398 	pop	b
                    4387   4399 
fb16  cd 59 fd      4388   4400 	call	CILPRT
fb19  4d 6f 72 65   4389   4401 	db	'More (Y/N)?',' '+80h
fb1d  20 28 59 2f   4389   4402
fb21  4e 29 3f a0   4389   4403
                    4390   4404 
fb25  cd c5 fc      4391   4405 	call	GETKBD		;user response
fb28  cd c8 fd      4392   4406 	call	PRINTA		;echo
                    4393   4407  endif ;ROM2K
                    4394   4408 
                    4395   4409  if ROM2K and LOWERC
fb2b  e6 df         4396   4410 	ani	('y'-'Y') XOR 0FFh	;make it uppercase
                    4397   4411  endif ;ROM2K and LOWERC
                    4398   4412 
                    4399   4413  if ROM2K
fb2d  fe 59         4400   4414 	cpi	'Y'
fb2f  c0            4401   4415 	rnz			;anything but y ends
                    4402   4416 
fb30  e5            4403   4417 	push	h		;search start address
fb31  d5            4404   4418 	push	d		;binary string address
                    4405   4419 
                    4406   4420 ;Search again, starting at the next byte after hl.
                    4407   4421 ;Quit if we've reached the end of memory, FFFFh
                    4408   4422 
fb32  d1            4409   4423 NOMTCH:	pop	d		;binary string address
fb33  e1            4410   4424 	pop	h		;search start address
                    4411   4425 
fb34  23            4412   4426 	inx	h		;next RAM
fb35  7c            4413   4427 	mov	a,h
fb36  b5            4414   4428 	ora	l		;End of memory?
fb37  c2 f3 fa      4415   4429 	jnz	SLOOP1
                    4416   4430 
fb3a  cd 59 fd      4417   4431 	call	CILPRT
fb3d  4e 6f 74 20   4418   4432 	db	'Not foun','d'+80h
fb41  66 6f 75 6e   4418   4433
fb45  e4            4418   4434
                    4419   4435 
fb46  c9            4420   4436 	ret
                    4421   4437 
                    4422   4438 ;---Local Subroutine-----------------------
                    4423   4439 ;Get a text string from user input at (de),
                    4424   4440 ;store string at (hl), bump count in b
                    4425   4441 ;On Entry:
                    4426   4442 ;  b=byte count
                    4427   4443 ;  c=QUOTE
                    4428   4444 ;  de points to initial quote
                    4429   4445 ;  hl points to destintion for binary
                    4430   4446 ;On Exit:
                    4431   4447 ;  b=b+number of string chrs
                    4432   4448 ;  de incremented past the string, and past
                    4433   4449 ;      the terminating quote, if it's there
                    4434   4450 ;  hl incremented for each string chr
                    4435   4451 ;  Z set
                    4436   4452 ;  Carry clear
                    4437   4453 ;------------------------------------------
fb47  13            4438   4454 SSTRNG:	inx	d		;skip over quote
                    4439   4455 
fb48  1a            4440   4456 STLOOP:	ldax	d
fb49  b7            4441   4457 	ora	a		;end quote is not required
fb4a  c8            4442   4458 	rz	
                    4443   4459 
fb4b  13            4444   4460 	inx	d		;point past this input chr
                    4445   4461 
fb4c  b9            4446   4462 	cmp	c		;end of string?
fb4d  c8            4447   4463 	rz	
                    4448   4464 
fb4e  77            4449   4465 	mov	m,a		;store a string byte
fb4f  23            4450   4466 	inx	h
fb50  04            4451   4467 	inr	b
                    4452   4468 
fb51  c3 48 fb      4453   4469 	jmp	STLOOP		;get more of this string
                    4454   4470 
                    4455   4471 ;---Local Subroutine-------------------------------
                    4456   4472 ;Get one hex value from user input at (de), convert
                    4457   4473 ;it to binary, store it at (hl), bump count in b
                    4458   4474 ;On Entry:
                    4459   4475 ;  b=byte count
                    4460   4476 ;  de points to next inut chr
                    4461   4477 ;  hl points to destintion for binary
                    4462   4478 ;On Exit:
                    4463   4479 ;  b=b+1 if hex byte found
                    4464   4480 ;  de incremented past the hex byte, if found
                    4465   4481 ;  hl incremented once of hex found
                    4466   4482 ;  Carry set if no hex digit found
                    4467   4483 ;--------------------------------------------------
fb54  cd a0 f8      4468   4484 SCHHEX:	call	PHFHEX		;push next string addr byte,
                    4469   4485 				;..and get a hex value.
                    4470   4486 				;hl=0 & carry set if none
                    4471   4487 
fb57  24            4472   4488 	inr	h		;no high byte allowed
fb58  25            4473   4489 	dcr	h		;does not change carry
fb59  c2 07 fd      4474   4490 	jnz	CMDERR
                    4475   4491 
fb5c  7d            4476   4492 	mov	a,l		;binary value from hex
fb5d  e1            4477   4493 	pop	h		;next string address byte
                    4478   4494 
fb5e  d8            4479   4495 	rc			;carry set means end of input
                    4480   4496 
fb5f  77            4481   4497 	mov	m,a		;store the hex digit
fb60  23            4482   4498 	inx	h
fb61  04            4483   4499 	inr	b
                    4484   4500 
fb62  c9            4485   4501 	ret
                    4486   4502  endif ;ROM2K
                    4487   4503 
                    4488   4504 ;***ROM2K Command Routine Continuation*************
                    4489   4505 ;MT [<ADR> [<CNT>]] (Test Memory)
                    4490   4506 ;
                    4491   4507 ;On Entry:
                    4492   4508 ;  Carry set if no parameters provided
                    4493   4509 ;  hl=<ADR>
                    4494   4510 ;  de points to <CNT>
                    4495   4511 ;**************************************************
                    4496   4512  if ROM2K
fb63                4497   4513 GMTCMD:
                    4498   4514  endif ;ROM2K
                    4499   4515 
                    4500   4516  if RAMCOD and ROM2K		;Running in low memory?
                    4501   4517 	push	h
                    4502   4518 	lxi	b,-CODEND	;Wipe out Memon/80?
                    4503   4519 	dad	b		;16-bit compare
                    4504   4520 	pop	h
                    4505   4521 	jnc	CMDERR		;y: error
                    4506   4522  endif ;RAMCOD and ROM2K
                    4507   4523 
                    4508   4524  if ROM2K
fb63  cd a0 f8      4509   4525 	call	PHFHEX		;push <ADR>, get hl=<CNT>
                    4510   4526 				;hl=0 if none entered
fb66  cd 59 fd      4511   4527 	call	CILPRT
fb69  54 65 73 74   4512   4528 	db	'Testin','g'+80h
fb6d  69 6e e7      4512   4529
                    4513   4530 
fb70  eb            4514   4531 	xchg			;de=byte count
                    4515   4532  endif ;ROM2K
                    4516   4533 
                    4517   4534  if RAMHNT and ROM2K
fb71  cd b3 fa      4518   4535 	call	RAMPAG		;get RAM page
fb74  7c            4519   4536 	mov	a,h		;a=RAM page
                    4520   4537  endif ;RAMHNT and ROM2K
                    4521   4538 
                    4522   4539  if not RAMHNT and ROM2K
                    4523   4540 	mvi	a,RAMEND/256
                    4524   4541  endif ;not RAMHNT and ROM2K
                    4525   4542 
                    4526   4543  if ROM2K
                    4527   4544 
fb75  e1            4528   4545 	pop	h		;hl=start address
                    4529   4546 
fb76  01 fe fb      4530   4547 	lxi	b,MTPAT		;Test pattern sequence
                    4531   4548 
                    4532   4549 ;Loop until all memory locations have seen each pattern byte
                    4533   4550 
fb79  e5            4534   4551 MTLOOP:	push	h		;Start address
fb7a  d5            4535   4552 	push	d		;Byte count
fb7b  c5            4536   4553 	Push	b		;Pattern position
fb7c  f5            4537   4554 	push	psw		;a=RAM page
                    4538   4555 	
                    4539   4556 ;------------------------------------------------
                    4540   4557 ;Fill memory with pattern, avoiding the stack. Do
                    4541   4558 ;a read/invert/write twice to stress the memory.
                    4542   4559 ;------------------------------------------------
fb7d  f1            4543   4560 FIL0:	pop	psw		;a=RAM page address
fb7e  f5            4544   4561 	push	psw
                    4545   4562 
fb7f  bc            4546   4563 	cmp	h		;On RAM page?
fb80  c2 89 fb      4547   4564 	jnz	FIL1
                    4548   4565 
fb83  7d            4549   4566 	mov	a,l		;y: stack part of RAM page?
fb84  fe 8f         4550   4567 	cpi	RAMBEG and 0FFh	;Can't test above the stack
fb86  d2 99 fb      4551   4568 	jnc	FIL3
                    4552   4569 
fb89  0a            4553   4570 FIL1:	ldax	b		;Get a pattern byte
                    4554   4571 
fb8a  b7            4555   4572 	ora	a		;Pattern end?
fb8b  c2 91 fb      4556   4573 	jnz	FIL2
fb8e  01 fe fb      4557   4574 	lxi	b,MTPAT		;y: restart pattern
                    4558   4575 
fb91  03            4559   4576 FIL2:	inx	b
                    4560   4577 
                    4561   4578 ;High-frequency memory byte test while
                    4562   4579 ;we fill memory with the pattern
                    4563   4580 
fb92  77            4564   4581 	mov	m,a		;Write pattern to memory
                    4565   4582 
fb93  7e            4566   4583 	mov	a,m		;Invert & write
fb94  2f            4567   4584 	cma
fb95  77            4568   4585 	mov	m,a
                    4569   4586 
fb96  7e            4570   4587 	mov	a,m		;twice
fb97  2f            4571   4588 	cma
fb98  77            4572   4589 	mov	m,a
                    4573   4590 
fb99  23            4574   4591 FIL3:	inx	h		;next address
                    4575   4592 
fb9a  1b            4576   4593 	dcx	d		;byte count
fb9b  7a            4577   4594 	mov	a,d		;end?
fb9c  b3            4578   4595 	ora	e
fb9d  c2 7d fb      4579   4596 	jnz	FIL0		;n: keep filling
                    4580   4597 
fba0  f1            4581   4598 	pop	psw		;a=RAM page address
fba1  c1            4582   4599 	pop	b		;Pattern position
fba2  d1            4583   4600 	pop	d		;Byte count
fba3  e1            4584   4601 	pop	h		;Start address
                    4585   4602 
                    4586   4603 ;-------------------------------------------------
                    4587   4604 ;compare memory to the pattern, avoiding the stack
                    4588   4605 ;-------------------------------------------------
fba4  e5            4589   4606 	push	h		;Start address
fba5  d5            4590   4607 	Push	d		;Byte count
fba6  c5            4591   4608 	push	b		;Pattern position
fba7  f5            4592   4609 	push	psw		;RAM page address
                    4593   4610 
fba8  f1            4594   4611 CMLOOP:	pop	psw		;a=RAM page
fba9  f5            4595   4612 	push	psw
                    4596   4613 
fbaa  bc            4597   4614 	cmp	h		;On RAM page?
fbab  c2 b4 fb      4598   4615 	jnz	CML1		;n: okay
                    4599   4616 
fbae  7d            4600   4617 	mov	a,l		;y: stack part of RAM page?
fbaf  fe 8f         4601   4618 	cpi	RAMBEG and 0FFh	;Can't test above the stack
fbb1  d2 c1 fb      4602   4619 	jnc	CML3
                    4603   4620 
fbb4  0a            4604   4621 CML1:	ldax	b		;Get pattern byte
                    4605   4622 
fbb5  b7            4606   4623 	ora	a		;Pattern end?
fbb6  c2 bc fb      4607   4624 	jnz	CML2
fbb9  01 fe fb      4608   4625 	lxi	b,MTPAT		;y: restart pattern
                    4609   4626 
fbbc  03            4610   4627 CML2:	inx	b		;next pattern byte
                    4611   4628 
                    4612   4629 
fbbd  be            4613   4630 	cmp	m		;compare pattern to memory
fbbe  c4 db fb      4614   4631 	cnz	CMPERR		;report any mismatch
                    4615   4632 
fbc1  23            4616   4633 CML3:	inx	h		;next RAM location
                    4617   4634 
fbc2  1b            4618   4635 	dcx	d		;next byte count
fbc3  7a            4619   4636 	mov	a,d		;end?
fbc4  b3            4620   4637 	ora	e
fbc5  c2 a8 fb      4621   4638 	jnz	CMLOOP
                    4622   4639 
                    4623   4640 ;---------------------------------------------------
                    4624   4641 ;Done with one pass. Print pacifier, test for abort,
                    4625   4642 ;and do another pass, unless we are done.
                    4626   4643 ;---------------------------------------------------
fbc8  cd 5d fd      4627   4644 	call	ILPRNT		;print pacifier
fbcb  ae            4628   4645 	db	PCFIER+80h
                    4629   4646 
fbcc  cd d1 fc      4630   4647 	call	CHKKBD		;Chance to abort
                    4631   4648 
fbcf  e1            4632   4649 	pop	h		;h=RAM page address
                    4633   4650 
fbd0  c1            4634   4651 	pop	b		;Pattern position
fbd1  d1            4635   4652 	pop	d		;Byte count
                    4636   4653 
fbd2  03            4637   4654 	inx	b		;rotate pattern once
fbd3  0a            4638   4655 	ldax	b		;end of pattern?
fbd4  b7            4639   4656 	ora	a
fbd5  7c            4640   4657 	mov	a,h		;restore RAM page address
                    4641   4658 
fbd6  e1            4642   4659 	pop	h		;Start address
                    4643   4660 
fbd7  c2 79 fb      4644   4661 	jnz	MTLOOP
                    4645   4662 
fbda  c9            4646   4663 	ret			;to main
                    4647   4664 		
                    4648   4665 ;---Local Subroutine----------
                    4649   4666 ;Report memory error, and give
                    4650   4667 ;user an opportunity to abort
                    4651   4668 ;On Entry:
                    4652   4669 ;  a=expected data
                    4653   4670 ;  hl=address
                    4654   4671 ;  (hl)=found data
                    4655   4672 ;-----------------------------
fbdb  c5            4656   4673 CMPERR:	push	b		;PHLADR trashes bc
fbdc  f5            4657   4674 	push	psw
                    4658   4675 
fbdd  cd 90 fd      4659   4676 	call	PHLADR		;address:
                    4660   4677 
fbe0  cd 5d fd      4661   4678 	call	ILPRNT
fbe3  57 72 6f 74   4662   4679 	db	'Wrote',' '+80h
fbe7  65 a0         4662   4680
                    4663   4681 
fbe9  f1            4664   4682 	pop	psw		;expected data
fbea  cd a6 fd      4665   4683 	call	PAHCSM
                    4666   4684 
fbed  cd 5d fd      4667   4685 	call	ILPRNT
fbf0  2c 20 72 65   4668   4686 	db	', read',' '+80h
fbf4  61 64 a0      4668   4687
fbf7  cd a5 fd      4669   4688 	call	PMHCSM		;memory data
                    4670   4689 
fbfa  c1            4671   4690 	pop	b
fbfb  c3 c1 fc      4672   4691 	jmp	CPAUSE		;Abort or pause from user?
                    4673   4692 
                    4674   4693 ;-----------------------------
                    4675   4694 ; Memory Test Pattern Sequence
                    4676   4695 ;-----------------------------
fbfe  00 ff 55 aa   4677   4696 MTPAT:	db	000h,0FFh,055h,0AAh,033h,0CCH,0F0h,00Fh
fc02  33 cc f0 0f   4677   4697
fc06  c3 3c 66 99   4678   4698 	db	0C3h,03CH,066h,099h,078h,001h,0FEh,002h
fc0a  78 01 fe 02   4678   4699
fc0e  fd 04 fb 08   4679   4700 	db	0FDH,004h,0FBh,008h,0F7h,010h,0EFh,020h
fc12  f7 10 ef 20   4679   4701
fc16  fd 40 bf 80   4680   4702 	db	0FDH,040h,0BFh,080h,07Fh
fc1a  7f            4680   4703
fc1b  00            4681   4704 	db	00h	;End of table mark
                    4682   4705  endif ;ROM2K
                    4683   4706 
                    4684   4707 ;***Command ROutine COntinuation****************
                    4685   4708 ;BO (Boot from 8" or 5=1/4" ALtair Floppy Disk)
                    4686   4709 ;Automatically detects 8" versus minidisk. Note
                    4687   4710 ;that Altair disks do not contain a boot sector.
                    4688   4711 ;This loader loads the entire operating system.
                    4689   4712 ;***********************************************
                    4690   4713  if (A88DCD or A88MCD)
                    4691   4714 
                    4692   4715 GBOCMD:	
                    4693   4716 ;-----------------------------------------------------------
                    4694   4717 ;Wait for user to insert a diskette into the drive 0, and
                    4695   4718 ;then load that drive's head. Do this first so that the disk
                    4696   4719 ;has plenty of time to settle. Note that a minidisk will
                    4697   4720 ;always report that it is ready. Minidisks will hang (later
                    4698   4721 ;on) waiting for sector 0F, until a few seconds after the
                    4699   4722 ;user inserts a disk.
                    4700   4723 ;-----------------------------------------------------------
                    4701   4724 WAITEN:	xra	a		;boot from disk 0
                    4702   4725 	out	DENABL		;..so enable disk 0
                    4703   4726 
                    4704   4727 	call	CHKKBD		;abort from user?
                    4705   4728 
                    4706   4729 	in	DSTAT		;Read drive status
                    4707   4730 	ani	DRVRDY		;Diskette in drive?
                    4708   4731 	jnz	WAITEN		;no: wait for drive ready
                    4709   4732 
                    4710   4733 	mvi	a,HEDLOD	;load 8" disk head, or enable
                    4711   4734 	out	DCTRL		;..minidisk for 6.4 Sec
                    4712   4735 
                    4713   4736 ;------------------------------------------------------
                    4714   4737 ;Step in once, then step out until track 0 is detected.
                    4715   4738 ;The first time through, delay at least 25 ms to force
                    4716   4739 ;a minimum 43 ms step wait instead of 10ms. This meets
                    4717   4740 ;the 8" spec for changing seek direction. (Minidisk
                    4718   4741 ;step time is always 50ms, enforced by the mninidsk
                    4719   4742 ;controller hardware.) See the 88-DCDD documentation
                    4720   4743 ;for details. This loop ends with hl=0.
                    4721   4744 ;------------------------------------------------------
                    4722   4745 	lxi	h,(25000/24)*CPUMHz ;25 mS delay 1st time thru
                    4723   4746 	mvi	a,STEPIN	;step in once first
                    4724   4747 
                    4725   4748 SEEKT0:	out	DCTRL		;issue step command
                    4726   4749 
                    4727   4750 	inr	l		;After the 1st time, the
                    4728   4751 				;..following loop goes 1 time.
                    4729   4752 
                    4730   4753 T0DELY:	dcx	h		;(5)
                    4731   4754 	mov	a,h		;(5)
                    4732   4755 	ora	l		;(4)
                    4733   4756 	jnz	T0DELY		;(10)24 cycles/pass
                    4734   4757 
                    4735   4758 WSTEP:	in	DSTAT		;wait for step to complete
                    4736   4759 	rrc			;put MVHEAD bit in Carry
                    4737   4760 	rrc			;is the servo stable?
                    4738   4761 	jc	WSTEP		;no: wait for servo to settle
                    4739   4762 
                    4740   4763 	ani	TRACK0/4	;Are we at track 00?
                    4741   4764 	mvi	a,STEPOT	;Step-out command
                    4742   4765 	jnz	SEEKT0		;no: step out another track
                    4743   4766 
                    4744   4767 ;------------------------------------------------------
                    4745   4768 ;Determine if this is an 8" disk or a minidisk, and set
                    4746   4769 ;c to the correct sectors/track for the detected disk.
                    4747   4770 ;an 8" disk has 20h sectors, numbered 0-1Fh. a minidisk
                    4748   4771 ;has 10h sectors, numbered 0-0Fh.
                    4749   4772 ;------------------------------------------------------
                    4750   4773 
                    4751   4774 ;Wait for the highest minidisk sector, sector number 0Fh
                    4752   4775 
                    4753   4776  endif ;(A88DCD or A88MCD)
                    4754   4777  if (A88DCD or A88MCD) and (ENINTS or CRXINT or TRXINT)
                    4755   4778 	di			;disable interrupts
                    4756   4779  endif ;(A88DCD or A88MCD) and (ENINTS or CRXINT or TRXINT)
                    4757   4780  if (A88DCD or A88MCD)
                    4758   4781 
                    4759   4782 CKDSK1:	in	DSECTR		;Read the sector position
                    4760   4783 
                    4761   4784 	ani	SECMSK+SVALID	;mask sector bits, and hunt
                    4762   4785 	cpi	(MDSPT-1)*2	;..for minidisk last sector
                    4763   4786 	jnz	CKDSK1		;..only while SVALID is 0
                    4764   4787 
                    4765   4788 ;wait for this sector to pass
                    4766   4789 
                    4767   4790 CKDSK2:	in	DSECTR		;Read the sector position
                    4768   4791 	rrc			;wait for invalid sector
                    4769   4792 	jnc	CKDSK2	
                    4770   4793 
                    4771   4794 ;Wait for and get the next sector number
                    4772   4795 
                    4773   4796 CKDSK3:	in	DSECTR		;Read the sector position
                    4774   4797 	rrc			;put SVALID in Carry
                    4775   4798 	jc	CKDSK3		;wait for sector to be valid
                    4776   4799 
                    4777   4800  endif ;(A88DCD or A88MCD)
                    4778   4801  if (A88DCD or A88MCD) and (ENINTS or CRXINT or TRXINT)
                    4779   4802 	ei			;denable interrupts
                    4780   4803  endif ;(A88DCD or A88MCD) and (ENINTS or CRXINT or TRXINT)
                    4781   4804 
                    4782   4805  if (A88DCD or A88MCD)
                    4783   4806 
                    4784   4807 
                    4785   4808 ;The next sector after sector 0Fh will be 0 for a minidisk,
                    4786   4809 ;and 10h for an 8" disk. Adding MDSPT (10h) to that value
                    4787   4810 ;will compute c=10h (for minidisks) or c=20h (for 8" disks).
                    4788   4811 
                    4789   4812 	ani	SECMSK/2	;mask sector bits
                    4790   4813 	adi	MDSPT		;compute SPT
                    4791   4814 	mov	c,a		;..and save SPT in c
                    4792   4815 
                    4793   4816 ;------------------------------------------
                    4794   4817 ;Set up to load
                    4795   4818 ;On Entry:
                    4796   4819 ;  hl=0 (DMA address & execution address)
                    4797   4820 ;  c=SPT (for either minidisk or 8" disk)
                    4798   4821 ;------------------------------------------
                    4799   4822 	push	h		;execution address=0 onto stack
                    4800   4823 	push	h		;INIT DMA address
                    4801   4824  endif ;(A88DCD or A88MCD)
                    4802   4825 
                    4803   4826  if RAMHNT and (A88DCD or A88MCD)
                    4804   4827 	dad	sp		;recover RAM page address
                    4805   4828 	mvi	l,RAMBUF	;Cleverly aligned buffer
                    4806   4829  endif ;RAMHNT and (A88DCD or A88MCD)
                    4807   4830 
                    4808   4831  if (not RAMHNT) and (A88DCD or A88MCD)
                    4809   4832 	lxi	h,RAMBUF	;Cleverly aligned buffer
                    4810   4833  endif ;(not RAMHNT) and (A88DCD or A88MCD)
                    4811   4834 
                    4812   4835  if (A88DCD or A88MCD)
                    4813   4836 	xthl			;push buffer address, recover
                    4814   4837 				;DMA address=0
                    4815   4838 
                    4816   4839 	mov	b,l		;initial sector number=0
                    4817   4840 
                    4818   4841 ;------------------------------------------------------
                    4819   4842 ;Read current sector over and over, until either the
                    4820   4843 ;checksum is right, or there have been too many retries
                    4821   4844 ;  b=current sector number
                    4822   4845 ;  c=sectors/track for this kind of disk
                    4823   4846 ; hl=current DMA address
                    4824   4847 ; top-of-stack=buffer address
                    4825   4848 ; next on stack=execution address
                    4826   4849 ;------------------------------------------------------
                    4827   4850 NXTSEC:	mvi	a,MAXTRYS	;(7)Initialize sector retries
                    4828   4851 
                    4829   4852 ;-----------------------------------------
                    4830   4853 ;Begin Sector Read
                    4831   4854 ;  a=Remaining retries for this sector
                    4832   4855 ;  b=Current sector number
                    4833   4856 ;  c=Sectors/track for this kind of disk
                    4834   4857 ; hl=current DMA address
                    4835   4858 ; top-of-stack=RAMBUF address
                    4836   4859 ; next on stack=execution address=0
                    4837   4860 ;-----------------------------------------
                    4838   4861 RDSCTR:	pop	d		;(10)get RAMBUF address
                    4839   4862 	push	d		;(11)keep it on the stack
                    4840   4863 	push	psw		;(11)Remaining retry count
                    4841   4864 
                    4842   4865  endif ;(A88DCD or A88MCD)
                    4843   4866  if (A88DCD or A88MCD) and (ENINTS or CRXINT or TRXINT)
                    4844   4867 	di			;disable interrupts
                    4845   4868  endif ;(A88DCD or A88MCD) and (ENINTS or CRXINT or TRXINT)
                    4846   4869  if (A88DCD or A88MCD)
                    4847   4870 
                    4848   4871 
                    4849   4872 ;---------------------------------------------------
                    4850   4873 ;Sector Read Step 1: hunt for sector specified in b.
                    4851   4874 ;Data will become avaiable 250 uS after -SVALID goes
                    4852   4875 ;low. -SVALID is low for 30 uS (nominal).
                    4853   4876 ;---------------------------------------------------
                    4854   4877 FNDSEC:	in	DSECTR		;(10)Read the sector position
                    4855   4878 
                    4856   4879 	ani	SECMSK+SVALID	;(7)yes: mask sector bits
                    4857   4880 				;..along with -SVALID bit
                    4858   4881 	rrc			;(4)sector bits to bits <4:0>
                    4859   4882 	cmp	b		;(4)found the desired sector
                    4860   4883 				;..with -SVALID low?
                    4861   4884 	jnz	FNDSEC		;(10)no: wait for it
                    4862   4885 
                    4863   4886 ;-----------------------------------------------------------
                    4864   4887 ;Test for DMA address that would overwrite the sector buffer
                    4865   4888 ;or the stack. Do this here, while we have some time.
                    4866   4889 ;-----------------------------------------------------------
                    4867   4890 	mov	a,h		;(5)high byte of DMA address
                    4868   4891 	cmp	d		;(4)high byte of RAM code addr
                    4869   4892 	jz	OVMERR		;(10)report overlay error
                    4870   4893 
                    4871   4894 ;--------------------------------------
                    4872   4895 ;Set up for the upcoming data move
                    4873   4896 ;Do this here, while we have some time.
                    4874   4897 ;--------------------------------------
                    4875   4898 	push	h		;(11)DMA address for retry
                    4876   4899 	push	b		;(11)Current sector & SPT
                    4877   4900 	lxi	b,BPS		;(10)b= init checksum,
                    4878   4901 				;c= byte count for MOVLUP
                    4879   4902 
                    4880   4903 ;-------------------------------------------------------
                    4881   4904 ;Sector Read Step 2: Read sector data into RAMBUF at de.
                    4882   4905 ;RAMBUF is positioned in memory such that e overflows
                    4883   4906 ;exactly at the end of the buffer. Read data becomes
                    4884   4907 ;available 250 uS after -SVALID becomes true (0).
                    4885   4908 ;
                    4886   4909 ;This loop must be << 32 uS per pass. 
                    4887   4910 ;-------------------------------------------------------
                    4888   4911 DATLUP:	in	DSTAT		;(10)Read the drive status
                    4889   4912 	rlc			;(4)new Read data Available?
                    4890   4913 	jc	DATLUP		;(10)no: wait for data
                    4891   4914 
                    4892   4915 	in	DDATA		;(10)Read data byte
                    4893   4916 	stax	d		;(7)store it in sector buffer
                    4894   4917 	inr	e		;(5)Move to next buffer address
                    4895   4918 				;..and test for end
                    4896   4919 	jnz	DATLUP		;(10)loop if more data
                    4897   4920 
                    4898   4921 ;------------------------------------------------
                    4899   4922 ;Sector Read Step 3: Move sector data from RAMBUF
                    4900   4923 ;into memory at hl. compute checksum as we go.
                    4901   4924 ;
                    4902   4925 ;8327 cycles for this section
                    4903   4926 ;------------------------------------------------
                    4904   4927 	mvi	e,SDATA and 0FFh ;(7)de= address of sector data
                    4905   4928 				 ;..within the sector buffer
                    4906   4929 
                    4907   4930 MOVLUP:	ldax	d		;(7)get sector buffer byte
                    4908   4931 	mov	m,a		;(7)store it at the destination
                    4909   4932         cmp	m		;(7)Did it store correctly?
                    4910   4933 	jnz	MEMERR		;(10)no: abort w/ memory error
                    4911   4934 
                    4912   4935 	add	b		;(4)update checksum
                    4913   4936 	mov	b,a		;(5)save the updated checksum
                    4914   4937 
                    4915   4938 	inx	d		;(5)bump sector buffer pointer
                    4916   4939 	inx	h		;(5)bump DMA pointer
                    4917   4940 	dcr	c		;(5)more data bytes to copy?
                    4918   4941 	jnz	MOVLUP		;(10)yes: loop
                    4919   4942 
                    4920   4943 ;----------------------------------------------------
                    4921   4944 ;Sector Read Step 4: check marker byte and compare
                    4922   4945 ;computed checksum against sector's checksum. Retry/
                    4923   4946 ;abort if wrong marker byte or checksum mismatch.
                    4924   4947 ;On Entry and Exit:
                    4925   4948 ;   a=computed checksum
                    4926   4949 ;134 cycles for for this section
                    4927   4950 ;----------------------------------------------------
                    4928   4951 	xchg			;(4)hl=1st trailer byte address
                    4929   4952 				;de=DMA address
                    4930   4953 	mov	c,m		;(7)get marker, should be FFh
                    4931   4954 	inr	c		;(5)c should be 0 now
                    4932   4955 
                    4933   4956 	inx	h		;(5)(hl)=checksum byte
                    4934   4957 	xra	m		;(7)compare to computed cksum
                    4935   4958 	ora	c		;(4)..and test marker=ff
                    4936   4959 
                    4937   4960 	pop	b		;(10)Current sector & SPT
                    4938   4961 	jnz	BADSEC		;(10)NZ: checksum error
                    4939   4962 
                    4940   4963 ;Compare next DMA address to the file byte count that came
                    4941   4964 ;from the sector header. Done of DMA address is greater.
                    4942   4965 
                    4943   4966 	mvi	l,SFSIZE and 0FFh ;(7)hl=address of file size
                    4944   4967 	mov	a,m		;(7)low byte
                    4945   4968 	inx	h		;(5)point to high byte
                    4946   4969 	mov	h,m		;(7)high byte
                    4947   4970 	mov	l,a		;(5)hl=SFSIZE
                    4948   4971 
                    4949   4972 	xchg			;(4)put DMA address back in hl
                    4950   4973 				;..and file size into de
                    4951   4974 
                    4952   4975 	mov	a,l		;(4)16-bit subtraction
                    4953   4976 	sub	e		;(4)
                    4954   4977 	mov	a,h		;(5)..throw away the result
                    4955   4978 	sbb	d		;(4)..but keep Carry (borrow)
                    4956   4979 
                    4957   4980 	pop	d		;(10)chuck old DMA address
                    4958   4981 	pop	d		;(10)chuck old retry count
                    4959   4982 
                    4960   4983 	jnc	FDEXEC		;(10)done loading if hl >= de
                    4961   4984 
                    4962   4985 ;------------------------------------------------------
                    4963   4986 ;Next Sector: the sectors are interleaved by two.
                    4964   4987 ;Read all the even sectors first, then the odd sectors.
                    4965   4988 ;
                    4966   4989 ;44 cycles for the next even or next odd sector
                    4967   4990 ;------------------------------------------------------
                    4968   4991 	lxi	d,NXTSEC	;(10)for compact jumps
                    4969   4992 	push	d		;(10)
                    4970   4993 
                    4971   4994 	inr	b		;(5)sector=sector + 2
                    4972   4995 	inr	b		;(5)
                    4973   4996 
                    4974   4997 	mov	a,b		;(5)even or odd sectors done?
                    4975   4998 	cmp	c		;(4)c=SPT
                    4976   4999 	rc			;(5/11)no: go read next sector
                    4977   5000 				;..at NXTSEC
                    4978   5001 
                    4979   5002 ;Total sector-to-sector = 28+8327+134+44=8533 cycles=4266.5 uS
                    4980   5003 ;one 8" sector time = 5208 uS, so with 2:1 interleave, we will
                    4981   5004 ;make the next sector, no problem.
                    4982   5005 
                    4983   5006  endif ;(A88DCD or A88MCD)
                    4984   5007  if (A88DCD or A88MCD) and (ENINTS or CRXINT or TRXINT)
                    4985   5008 	ei			;enable interrupts
                    4986   5009  endif ;(A88DCD or A88MCD) and (ENINTS or CRXINT or TRXINT)
                    4987   5010  if (A88DCD or A88MCD)
                    4988   5011 
                    4989   5012 	mvi	b,01h		;1st odd sector number
                    4990   5013 	rz			;Z: must read odd sectors now
                    4991   5014 				;..at NXTSEC
                    4992   5015 
                    4993   5016 ;------------------------------------------------------------
                    4994   5017 ;Next Track: Step in, and read again.
                    4995   5018 ;Don't wait for the head to be ready (-MVHEAD), since we just
                    4996   5019 ;read the entire previous track. Don't need to wait for this
                    4997   5020 ;step-in to complete either, because we will definitely blow
                    4998   5021 ;a revolution going from the track's last sector to sector 0.
                    4999   5022 ;(One revolution takes 167 mS, and one step takes a maximum
                    5000   5023 ;of 40 uS.) Note that NXTRAC will repair the stack.
                    5001   5024 ;------------------------------------------------------------
                    5002   5025 	mov	a,b		;STEPIN happens to be 01h
                    5003   5026 	out	DCTRL
                    5004   5027 
                    5005   5028 	dcr	b		;start with b=0 for sector 0
                    5006   5029 	ret			;go to NXTSEC
                    5007   5030 
                    5008   5031 ;-------------------------------------------------
                    5009   5032 ;Execute successfully loaded code, after disabling
                    5010   5033 ;the floppy drive and disabling the PROM
                    5011   5034 ;On Entry:
                    5012   5035 ;  Top of stack=RAMBUF address
                    5013   5036 ;  Next on stack=execution address
                    5014   5037 ;-------------------------------------------------
                    5015   5038 FDEXEC:	mvi	a,DDISBL	;Disable floppy controller
                    5016   5039 	out	DENABL
                    5017   5040 
                    5018   5041 	pop	d		;chuck RAMBUF address
                    5019   5042 				;..to expose exec address
                    5020   5043 
                    5021   5044  endif ;(A88DCD or A88MCD)
                    5022   5045  if (A88DCD or A88MCD) and (ENINTS or CRXINT or TRXINT)
                    5023   5046 	di			;disable interrupts
                    5024   5047  endif ;(A88DCD or A88MCD) and (ENINTS or CRXINT or TRXINT)
                    5025   5048  if (A88DCD or A88MCD)
                    5026   5049 
                    5027   5050 
                    5028   5051 	jmp	EXECDP		;disable PROM and execute code
                    5029   5052 
                    5030   5053 ;---Error Routine------------------------------------------
                    5031   5054 ;Checksum error: attempt retry if not too many retries
                    5032   5055 ;already. otherwise, abort, reporting the error 
                    5033   5056 ;On Entry:
                    5034   5057 ;  Top of stack=adress for first byte of the failing sector
                    5035   5058 ;  next on stack=retry count
                    5036   5059 ;----------------------------------------------------------
                    5037   5060 BADSEC:	mvi	a,HEDLOD	;Restart Minidisk 6.4 uS timer
                    5038   5061 	out	DCTRL
                    5039   5062 
                    5040   5063  endif ;(A88DCD or A88MCD)
                    5041   5064  if (A88DCD or A88MCD) and (ENINTS or CRXINT or TRXINT)
                    5042   5065 	ei			;enable interrupts
                    5043   5066  endif ;(A88DCD or A88MCD) and (ENINTS or CRXINT or TRXINT)
                    5044   5067  if (A88DCD or A88MCD)
                    5045   5068 
                    5046   5069 
                    5047   5070 	pop	h		;Restore DMA address
                    5048   5071 	pop	psw		;get retry count
                    5049   5072 	dcr	a		;Any more retries left?
                    5050   5073 	jnz	RDSCTR		;yes: try reading it again
                    5051   5074 
                    5052   5075 ;Irrecoverable error in one sector: too many retries.
                    5053   5076 ;these errors may be either incorrect marker bytes,
                    5054   5077 ;wrong checksums, or a combination of both.
                    5055   5078 
                    5056   5079 ;Fall into CSMERR
                    5057   5080 
                    5058   5081  endif ;A88DCD or A88MCD
                    5059   5082 
                    5060   5083 ;---Error Routine--------------------------------------
                    5061   5084 ;Checksum Error (for both HL and BO commands)
                    5062   5085 ;On Entry:
                    5063   5086 ;  if ROM2K: hl=RAM adress for first byte of the failed
                    5064   5087 ;     sector, or last address of the Intel Hex block
                    5065   5088 ;------------------------------------------------------
fc1c  cd 59 fd      5066   5089 CSMERR:	call	CILPRT
fc1f  43 73 ed      5067   5090 	db	'Cs','m'+80h
                    5068   5091 
                    5069   5092  if ROM2K
fc22  c3 34 fc      5070   5093 	jmp	RPTERR		;go give details
                    5071   5094  endif ;ROM2K
                    5072   5095 
                    5073   5096  if not ROM2K
                    5074   5097 	jmp	CMDERR		;error handler
                    5075   5098  endif ;not ROM2K
                    5076   5099 
                    5077   5100 ;---Error Routine----------------------------------
                    5078   5101 ;Memory Overwrite Error: Attempt to overwrite stack
                    5079   5102 ;(for both HL and BO commands)
                    5080   5103 ;On Entry:
                    5081   5104 ;   if ROM2K: hl=offending RAM address
                    5082   5105 ;--------------------------------------------------
fc25  cd 59 fd      5083   5106 OVMERR:	call	CILPRT
fc28  41 64 f2      5084   5107 	db	'Ad','r'+80h
                    5085   5108 
                    5086   5109  if ROM2K
fc2b  c3 34 fc      5087   5110 	jmp	RPTERR		;go give details
                    5088   5111  endif ;ROM2K
                    5089   5112 
                    5090   5113  if not ROM2K
                    5091   5114 	jmp	CMDERR		;error handler
                    5092   5115  endif ;not ROM2K
                    5093   5116 
                    5094   5117  if ROM2K
                    5095   5118 ;---Error Routine---------------------
                    5096   5119 ;Memory Error: memory readback failed
                    5097   5120 ;On Entry:
                    5098   5121 ;   if ROM2K: hl=offending RAM address
                    5099   5122 ;-------------------------------------
fc2e  cd 59 fd      5100   5123 MEMERR:	call	CILPRT
fc31  52 41 cd      5101   5124 	db	'RA','M'+80h
                    5102   5125 
                    5103   5126 ;Fall into RPTERR
                    5104   5127 
                    5105   5128 ;---Error Routine--------------------------------------
                    5106   5129 ;Report An error: turn the disk controller off, report
                    5107   5130 ;the error on the Console and jump to the Console loop.
                    5108   5131 ;On Entry:
                    5109   5132 ;   hl=offending RAM address
                    5110   5133 ;   sp=valid address in RAM page
                    5111   5134 ;------------------------------------------------------
fc34                5112   5135 RPTERR:
                    5113   5136 
                    5114   5137  endif ;ROM2K
                    5115   5138  if A88DCD or A88MCD
                    5116   5139 
                    5117   5140 	mvi	a,DDISBL	;Disable floppy controller
                    5118   5141 	out	DENABL
                    5119   5142 
                    5120   5143  endif ;A88DCD or A88MCD
                    5121   5144  if ROM2K
                    5122   5145 
fc34  cd 5d fd      5123   5146 	call	ILPRNT
fc37  20 65 72 72   5124   5147 	db	' error at',' '+80h
fc3b  6f 72 20 61   5124   5148
fc3f  74 a0         5124   5149
fc41  cd 9d fd      5125   5150 	call	PHLCHX		;print hl in hex on Console
                    5126   5151 
fc44  c3 0b fd      5127   5152 	jmp	CABORT		;Repair stack, go to MAIN
                    5128   5153 
                    5129   5154  endif ;ROM2K
                    5130   5155 
                    5131   5156 ;***Command Routine Continuation**********
                    5132   5157 ;BO (Boot from CCS 2422 Floppy Controller)
                    5133   5158 ;*****************************************
                    5134   5159  if CC2422
                    5135   5160 
                    5136   5161 GBOCMD:	mvi	c,MAXTRYS+1	;sector retry counter
                    5137   5162 
                    5138   5163 	mvi	a,DCMDMO+(1 shl BOTDSK)
                    5139   5164 	out	DCTRL		;Assume minidisk for restore
                    5140   5165 	mov	d,a
                    5141   5166 
                    5142   5167 	mvi	a,SIDE0		;set side 0
                    5143   5168 	out	BCTRL
                    5144   5169 
                    5145   5170 	mvi	a,RESTOR	;Restore to track 0
                    5146   5171 	out	DCMMD
                    5147   5172 	mvi	b,SNORDY	;(7)The only possible error
                    5148   5173 	call	EXCCHK		;(17)test WD1793 status (17)
                    5149   5174 
                    5150   5175 ;Check for 8" disk and change setup if that's what we have
                    5151   5176 
                    5152   5177 	in	BSTAT		;read BSTAT while on track 0
                    5153   5178 	ani	BTRK0		;1 if 8" disk while on track 0
                    5154   5179 	jz	REBO1
                    5155   5180 
                    5156   5181 	mvi	a,DCMAXI	;set up for an 8" disk by
                    5157   5182 	ora	d		;..setting the maxidisk bit
                    5158   5183 	out	DCTRL
                    5159   5184 	mov	d,a		;remember DCTRL state
                    5160   5185 REBO1:
                    5161   5186 
                    5162   5187 ;Set up to read the boot sector
                    5163   5188 
                    5164   5189 RBRTRY:	mvi	a,BOTSEC	;Sector to boot
                    5165   5190 	out	DSCTR		;WD1793 sector port
                    5166   5191 
                    5167   5192 	lxi	h,BOTADR	;Put boot sector here
                    5168   5193 
                    5169   5194 ;Read boot sector into RAM at hl
                    5170   5195 
                    5171   5196  endif ;CC2422
                    5172   5197  if CC2422 and (ENINTS or CRXINT or TRXINT)
                    5173   5198 	di			;disable interrupts
                    5174   5199  endif ;CC2422 and (ENINTS or CRXINT or TRXINT)
                    5175   5200  if CC2422
                    5176   5201 
                    5177   5202 	mov	a,d		;(13)select
                    5178   5203 	ori	DCAUTOW		;(7)enable auto-wait
                    5179   5204 	out	DCTRL		;(11)output DCTRL value
                    5180   5205 
                    5181   5206 	mvi	a,RDSECT	;read command
                    5182   5207 	out	DCMMD		;(11)disk command port
                    5183   5208 
                    5184   5209 
                    5185   5210 RDSLUP:	in	DDATA		;(10) 32 cycles in-to-in
                    5186   5211 	mov	m,a		;(7)
                    5187   5212 	inr	l		;(4)
                    5188   5213 	jm	RDSLUP		;(10)
                    5189   5214 
                    5190   5215 	mvi	b,SNORDY+SRNFER+SCRCER+SLOSTD
                    5191   5216 	call	EXCCHK		;test WD1793 status
                    5192   5217 
                    5193   5218 ;Execute the loaded code if it's ok
                    5194   5219 
                    5195   5220 	jz	BOTADR
                    5196   5221 
                    5197   5222 ;----------------------------------
                    5198   5223 ;Read fail. Try again if possible.
                    5199   5224 ;Give user feedback about retries.
                    5200   5225 ;  c=retry count-down
                    5201   5226 ;----------------------------------
                    5202   5227 	mov	b,a		;error code
                    5203   5228 
                    5204   5229 	mvi	a,MAXTRYS+1
                    5205   5230 	cmp	c		;first retry?
                    5206   5231 	jnz	RBR1		;n: just print dot
                    5207   5232 
                    5208   5233 	call	CILPRT		;Enables ints too, if ENINTS
                    5209   5234 	db	'Retryin','g'+80h
                    5210   5235 
                    5211   5236 RBR1:	call	ILPRNT
                    5212   5237 	db	'.'+80h
                    5213   5238 
                    5214   5239 	dcr	c		;too many retries?
                    5215   5240 	jnz	RBRTRY
                    5216   5241 
                    5217   5242 ;Fall into BOTERR
                    5218   5243 
                    5219   5244 ;---Fail-------------------------
                    5220   5245 ;Fatal error when trying to boot.
                    5221   5246 ;Report, and return to prompt
                    5222   5247 ;On Entry:
                    5223   5248 ;  b=error code
                    5224   5249 ;--------------------------------
                    5225   5250 BOTERR:	call	CILPRT
                    5226   5251 	db	'Boot failed:',' '+80h
                    5227   5252 
                    5228   5253 	mov	a,b		;error code
                    5229   5254 	call	PCAHEX
                    5230   5255 
                    5231   5256 	call	ILPRNT
                    5232   5257 	db	'h'+80h
                    5233   5258 
                    5234   5259 	jmp	CABORT
                    5235   5260 
                    5236   5261 ;---Local Subroutine----------
                    5237   5262 ;Check disk controller status
                    5238   5263 ;On Entry:
                    5239   5264 ;  b=error mask
                    5240   5265 ;On Exit:
                    5241   5266 ;  Z set if no errors
                    5242   5267 ;  Z clear if error or timeout
                    5243   5268 ;Trashes a,e,hl
                    5244   5269 ;-----------------------------
                    5245   5270 EXCCHK:	lxi	h,400*CPUMHz	;(7)about 2 seconds
                    5246   5271 				;(e a little random at first)
                    5247   5272 
                    5248   5273 ECLOOP:	dcx	h		;(5)
                    5249   5274 	mov	a,l		;(5)
                    5250   5275 	ora	h		;(4)
                    5251   5276 	jz	TIMOUT		;(10)controller timeout?
                    5252   5277 
                    5253   5278 ECLUP2:	dcr	e		;(5)inner loop: 9984 cycles
                    5254   5279 	jz	ECLOOP		;(10)
                    5255   5280 
                    5256   5281 	in	DFLAG		;(10)wait for command to end
                    5257   5282 	rrc			;(4)test DFSEOJ
                    5258   5283 	jnc	ECLUP2		;(10) 39 cycles/pass
                    5259   5284 
                    5260   5285 ;Delay enough that we have at least 56 uS.
                    5261   5286 ;We have 94 cycles already in the code.
                    5262   5287 ;(See WD179x Application Notes, November 1980)
                    5263   5288 
                    5264   5289 	mvi	e,3*CPUMHz	;(7)
                    5265   5290 
                    5266   5291 ELDLP:	dcr	e		;(4)
                    5267   5292 	jnz	ELDLP		;(10) 14 cycles/pass
                    5268   5293 
                    5269   5294 ;check controller status
                    5270   5295 
                    5271   5296 	in	DSTAT		;get status
                    5272   5297 	ani	b		;mask errors
                    5273   5298 	rp			;msb is drive not ready bit
                    5274   5299 
                    5275   5300 ;Fall into DNRERR
                    5276   5301 
                    5277   5302 ;---Fail---------------------
                    5278   5303 ;Drive not ready.
                    5279   5304 ;Report, and return to prompt
                    5280   5305 ;----------------------------
                    5281   5306 DNRERR:	call	CILPRT
                    5282   5307 	db	'Drive not read','y'+80h
                    5283   5308 	jmp	CABORT
                    5284   5309 
                    5285   5310 ;---Fail---------------------
                    5286   5311 ;Controller timeout.
                    5287   5312 ;Report, and return to prompt
                    5288   5313 ;----------------------------
                    5289   5314 TIMOUT:	call	CILPRT
                    5290   5315 	db	'FDC timeou','t'+80h
                    5291   5316 
                    5292   5317 	jmp	CABORT
                    5293   5318 
                    5294   5319  endif ;CC2422
                    5295   5320 
                    5296   5321 ;***Command Routine Continuation***************************
                    5297   5322 ;BO (Boot from Cromemco 4FDC/16FDC/64FDC Floppy Controller)
                    5298   5323 ;On Entry:
                    5299   5324 ;  hl=1st value after the command
                    5300   5325 ; We allow booting from any valid drive because CDOS
                    5301   5326 ; (and probably Cromix) can boot from any drive.
                    5302   5327 ;**********************************************************
                    5303   5328  if (C4FDC or C16FDC or C64FDC)
                    5304   5329 
                    5305   5330 GBOCMD:	mvi	c,MAXTRYS+1	;sector retry counter
                    5306   5331 
                    5307   5332 ;Get the specified boot drive, if any, and set up the
                    5308   5333 ;DCTRL value in d
                    5309   5334 
                    5310   5335 	mov	a,l
                    5311   5336 	cmp	MAXDRV+1	;valid drive specified?
                    5312   5337 	jnc	CMDERR		;n: bogus
                    5313   5338 
                    5314   5339 	mvi	a,80h		;compute drive select
                    5315   5340 
                    5316   5341 DSLOOP:	rlc
                    5317   5342 	dcr	l
                    5318   5343 	jp	DSLOOP
                    5319   5344 
                    5320   5345 	ori	DCMAXI or DCMOTO ;complete select bits
                    5321   5346 	mov	d,a
                    5322   5347 
                    5323   5348 RBRTRY:	mov	a,d
                    5324   5349 	out	DCTRL		;select disk & maxi/mini
                    5325   5350 
                    5326   5351 	mvi	a,7Fh		;side 0, slow-seek, etc.
                    5327   5352 	out	ACTRL
                    5328   5353 
                    5329   5354 ;Restore to track 0
                    5330   5355 
                    5331   5356 	mvi	a,RESTOR	;restore to track 0
                    5332   5357 	out	DCMMD
                    5333   5358 
                    5334   5359 	mvi	b,SNORDY	;(7)The only possible error
                    5335   5360 	call	EXCCHK		;test WD1793 status (17)
                    5336   5361 
                    5337   5362 ;Set up to read boot sector
                    5338   5363 
                    5339   5364 	mvi	a,BOTSEC	;Boot sector
                    5340   5365 	out	DSCTR		;set sector reg
                    5341   5366 
                    5342   5367 	lxi	h,BOTADR	;address to load & run
                    5343   5368 
                    5344   5369 	mov	a,d		;select bits
                    5345   5370 	ori	DCAUTO		;turn on auto-wait
                    5346   5371 	out	DCTRL
                    5347   5372 
                    5348   5373 ;Read the sector
                    5349   5374 
                    5350   5375  endif ;(C4FDC or C16FDC or C64FDC)
                    5351   5376  if (C4FDC or C16FDC or C64FDC) and (ENINTS or CRXINT or TRXINT)
                    5352   5377 	di			;disable interrupts
                    5353   5378  endif ;(C4FDC or C16FDC or C64FDC) and (ENINTS or CRXINT or TRXINT)
                    5354   5379  if (C4FDC or C16FDC or C64FDC)
                    5355   5380 
                    5356   5381 	mvi	a,RDSECT
                    5357   5382 	out	DCMMD
                    5358   5383 
                    5359   5384 ;32 cycles=16 uS per byte (no problem for SD track)
                    5360   5385 
                    5361   5386 DDREAD:	in	DDATA		;(10)get a byte
                    5362   5387 	mov	m,a		;(7)store it in RAM
                    5363   5388 	inr	l		;(5)
                    5364   5389 	jm	DDREAD		;(10)
                    5365   5390 
                    5366   5391 ;check status
                    5367   5392 
                    5368   5393 	mvi	b,SNORDY+SRNFER+SCRCER+SLOSTD
                    5369   5394 	call	EXCCHK		;test WD1793 status
                    5370   5395 
                    5371   5396 ;Execute the loaded code if it's ok
                    5372   5397 
                    5373   5398 	jz	BOTADR
                    5374   5399 
                    5375   5400 ;----------------------------------------
                    5376   5401 ;Read fail. Try again with the other size
                    5377   5402 ;size disk (maxi vs mini) if possible.
                    5378   5403 ;Give user feedback about retries.
                    5379   5404 ;  a=error code
                    5380   5405 ;  c=retry count-down
                    5381   5406 ;  d=select bits with mini/maxi
                    5382   5407 ;----------------------------------------
                    5383   5408 	mov	b,a		;error code
                    5384   5409 
                    5385   5410 	mvi	a,DCMAXI
                    5386   5411 	xra	d		;toggle maxi/mini
                    5387   5412 	mov	d,a
                    5388   5413 
                    5389   5414 	ani	DCMAXI		;report only when
                    5390   5415 	jz	RBRTRY		;..retrying maxidisk
                    5391   5416 
                    5392   5417 	mvi	a,MAXTRYS+1
                    5393   5418 	cmp	c		;first retry?
                    5394   5419 	jnz	RBR1		;n: just print dot
                    5395   5420 
                    5396   5421 	call	CILPRT
                    5397   5422 	db	'Retryin','g'+80h
                    5398   5423 
                    5399   5424 RBR1:	call	ILPRNT
                    5400   5425 	db	'.'+80h
                    5401   5426 
                    5402   5427 	dcr	c		;too many retries?
                    5403   5428 	jnz	RBRTRY
                    5404   5429 
                    5405   5430 ;Fall into BOTERR
                    5406   5431 
                    5407   5432 ;---Fail--------------------------
                    5408   5433 ;Fatal error when trying to boot.
                    5409   5434 ;Report, and return to the prompt.
                    5410   5435 ;On Entry:
                    5411   5436 ;  b=error code
                    5412   5437 ;---------------------------------
                    5413   5438 BOTERR:	call	CILPRT
                    5414   5439 	db	'Boot failed:',' '+80h
                    5415   5440 
                    5416   5441 	mov	a,b		;error code
                    5417   5442 	call	PCAHEX
                    5418   5443 
                    5419   5444 	call	ILPRNT
                    5420   5445 	db	'h'+80h
                    5421   5446 
                    5422   5447 	jmp	CABORT
                    5423   5448 
                    5424   5449 ;---Local Subroutine---------------------------
                    5425   5450 ;Check disk controller status
                    5426   5451 ;On Entry:
                    5427   5452 ;  b=error mask
                    5428   5453 ;On Exit:
                    5429   5454 ;  Z set if no errors
                    5430   5455 ;  Z clear and a=error code if error or timeout
                    5431   5456 ;Trashes a,e,hl
                    5432   5457 ;----------------------------------------------
                    5433   5458 EXCCHK:	lxi	h,400*CPUMHz	;(7)about 2 seconds
                    5434   5459 				;(e a little random at first)
                    5435   5460 
                    5436   5461 ECLOOP:	dcx	h		;(5)
                    5437   5462 	mov	a,l		;(5)
                    5438   5463 	ora	h		;(4)
                    5439   5464 	jz	TIMOUT		;(10)controller timeout?
                    5440   5465 
                    5441   5466 ECLUP2:	dcr	e		;(5)inner loop: 9984 cycles
                    5442   5467 	jz	ECLOOP		;(10)
                    5443   5468 
                    5444   5469 	in	DFLAG		;(10)wait for command to end
                    5445   5470 	rrc			;(4)test DFSEOJ
                    5446   5471 	jnc	ECLUP2		;(10) 39 cycles/pass
                    5447   5472 
                    5448   5473 ;Delay enough that we have at least 56 uS (224 cycles)
                    5449   5474 ;for a 4 MHz CPU. We have 94 cycles already in the code.
                    5450   5475 ;(See WD179x Application Notes, November 1980)
                    5451   5476 
                    5452   5477 	mvi	e,10		;(7)
                    5453   5478 
                    5454   5479 ELDLP:	dcr	e		;(4)
                    5455   5480 	jnz	ELDLP		;(10) 14 cycles/pass
                    5456   5481 
                    5457   5482 ;Check controller status
                    5458   5483 
                    5459   5484 	in	DSTAT		;get status
                    5460   5485 	ani	b		;mask errors
                    5461   5486 	rp			;msb is drive not ready bit
                    5462   5487 
                    5463   5488 ;Fall into DNRERR
                    5464   5489 
                    5465   5490 ;---Fail-----------------------
                    5466   5491 ;Drive not ready.
                    5467   5492 ;report, and return to Memon/80
                    5468   5493 ;------------------------------
                    5469   5494 DNRERR:	call	CILPRT
                    5470   5495 	db	'Drive not read','y'+80h
                    5471   5496 
                    5472   5497 	jmp	CABORT
                    5473   5498 
                    5474   5499 ;---Fail-----------------------
                    5475   5500 ;controller timeout.
                    5476   5501 ;report, and return to Memon/80
                    5477   5502 ;------------------------------
                    5478   5503 TIMOUT:	call	CILPRT
                    5479   5504 	db	'FDC timeou','t'+80h
                    5480   5505 
                    5481   5506 	jmp	CABORT
                    5482   5507 
                    5483   5508  endif ;(C4FDC or C16FDC or C64FDC)
                    5484   5509 
                    5485   5510 ;***Command Routine Continuation***************
                    5486   5511 ;BO (Boot from IMSAI FIF Floppy controller)
                    5487   5512 ;(This code based on ABOOTSIM.ASM in the "IMSAI
                    5488   5513 ;CP/M System User's Guide Version 1.31 Rev.2",
                    5489   5514 ;3/21/77, page CP/M 2 - 18.)
                    5490   5515 ;**********************************************
                    5491   5516  if IFIF
fc47  0e 11         5492   5517 GBOCMD:	mvi	c,MAXTRYS+1	;retry counter
                    5493   5518 
fc49  3e 10         5494   5519 	mvi	a,ISSPTR	;Set string pointer 0
fc4b  d3 fd         5495   5520 	out	IDISK
                    5496   5521 
                    5497   5522 ;Set Floppy Disk Interface string pointer
                    5498   5523 
fc4d  21 80 00      5499   5524 	lxi	h,IBCMD		;Point hl at command string
fc50  7d            5500   5525 	mov	a,l		;lo
fc51  d3 fd         5501   5526 	out	IDISK
fc53  7c            5502   5527 	mov	a,h		;hi
fc54  d3 fd         5503   5528 	out	IDISK
                    5504   5529 
                    5505   5530 ;Set up string in RAM
                    5506   5531 
fc56  36 21         5507   5532 	mvi	m,IRDSEC	;Read sector 0, unit 0
fc58  23            5508   5533 	inx	h		;Point at status byte
fc59  23            5509   5534 	inx	h		;Point at high order track
fc5a  af            5510   5535 	xra	a		;Get 0 in a
fc5b  77            5511   5536 	mov	m,a		;Zero high order track
fc5c  23            5512   5537 	inx	h
fc5d  77            5513   5538 	mov	m,a		;Zero lo order track
fc5e  23            5514   5539 	inx	h
fc5f  36 01         5515   5540 	mvi	m,1		;Sector 1
fc61  23            5516   5541 	inx	h
fc62  77            5517   5542 	mov	m,a		;Zero low order buffer address
fc63  23            5518   5543 	inx	h
fc64  77            5519   5544 	mov	m,a		;Zero high order buf address
                    5520   5545 
                    5521   5546 ;Initialization complete. Now read sector.
                    5522   5547 
fc65  21 81 00      5523   5548 RBRTRY:	lxi	h,IBSTAT
fc68  af            5524   5549 	xra	a
                    5525   5550 
fc69  77            5526   5551 	mov	m,a		;Stat must be 0 before command
                    5527   5552 
                    5528   5553 ;N.B. a=0 is disk command IEXEC0 to execute string 0
                    5529   5554 
fc6a  d3 fd         5530   5555 	out	IDISK		;Tell disk to go
fc6c  86            5531   5556 IDWAIT:	add	m		;Look for non-0 status
fc6d  ca 6c fc      5532   5557 	jz	IDWAIT		;Keep looking 'till it comes
                    5533   5558 
fc70  fe 01         5534   5559 	cpi	ISUCCS
fc72  ca 00 00      5535   5560 	jz	0		;On success, go to bootstrap
                    5536   5561 				;routine read from disk
                    5537   5562 
                    5538   5563 ;--------------------------------------------
                    5539   5564 ;Read fail. Restore the disk and try again if
                    5540   5565 ;we can. Give user feedback about retries.
                    5541   5566 ;  m=error code
                    5542   5567 ;  c=retry count-down
                    5543   5568 ;--------------------------------------------
fc75  3e 21         5544   5569 	mvi	a,IRESTR	;Restore the disk
fc77  d3 fd         5545   5570 	out	IDISK
                    5546   5571 
fc79  3e 11         5547   5572 	mvi	a,MAXTRYS+1
fc7b  b9            5548   5573 	cmp	c		;first retry?
fc7c  c2 8a fc      5549   5574 	jnz	RBR1		;n: just print dot
                    5550   5575 
fc7f  cd 59 fd      5551   5576 	call	CILPRT
fc82  52 65 74 72   5552   5577 	db	'Retryin','g'+80h
fc86  79 69 6e e7   5552   5578
                    5553   5579 
fc8a  cd 5d fd      5554   5580 RBR1:	call	ILPRNT
fc8d  ae            5555   5581 	db	'.'+80h
                    5556   5582 
fc8e  0d            5557   5583 	dcr	c		;too many retries?
fc8f  c2 65 fc      5558   5584 	jnz	RBRTRY
                    5559   5585 
                    5560   5586 ;Fall into BOTERR
                    5561   5587 
                    5562   5588 ;---Fail--------------------------
                    5563   5589 ;Fatal error when trying to boot.
                    5564   5590 ;report, and return to the prompt.
                    5565   5591 ;On Entry:
                    5566   5592 ;  m=error code
                    5567   5593 ;---------------------------------
fc92  cd 59 fd      5568   5594 BOTERR:	call	CILPRT
fc95  42 6f 6f 74   5569   5595 	db	'Boot failed:',' '+80h
fc99  20 66 61 69   5569   5596
fc9d  6c 65 64 3a   5569   5597
fca1  a0            5569   5598
                    5570   5599 
fca2  7e            5571   5600 	mov	a,m		;error code
fca3  cd ab fd      5572   5601 	call	PCAHEX
                    5573   5602 
fca6  cd 5d fd      5574   5603 	call	ILPRNT
fca9  e8            5575   5604 	db	'h'+80h
                    5576   5605 
fcaa  c3 0b fd      5577   5606 	jmp	CABORT
                    5578   5607  endif ;IFIF
                    5579   5608 
                    5580   5609 ;***Command Routine Continuation************
                    5581   5610 ;BO (Boot from Micropolis Floppy Controller)
                    5582   5611 ;*******************************************
                    5583   5612  if MICROP
                    5584   5613 
                    5585   5614 ;Copy Read-Sector subroutine into RAM,
                    5586   5615 ;since DOS expects it there.
                    5587   5616 
                    5588   5617 GBOCMD:	lxi	d,RDSROM	;source
                    5589   5618 	lxi	h,RDSEC		;destination
                    5590   5619 	mvi	c,RDSLEN	;byte count
                    5591   5620 
                    5592   5621 COPYB:	ldax	d
                    5593   5622 	mov	m,a
                    5594   5623 	inx	h
                    5595   5624 	inx	d
                    5596   5625 	dcr	c
                    5597   5626 	jnz	COPYB
                    5598   5627 
                    5599   5628 	lxi	h,FDCMD		;command register address
                    5600   5629 	mvi	m,FRESET	;reset FDC
                    5601   5630 
                    5602   5631 	mvi	b,MAXTRYS+1	;b=max read retries
                    5603   5632 
                    5604   5633 ;--------------------------------------
                    5605   5634 ;Find and load track 0, sector 0, using
                    5606   5635 ;the FDC we just found.
                    5607   5636 ;On Entry:
                    5608   5637 ;   b=retry counter
                    5609   5638 ;   c=0
                    5610   5639 ;   hl=command register address
                    5611   5640 ;--------------------------------------
                    5612   5641 
                    5613   5642 ;Select drive 0 and give the drive time to spin up.
                    5614   5643 ;The drive may not be spinning if the FDC has been
                    5615   5644 ;modified with the motor-off mod. DELSTA will read
                    5616   5645 ;the FDC's status register every pass, resetting
                    5617   5646 ;the motor-off mod's 4-second timer.
                    5618   5647 
                    5619   5648 	mvi	m,SLUN+0	;select drive zero
                    5620   5649 
                    5621   5650 	mvi	d,85		;delay for 85*5.89=500 mS
                    5622   5651 	call	DELSTA		;returns a=status reg value
                    5623   5652 				;returns de=0	
                    5624   5653 
                    5625   5654 RETRY:	dcr	b		;too many read retries?
                    5626   5655 	jz	RDERR		;y: read error
                    5627   5656 	push	b		;b=retries
                    5628   5657 
                    5629   5658 ;Verify drive is ready. If the controller board has been
                    5630   5659 ;modified with the motor-off mod, then its RDY line is
                    5631   5660 ;always true. So rather than check the drive ready bit,
                    5632   5661 ;look at the sector register to see that it is changing,
                    5633   5662 ;indicating that a disk is spinning. (We don't care if the
                    5634   5663 ;sector is valid - just that it is changing.)
                    5635   5664 
                    5636   5665 	mov	c,m		;c=1st check of sector register
                    5637   5666 
                    5638   5667 	mvi	d,17		;delay for 17*5.89=100.3 mS
                    5639   5668 	call	DELSTA		;..1/2 revolution
                    5640   5669 
                    5641   5670 	mov	a,m		;a=2nd check of sector register
                    5642   5671 	xra	c		;did sector register change?
                    5643   5672 				;any bits changing in sect reg
                    5644   5673 				;..indicate a spinning disk.
                    5645   5674 
                    5646   5675 	jz	DNRERR		;same: drive not ready	
                    5647   5676 
                    5648   5677 ;Home the head: Step in to get off track 0, and then seek to
                    5649   5678 ;track zero. The number of step-ins is equal to the remaining
                    5650   5679 ;retry counter, meaning it will try more times to get off the
                    5651   5680 ;track 0 sensor on early retries than on late retries. In
                    5652   5681 ;fact, it should always take just one step to get off the
                    5653   5682 ;track 0 sensor. If we happen to start out on the last track,
                    5654   5683 ;then we will do one more step out, which is okay.
                    5655   5684 ;hl=FDC command register address for HSTEP
                    5656   5685 ;b=retries here
                    5657   5686 ;e=0 here
                    5658   5687 
                    5659   5688 ;step away from track 0
                    5660   5689 
                    5661   5690 	lxi	b,900h+STEP+STEPI ;b=8 steps, c=step in
                    5662   5691 
                    5663   5692 UNSTUK:	call	HSTEP		;exits with de=0,
                    5664   5693 				;..a=status reg value
                    5665   5694 	ani	TK0		;still at track zero?
                    5666   5695 	jnz	UNSTUK		;y: try stepping away again
                    5667   5696 
                    5668   5697 ;seek track 0
                    5669   5698 
                    5670   5699 	lxi	b,(90*256)+STEP+STEPO ;b=90 steps max,
                    5671   5700 				      ;..c=step out
                    5672   5701 
                    5673   5702 SEEK0:	call	HSTEP		;exits with de=0,
                    5674   5703 				;..a=status reg value
                    5675   5704 	ani	TK0		;at track zero yet?
                    5676   5705 				;returns with de=0
                    5677   5706 	jz	SEEK0		;n: step out again
                    5678   5707 
                    5679   5708 ;Read sector zero into a RAM buffer (MICBUF)
                    5680   5709 ;d=0
                    5681   5710 ;hl=FDC command register address for RDSECH
                    5682   5711 
                    5683   5712 	mvi	e,MICBUF	;de=RAM buffer addr in page 0
                    5684   5713 	call	READ0		;hl=control register
                    5685   5714 				;Z set if ok
                    5686   5715 
                    5687   5716 ;Unless the 1st read failed, get the load address for
                    5688   5717 ;this sector from the sector data and re-read the same
                    5689   5718 ;sector into the requested address
                    5690   5719 
                    5691   5720 	xchg			;de=FDC address
                    5692   5721 	lhld	MICBUF+PTROFF	;requested load address
                    5693   5722 	xchg
                    5694   5723 	cz	READ0		;hl=control register
                    5695   5724 
                    5696   5725 	pop	b		;b=retry counter, c=0
                    5697   5726 	jnz	RETRY		;failed, start over
                    5698   5727 
                    5699   5728 ;Successful load. Create stack for DOS, save addresses
                    5700   5729 ;DOS uses (Note: we can't create DOS's stack until we
                    5701   5730 ;are sure we will not return to MAIN.)
                    5702   5731 
                    5703   5732 	lxi	sp,LODADR+2	;create stack for DOS
                    5704   5733 	push	d		;LODADR gets load address
                    5705   5734 	push	h		;FDCADR gets FDC address
                    5706   5735 	dcr	h		;compute ROM address
                    5707   5736 	dcr	h		;200h below FDC reg address
                    5708   5737 	push	h		;ROMADR	
                    5709   5738 	
                    5710   5739 ;Go execute the loaded code, with registers and the sp
                    5711   5740 ;where the onboard ROMs would have left them.
                    5712   5741 
                    5713   5742 	xchg			;hl=LODADR
                    5714   5743 	pop	d		;de=ROMADR (for DOS)
                    5715   5744 
                    5716   5745 	lxi	b,eXEOFF	;execute 12 bytes into sector
                    5717   5746 	dad	b		;hl=execution address
                    5718   5747 
                    5719   5748 ; sp=ROMADR+2=00A2
                    5720   5749 ; de=address of onboard ROM
                    5721   5750 ; hl=code exec address (12-bytes into sector data in RAM)
                    5722   5751 ;
                    5723   5752 ;00a0: ROMADR=address of onboard ROM
                    5724   5753 ;00A2: FDCADR=address of FDC registers
                    5725   5754 ;00A4: LODADR=address beginning of sector in RAM
                    5726   5755 
                    5727   5756  endif ;MICROP
                    5728   5757  if MICROP and (ENINTS or CRXINT or TRXINT)
                    5729   5758 	di			;disable interrupts
                    5730   5759  endif ;MICROP and (ENINTS or CRXINT or TRXINT)
                    5731   5760  if MICROP
                    5732   5761 
                    5733   5762 	pchl			;execute boot loader from disk
                    5734   5763 
                    5735   5764 ;---Local Subroutine--------------------------------------
                    5736   5765 ;Read and validate sector 0
                    5737   5766 ;On Entry:
                    5738   5767 ;  hl=FDC data register address
                    5739   5768 ;  de=target address
                    5740   5769 ;On Exit:
                    5741   5770 ;  a=0 and Z set = read successful
                    5742   5771 ;  a<>0 and Z clear = read fail (checksum or wrong sector)
                    5743   5772 ;  c=0
                    5744   5773 ;Trashes b
                    5745   5774 ;---------------------------------------------------------
                    5746   5775 READ0:	push	d		;buffer address
                    5747   5776 
                    5748   5777 	lxi	b,SCLEN/2	;b=sector 0, c=bytes to read/2
                    5749   5778 				;hl=FDC command reg
                    5750   5779 	call	RDSECH		;read the sector into (de)
                    5751   5780 				;returns a<>0 if read error
                    5752   5781 				;returns c=0
                    5753   5782 
                    5754   5783 	pop	h		;buffer address
                    5755   5784 	mov	e,c		;de=FDC address (c=0)
                    5756   5785 
                    5757   5786 ;Verify metadata from the loaded sector says track 0, sector 0
                    5758   5787 ;(a=0 if RDSECH thought the read was successful)
                    5759   5788 
                    5760   5789 	ora	m		;a=track number from disk data
                    5761   5790 	inx	h		;(hl)=sec number from disk data
                    5762   5791 	ora	m		;verify track and sec are zero
                    5763   5792 	dcx	h		;hl=buffer address
                    5764   5793 
                    5765   5794 	xchg			;put pointers back
                    5766   5795 	ret
                    5767   5796 
                    5768   5797 ;---Local Subroutine-------------------
                    5769   5798 ;Step head Once
                    5770   5799 ;On Entry:
                    5771   5800 ;  b=retry counter
                    5772   5801 ;  c=command (Step in or step out)
                    5773   5802 ;  e=0
                    5774   5803 ;  hl=command register address
                    5775   5804 ;On Exit:
                    5776   5805 ;  Abort (rudely) if b decremetned to 0
                    5777   5806 ;  a=status register value
                    5778   5807 ;  b decremented
                    5779   5808 ;  de=0
                    5780   5809 ;--------------------------------------
                    5781   5810 HSTEP:	dcr	b
                    5782   5811 	jz	T0FAIL		;Can't find track 0
                    5783   5812 				;..or get off track 0
                    5784   5813 
                    5785   5814 	mov	m,c		;Step in or out now
                    5786   5815 
                    5787   5816 ;delay for >40 mS
                    5788   5817 
                    5789   5818 	mvi	d,7		;delay for 7*5.89=41.2 mS
                    5790   5819 
                    5791   5820 ;Fall into DELSTA to delay and read the status register
                    5792   5821 
                    5793   5822 ;---Local Subroutine---------------------------------
                    5794   5823 ;Delay 5.89 mS times value specified in d, and return
                    5795   5824 ;the FDC status register value. Looks at 2mhz/4mhz
                    5796   5825 ;jumper on the FDC to determine CPU speed.
                    5797   5826 ;
                    5798   5827 ;On Entry:
                    5799   5828 ;  d=delay value in 5.89 mS units (max value=127)
                    5800   5829 ;  e=0 (low byte of delay counter, really)
                    5801   5830 ;  hl=address of FDC control register
                    5802   5831 ;On Exit:
                    5803   5832 ;  a=status register value
                    5804   5833 ;  de=0
                    5805   5834 ;----------------------------------------------------
                    5806   5835 DELSTA:	mov	a,m		;a=sector register from FDC
                    5807   5836 	ani	DTMR		;see if 4mhz jumper in place	
                    5808   5837 	mov	a,d		;a=requested delay
                    5809   5838 	jnz	NOT4M		;not 4mhz
                    5810   5839 	rlc			;double the count for 4mhz CPU
                    5811   5840 
                    5812   5841 NOT4M:	mov	d,a		;save adjusted delay count
                    5813   5842 
                    5814   5843 ;we re-read the status register every pass for delay
                    5815   5844 
                    5816   5845 DLOOP:	dcx	d		;(5)
                    5817   5846 	mov	a,e		;(5)
                    5818   5847 	ora	d		;(4)
                    5819   5848 	inx	h		;(5) point to status register
                    5820   5849 	mov	a,m		;(7) read status register
                    5821   5850 	dcx	h		;(5) point to control register
                    5822   5851 	rz			;(5 not taken)
                    5823   5852 	jmp	DLOOP		;(10) 46 cycles/pass
                    5824   5853 
                    5825   5854 ;---Error Routines---------
                    5826   5855 ;These all repair the stack
                    5827   5856 ;and return to the prompt.
                    5828   5857 ;--------------------------
                    5829   5858 T0FAIL:	call	CILPRT		;stuck or lost
                    5830   5859 	db	'Track ','0'+80h
                    5831   5860 	jmp	PFAIL		;adds ' error' and aborts
                    5832   5861 
                    5833   5862 RDERR:	call	CILPRT		;too many retries on reading
                    5834   5863 	db	'Rea','d'+80h
                    5835   5864 	jmp	PFAIL		;adds ' error' and aborts
                    5836   5865 
                    5837   5866 NCERR:	call	CILPRT		;can't find FDC
                    5838   5867 	db	'FD','C'+80h
                    5839   5868 
                    5840   5869 ;Fall into PFAIL
                    5841   5870 
                    5842   5871 PFAIL:	call	ILPRNT
                    5843   5872 	db	' fai','l'+80h
                    5844   5873 
                    5845   5874 	jmp	CABORT
                    5846   5875 
                    5847   5876 DNRERR:	call	CILPRT		;no disk probably
                    5848   5877 	db	'Drive not read','y'+80h
                    5849   5878 	jmp	CABORT
                    5850   5879 
                    5851   5880 ;---RAM Subroutine--------------------------------------
                    5852   5881 ;Read sector into RAM
                    5853   5882 ;This code gets moved into RAM at RDSEC
                    5854   5883 ;
                    5855   5884 ;On Entry at RDSEC:
                    5856   5885 ;  de=RAM buffer
                    5857   5886 ;  b=sector to read
                    5858   5887 ;  c=number of bytes to read/2
                    5859   5888 ;On Entry at RDSEC+3:
                    5860   5889 ;  hl=FDC control/sector register address
                    5861   5890 ;  de=RAM buffer
                    5862   5891 ;  b=sector to read
                    5863   5892 ;  c=number of bytes to read/2
                    5864   5893 ;On Exit:
                    5865   5894 ;  a=0 and Z set = read successful
                    5866   5895 ;  a<>0 and Z clear = checksum error
                    5867   5896 ;  c=0
                    5868   5897 ;  de=FDC data register address
                    5869   5898 ;  hl=next RAM address past this sector's data
                    5870   5899 ;Trashes b
                    5871   5900 ;-------------------------------------------------------
                    5872   5901 RDSROM:	lhld	FDCADR		;FDC registers
                    5873   5902 				;(sector register)
                    5874   5903 
                    5875   5904 wtSec:	mov	a,m		;sector status
                    5876   5905 	ani	SFLG		;wait for sector true
                    5877   5906 	jz	wtSec-OFFSET
                    5878   5907 
                    5879   5908 	mov	a,m		;re-read to be safe
                    5880   5909 	ani	SMASK		;get sector number alone
                    5881   5910 	xra	b		;right sector number?
                    5882   5911 	jnz	wtSec-OFFSET	;no, keep looking
                    5883   5912 
                    5884   5913 	inx	h		;hl=status register address
                    5885   5914 
                    5886   5915  endif ;MICROP
                    5887   5916  if MICROP and (ENINTS or CRXINT or TRXINT)
                    5888   5917 	di			;disable interrupts
                    5889   5918  endif ;MICROP and (ENINTS or CRXINT or TRXINT)
                    5890   5919  if MICROP
                    5891   5920 
                    5892   5921 wtXfer:	ora	m		;wait for transfer flag (bit 7)
                    5893   5922 	jp	wtXfer-OFFSET	;(10)
                    5894   5923 
                    5895   5924 	inx	h		;(5)hl=data register address
                    5896   5925 	mov	a,m		;(7)read & chuck sync byte
                    5897   5926 	xra	a		;(4)start with carry clear
                    5898   5927 	xchg			;(4)de=data register address
                    5899   5928 				;hl=target RAM address
                    5900   5929 
                    5901   5930 	mvi	b,0		;(7)initialize checksum
                    5902   5931 	nop			;(4)timing for FDC stall logic
                    5903   5932 	nop			;(4)
                    5904   5933 
                    5905   5934 ;Read sector data from disk into RAM two bytes at a time
                    5906   5935 ;de=FDC data register
                    5907   5936 ;hl=destination RAM address
                    5908   5937 
                    5909   5938 movSec:	ldax	d		;read data byte
                    5910   5939 	mov	m,a		;save in buffer
                    5911   5940 	inx	h
                    5912   5941 	adc	b		;update checksum
                    5913   5942 	mov	b,a
                    5914   5943 
                    5915   5944 	ldax	d		;repeat for 2nd byte
                    5916   5945 	mov	m,a
                    5917   5946 	inx	h
                    5918   5947 	adc	b
                    5919   5948 	mov	b,a
                    5920   5949 
                    5921   5950 	dcr	c		;decrement byte count
                    5922   5951 	jnz	movSec-OFFSET	;repeat until done
                    5923   5952  endif ;MICROP
                    5924   5953  if MICROP and (ENINTS or CRXINT or TRXINT)
                    5925   5954 	ei			;enable interrupts
                    5926   5955  endif ;MICROP and (ENINTS or CRXINT or TRXINT)
                    5927   5956  if MICROP
                    5928   5957 
                    5929   5958 ;Read and verify checksum
                    5930   5959 
                    5931   5960 	ldax	d		;a=checksum from disk
                    5932   5961 	xra	b		;compare to computed checksum	
                    5933   5962 	ret			;return result
                    5934   5963 
                    5935   5964 RDSEND	equ	$
                    5936   5965 RDSLEN	equ	RDSEND-RDSROM
                    5937   5966 OFFSET	equ	RDSROM-RDSEC	;address offsets
                    5938   5967 MICBUF	equ	RDSEND-OFFSET	;Micropolis Sec RAM buffer
                    5939   5968 
                    5940   5969  endif ;MICROP
                    5941   5970 
                    5942   5971 ;***Command ROutine Continuation**************************
                    5943   5972 ;BO (Boot from Northstar Double-Density Floppy Disk drive,
                    5944   5973 ;   with either a single- or double-density disk)
                    5945   5974 ;*********************************************************
                    5946   5975  if NSTARD
                    5947   5976 
                    5948   5977 GBOCMD:	lxi	b,0D00h+MAXTRYS	;Initialize c=retry counter
                    5949   5978 				;and b=index hunt counter
                    5950   5979 
                    5951   5980 ;----------------------------------------------------------
                    5952   5981 ;Start the spindle motors, select drive 1, and delay enough
                    5953   5982 ;time for the motor to spin up and the head to settle
                    5954   5983 ;----------------------------------------------------------
                    5955   5984 	lda	CTLCMD+CTLAS+CTLMO ;Motor on
                    5956   5985 
                    5957   5986 	lxi	d,3008h		;d=48 secs: motor spin-up delay
                    5958   5987 				;e=8: step-ins
                    5959   5988 	call	WSECTD
                    5960   5989 
                    5961   5990 	lxi	h,CTLORD+ORDSIN+ORDDS1	;Select drive 1
                    5962   5991 					;..(step in mode)
                    5963   5992 	mov	a,m
                    5964   5993 
                    5965   5994 ;-------------------------------------------------------
                    5966   5995 ;Wait for the index mark to ensure a disk is installed.
                    5967   5996 ;(The MDS-D will generate fake sector pulses if not.)
                    5968   5997 ;b=0DH here, for 12 sectors to try
                    5969   5998 ;hl=CTLORD+ORDSIN+ORDDS
                    5970   5999 ;-------------------------------------------------------
                    5971   6000 IWLOOP:	dcr	b		;Too many sectors?
                    5972   6001 	jz	INFERR		;y: no index hole
                    5973   6002 
                    5974   6003 	call	WSECT1		;wait for next sector
                    5975   6004 
                    5976   6005 	lda	CTLCMD+ORDST	;Get A-Status
                    5977   6006 	ani	SAIX		;Index hole?
                    5978   6007 	jz	IWLOOP		;n: keep looking
                    5979   6008 
                    5980   6009 ;----------------------
                    5981   6010 ;Home: Seek track 0
                    5982   6011 ;e=8 here
                    5983   6012 ;hl=CTLORD+ORDSIN+ORDDS
                    5984   6013 ;----------------------
                    5985   6014 
                    5986   6015 ;If already on track 0, step away.
                    5987   6016 
                    5988   6017 HOME:	lda	CTLCMD+CTLBS		;Read B-Status
                    5989   6018 	rar				;test SBT0: On track 0?
                    5990   6019 	cnc	STEP
                    5991   6020 
                    5992   6021 	jnc	T0STUK			;Stuck on track 0?
                    5993   6022 
                    5994   6023 ;Step out to track 0
                    5995   6024 ;h=E8h here
                    5996   6025 
                    5997   6026 	mvi	l,ORDDS1	;step out
                    5998   6027 	mov	e,h		;max number of tries
                    5999   6028 	call	STEP		;Step out to track 0
                    6000   6029 	jc	T0FAIL		;can't find track 0
                    6001   6030 
                    6002   6031 ;---------------------------------------------
                    6003   6032 ;Hunt: Wait for the double-density boot sector
                    6004   6033 ;h=E8h here
                    6005   6034 ;---------------------------------------------
                    6006   6035 	mov	b,h		;long timeout for several loops
                    6007   6036 
                    6008   6037 HUNT:	dcr	b		;timeout?
                    6009   6038 	jz	SNFERR
                    6010   6039 
                    6011   6040 	call	WSECT1		;Wait for next sector
                    6012   6041 
                    6013   6042 	lda	CTLCMD+CTLCS+CTLMO	;Read C-Status
                    6014   6043 	ani	SCSM			;Sector mask
                    6015   6044 	cpi	DDBSCR			;Found our boot sector?
                    6016   6045 	jnz	HUNT			;N: Keep looking
                    6017   6046 
                    6018   6047 ;Wait for hardware to say that read is enabled
                    6019   6048 ;(timer b should be between DBh and E8h - huge)
                    6020   6049 
                    6021   6050 WAITRD:	dcr	b		;(5)timeout?
                    6022   6051 	jz	SNFERR		;(10)
                    6023   6052 
                    6024   6053 	lda	CTLCMD+CTLAS	;(13)Read A-Status
                    6025   6054 	ani	SARE		;(7)Read enabled?
                    6026   6055 	jz	WAITRD		;(10)n: wait more
                    6027   6056 
                    6028   6057 ;Stall for about 68 uS on a 2 MHz 8080
                    6029   6058 ;or about 34 uS on a 4 MHz Z80
                    6030   6059 
                    6031   6060 	mvi	e,9
                    6032   6061 STAL68:	dcr	e		;(5)
                    6033   6062 	jnz	STAL68		;(10)end with e=0
                    6034   6063 
                    6035   6064 ;------------------------------------
                    6036   6065 ;Check for single-density disk, which
                    6037   6066 ;loads from a different sector
                    6038   6067 ;e=0 here
                    6039   6068 ;h=E8h here
                    6040   6069 ;------------------------------------
                    6041   6070 	lda	CTLCMD+CTLAS	;Read A-Status
                    6042   6071 	ani	SADD		;Double-density disk?
                    6043   6072 	jnz	GETSEC		;y: go read the sector
                    6044   6073 
                    6045   6074 ;---------------------------------------------
                    6046   6075 ;Single-density boot
                    6047   6076 ;Step in to track 1 and hunt for sector 8
                    6048   6077 ;(Sector 8 is a special 512-byte boot sector.)
                    6049   6078 ;---------------------------------------------
                    6050   6079 	inr	e		   ;e=1
                    6051   6080 	mvi	l,ORDSIN+ORDDS1	   ;Step in once to track 1
                    6052   6081 	call	STEP
                    6053   6082 
                    6054   6083 SDRSCT:	call	WSECT1		   ;Wait for 1 sector time
                    6055   6084 
                    6056   6085 	lda	CTLCMD+CTLCS+CTLMO ;Read C-Status
                    6057   6086 	ani	SCSM		   ;Sector mask
                    6058   6087 	cpi	SDBSCR		   ;single-density boot sector
                    6059   6088 	jnz	SDRSCT
                    6060   6089 
                    6061   6090 ;Fall into GETSEC
                    6062   6091 
                    6063   6092 ;----------------------------------------
                    6064   6093 ;Wait for the sector body.
                    6065   6094 ;Time out after a ridiculously long time.
                    6066   6095 ;b still has a large timeout value here
                    6067   6096 ;h=E8h here
                    6068   6097 ;----------------------------------------
                    6069   6098 GETSEC:	lxi	d,CTLCMD+CTLRD	;Select Read Data
                    6070   6099 
                    6071   6100  endif ;NSTARD
                    6072   6101  if NSTARD and (ENINTS or CRXINT or TRXINT)
                    6073   6102 	di			;disable interrupts
                    6074   6103  endif ;NSTARD and (ENINTS or CRXINT or TRXINT)
                    6075   6104  if NSTARD
                    6076   6105 
                    6077   6106 WATSEC:	dcr	b		;(5)timeout?
                    6078   6107 	jz	NSERR		;(10)
                    6079   6108 
                    6080   6109 	lda	CTLCMD+CTLAS	;(7)Read A-Status
                    6081   6110 	rrc			;(4)SABD set?
                    6082   6111 				;..(Sync chr detected)
                    6083   6112 	jnc	WATSEC		;(10)n: keep waiting
                    6084   6113 
                    6085   6114 ;------------------------------------------------------------
                    6086   6115 ;Read and validate the sector data
                    6087   6116 ;  Byte 0: <PA> High byte of target RAM address
                    6088   6117 ;  Bytes 1-511: Sector data
                    6089   6118 ;  Byte 512: CRC of Bytes 0-511
                    6090   6119 ;Bytes1-511 get written into RAM at <PA>01 through <PA+1>FF.
                    6091   6120 ; <PA> gets written to <PA>01 before getting overwritten by
                    6092   6121 ; byte 1. Note that <PA>00 never gets written
                    6093   6122 ;------------------------------------------------------------
                    6094   6123 	ldax	d		;read 1st disk data byte
                    6095   6124 	mov	h,a		;This is the target RAM page
                    6096   6125 
                    6097   6126 	mvi	l,1		;byte 1 in that page
                    6098   6127 	mov	m,a		;save page address (why?)
                    6099   6128 
                    6100   6129 	rlc			;Start CRC calculation
                    6101   6130 	mov	b,a		;b accumulates CRC
                    6102   6131 
                    6103   6132 ;Read the next 255 bytes (the remainder of the data that goes
                    6104   6133 ;into the 1st RAM page) into the specified RAM page
                    6105   6134 
                    6106   6135 RLOOP1:	ldax	d		;get a disk data byte
                    6107   6136 	mov	m,a		;write it to RAM
                    6108   6137 	xra	b		;compute CRC
                    6109   6138 	rlc
                    6110   6139 	mov	b,a		;..in b
                    6111   6140 	inr	l		;end of page data?
                    6112   6141 	jnz	RLOOP1		;n: get another byte
                    6113   6142 
                    6114   6143 ;Read the final 256 bytes into the next RAM page
                    6115   6144 
                    6116   6145 	inr	h		;Next RAM page
                    6117   6146 
                    6118   6147 RLOOP2:	ldax	d		;get a disk data byte
                    6119   6148 	mov	m,a		;write it to RAM
                    6120   6149 	xra	b		;compute CRC
                    6121   6150 	rlc
                    6122   6151 	mov	b,a		;..in b
                    6123   6152 	inr	l		;end of sector data?
                    6124   6153 	jnz	RLOOP2		;n: keep reading
                    6125   6154 
                    6126   6155 	ldax	d		;Get CRC byte
                    6127   6156 	xra	b		;Does it match?
                    6128   6157 	jnz	NSERR		;n: retry if possible
                    6129   6158 
                    6130   6159 ;-----------------------------------------
                    6131   6160 ;Success. Go execute the loaded code image
                    6132   6161 ;Like the MDS-D boot ROM, d contains the
                    6133   6162 ;high byte of the disk controller address,
                    6134   6163 ;in case the loaded code looks for this.
                    6135   6164 ;-----------------------------------------
                    6136   6165 	dcr	h		;get execution address
                    6137   6166 	mvi	l,0ah		;10th byte of load page
                    6138   6167 
                    6139   6168 	pchl			;Go execute loaded code
                    6140   6169 
                    6141   6170 ;---Local Subroutine-----------------
                    6142   6171 ;Wait 1 sector time (for next sector)
                    6143   6172 ;On Exit:
                    6144   6173 ;  a=0
                    6145   6174 ;  d=0
                    6146   6175 ;  Sector flag is cleared
                    6147   6176 ;------------------------------------
                    6148   6177 WSECT1:	mvi	d,1
                    6149   6178 
                    6150   6179 ;Fall into WSECTD
                    6151   6180 
                    6152   6181 ;---Local Subroutine---------------
                    6153   6182 ;Wait d sector times
                    6154   6183 ;On Entry:
                    6155   6184 ;  d=number of sector tines to wait
                    6156   6185 ;On Exit:
                    6157   6186 ;  a=0
                    6158   6187 ;  d=0
                    6159   6188 ;  Sector flag is cleared
                    6160   6189 ;----------------------------------
                    6161   6190 WSECTD:	lda	CTLCMD+CTLAS+CTLRSF ;Reset sector flag
                    6162   6191 
                    6163   6192 WSECTR:	lda	CTLCMD+CTLAS	    ;Read A-Status
                    6164   6193 	ora	a		    ;Test SASF (Sector flag)
                    6165   6194 				    ;clears carry too
                    6166   6195 	jp	WSECTR		    ;Wait for sector
                    6167   6196 
                    6168   6197 	dcr	d		    ;next sector
                    6169   6198 	lda	CTLCMD+CTLAS+CTLRSF ;Reset sector flag
                    6170   6199 	jnz	WSECTD		    ;more sectors to wait?
                    6171   6200 
                    6172   6201 	ret
                    6173   6202 
                    6174   6203 ;---Local Subroutine-------------
                    6175   6204 ;Step e tracks
                    6176   6205 ;On Entry:
                    6177   6206 ;  e=number of steps
                    6178   6207 ;  hl=step-in or step-out command
                    6179   6208 ;On Exit:
                    6180   6209 ;  Carry set if on track 0
                    6181   6210 ;Trashes a,de,l
                    6182   6211 ;--------------------------------
                    6183   6212 STEP:	mov	a,m		;issue command (Step level low)
                    6184   6213 	push	h		;remember original command
                    6185   6214 
                    6186   6215 	mov	a,l		;set step level high
                    6187   6216 	ori	ORDST
                    6188   6217 	mov	l,a
                    6189   6218 	mov	a,m		;Step level high
                    6190   6219 
                    6191   6220 	pop	h		;original command
                    6192   6221 	mov	a,m		;step level low again
                    6193   6222 
                    6194   6223 	mvi	d,2		;Wait for 2 sector times	
                    6195   6224 	call	WSECTD
                    6196   6225 
                    6197   6226 	lda	CTLCMD+CTLBS	;Read B-Status
                    6198   6227 	rar			;test SBT0: On track 0?
                    6199   6228 	rc			;y: done with Carry set
                    6200   6229 
                    6201   6230 	dcr	e
                    6202   6231 	jnz	STEP
                    6203   6232 
                    6204   6233 	ret			;with carry clear
                    6205   6234 
                    6206   6235 ;---Error Routines---------
                    6207   6236 ;These all repair the stack
                    6208   6237 ;and return to the prompt.
                    6209   6238 ;--------------------------
                    6210   6239 NSERR:	dcr	c		;More retries left?
                    6211   6240 	jnz	HOME		;y: try again
                    6212   6241 
                    6213   6242 SNFERR:	call	CILPRT
                    6214   6243 	db	'Secto','r'+80h
                    6215   6244 	jmp	NFERR		;recycle some code
                    6216   6245 
                    6217   6246 INFERR:	call	CILPRT
                    6218   6247 	db	'Inde','x'+80h
                    6219   6248 	jmp	NFERR		;recycle some code
                    6220   6249 
fcad                6221   6250 T0STUK:T0FAIL:	call	CILPRT
                    6222   6251 	db	'Track ','0'+80h
                    6223   6252 
                    6224   6253 ;Fall into NFERR
                    6225   6254 
                    6226   6255 NFERR:	call	ILPRNT
                    6227   6256 	db	' erro','r'+80h
                    6228   6257 	jmp	CABORT
                    6229   6258 
                    6230   6259  endif ;NSTARD
                    6231   6260 
                    6232   6261 ;***Command ROutine Continuation********************
                    6233   6262 ;BO (Boot from Northstar Single-Density Floppy Disk)
                    6234   6263 ;***************************************************
                    6235   6264  if NSTARS
                    6236   6265 
                    6237   6266 GBOCMD:	mvi	b,MAXTRYS	;INit retry count (10)
                    6238   6267 
                    6239   6268 ;(Re)load the boot sector
                    6240   6269 ;b=remaining retries. Stack is valid
                    6241   6270 ;turn on the drive motor and select the boot drive
                    6242   6271 
                    6243   6272 RETRY:	lda	CTLMO or CTLNOP	;Motors on & a status
                    6244   6273 	ani 	SAMO		;Motor already on? (retry?)
                    6245   6274 	jnz	SELECT		;Yes, no need to wait
                    6246   6275 
                    6247   6276 	mvi	d,32h		;Wait 32 sector times
                    6248   6277 	call	WSECTS		;..for motor to spin up
                    6249   6278 
                    6250   6279 SELECT:	lda	CTLDS0 or BDRIVE ;Select boot drive
                    6251   6280 	mvi	d,0DH		;Wait 13 sector tiems
                    6252   6281 	call	WSECTS		;..for head to settle
                    6253   6282 
                    6254   6283 ;Step in a few tracks in case we are lost
                    6255   6284 
                    6256   6285 	mvi	e,17		;max step-ins+1
                    6257   6286 
                    6258   6287 STIN:	dcr	e
                    6259   6288 	jz	T0STUK		;track 0 sensor stuck?
                    6260   6289 
                    6261   6290 	lxi 	h,CTLSTI	;step-in command
                    6262   6291 	mvi	c,1		;step 1 track inward
                    6263   6292 	call	STEP
                    6264   6293 	jnz	STIN		;still on track 0?
                    6265   6294 
                    6266   6295 ;Step out to track 0
                    6267   6296 
                    6268   6297 	lxi 	h,CTLSTO	;step-out command
                    6269   6298 	mvi	c,59h		;max 59 steps outward
                    6270   6299 	call	STEP
                    6271   6300 	jz	T0FAIL		;Can't find track 0
                    6272   6301 
                    6273   6302 ;------------------------
                    6274   6303 ;Hunt for the boot sector
                    6275   6304 ;------------------------
                    6276   6305 HUNT:	mvi	d,1		;Wait one sector time
                    6277   6306 	call	WSECTS
                    6278   6307 
                    6279   6308 	lda	CTLBST or CTLNOP ;Read B-status
                    6280   6309 	ani	SBSECT		;Get sector number
                    6281   6310 	cpi	BSECTR		;Desired sector?
                    6282   6311 	jnz	HUNT		;N: wait for it
                    6283   6312 
                    6284   6313 ;---------------
                    6285   6314 ;Set up for load
                    6286   6315 ;---------------
                    6287   6316 	lxi	h,LODADR	;RAM load address
                    6288   6317 	mvi	c,8dh		;Timeout count
                    6289   6318 
                    6290   6319 ;-------------------------------------------------------
                    6291   6320 ;Issue read command, and wait for the boot sector's data
                    6292   6321 ;--------------------------------------------------------
                    6293   6322 	lxi	d,CTLRD or CTLNOP ;Read data command
                    6294   6323 
                    6295   6324 WATSEC:	dcr	c		;timeout?
                    6296   6325 	jz	SNFERR
                    6297   6326 
                    6298   6327 	lda	CTLNOP		;Get A-status
                    6299   6328 	ani	SABDY		;Wait for Body
                    6300   6329 	jz	WATSEC		;n: keep waiting
                    6301   6330 
                    6302   6331  endif ;NSTARS
                    6303   6332  if NSTARS and (ENINTS or CRXINT or TRXINT)
                    6304   6333 	di			;disable interrupts
                    6305   6334  endif ;NSTARS and (ENINTS or CRXINT or TRXINT)
                    6306   6335  if NSTARS
                    6307   6336 ;----------------------------------
                    6308   6337 ;Read 256-byte sector data into RAM
                    6309   6338 ;This loop assumes the load address
                    6310   6339 ;low byte is 00.
                    6311   6340 ;----------------------------------
                    6312   6341 	mov	c,l		;initial CRC (l=0)
                    6313   6342 
                    6314   6343 RDLOOP:	ldax	d		;Read data byte
                    6315   6344 	mov	m,a		;Write to RAM
                    6316   6345 
                    6317   6346 	xra	c		;Compute CRC
                    6318   6347 	rlc
                    6319   6348 	mov	c,a
                    6320   6349 
                    6321   6350 	inr	l		;Next RAM address
                    6322   6351 	jnz	RDLOOP		;Read them all
                    6323   6352 
                    6324   6353 	ldax	d		;Read CRC
                    6325   6354 	xra	c		;Does it match?
                    6326   6355 	jnz	CRCERR		;n: CRC error
                    6327   6356 
                    6328   6357 ;-----------------------
                    6329   6358 ;Execute the loaded code
                    6330   6359 ;-----------------------
                    6331   6360 	jmp	EXEADR
                    6332   6361 
                    6333   6362 ;--------------------------------
                    6334   6363 ;CRC fail: retry sector if we can
                    6335   6364 ;--------------------------------
                    6336   6365 CRCERR:	dcr	b		;any retries left?
                    6337   6366 	jnz	RETRY
                    6338   6367 
                    6339   6368 ;Too many retries
                    6340   6369 
                    6341   6370 	call	CILPRT
                    6342   6371 	db	'CR','C'+80h
                    6343   6372 	jmp	RPTERR
                    6344   6373 
                    6345   6374 ;---Local Subroutine-------------
                    6346   6375 ;Step specified number of tracks
                    6347   6376 ;On Entry:
                    6348   6377 ;  c=number of tracks to step
                    6349   6378 ;  hl=step in or step out command
                    6350   6379 ;On Exit:
                    6351   6380 ;  Z clear if on track 0
                    6352   6381 ;trashes a,c,d
                    6353   6382 ;--------------------------------
                    6354   6383 STEP:	mov	a,m		;Set direction
                    6355   6384 
                    6356   6385 STPLUP:	lda	CTLSTS		;Set track-step flip flop
                    6357   6386 	xthl			;Delay
                    6358   6387 	xthl			;Delay
                    6359   6388 	lda 	CTLSTC		;Clear track-step flip flop
                    6360   6389 
                    6361   6390 	mvi	d,2		;Wait 2 sector times
                    6362   6391 	call	WSECTS
                    6363   6392 
                    6364   6393 	lda	CTLNOP		;Read A-status
                    6365   6394 	ani	SATR0		;At track 0?
                    6366   6395 	jz	STEP1		;No, keep stepping
                    6367   6396 
                    6368   6397 	ret			;Z clear: On track 0
                    6369   6398 
                    6370   6399 STEP1:	dcr	c		;More steps to do?
                    6371   6400 	jnz	STPLUP		;n: step again
                    6372   6401 
                    6373   6402 	ret			;Z set: not on track 0
                    6374   6403 
                    6375   6404 ;---Local Subroutine---------------
                    6376   6405 ;Wait d sector times
                    6377   6406 ;On Entry:
                    6378   6407 ;  d=number of sector times to wait
                    6379   6408 ;Trashes psw,d
                    6380   6409 ;----------------------------------
                    6381   6410 WSECTS:	lda 	CTLRSF		;Reset sector flag
                    6382   6411 
                    6383   6412 WSECT:	lda	CTLMO or CTLNOP	;Read A-status
                    6384   6413 	ani	SASF		;Sector pulse?
                    6385   6414 	jz	WSECT		;Wait for it
                    6386   6415 	dcr	d		;enough sectors?
                    6387   6416 	rz			;y: done
                    6388   6417 
                    6389   6418 	jmp	WSECTS		;n: Keep waiting
                    6390   6419 
                    6391   6420 ;---Error Routines---------
                    6392   6421 ;These all repair the stack
                    6393   6422 ;and return to the prompt.
                    6394   6423 ;--------------------------
                    6395   6424 T0STUK:
                    6396   6425 T0FAIL:	call	CILPRT
                    6397   6426 	db	'Track ','0'+80h
                    6398   6427 	jmp	NFERR
                    6399   6428 
                    6400   6429 SNFERR:	call	CILPRT
                    6401   6430 	db	'Secto','r'+80h
                    6402   6431 
                    6403   6432 ;Fall into NFERR
                    6404   6433 
                    6405   6434 NFERR:	call	ILPRNT
                    6406   6435 	db	' not foun','d'+80h
                    6407   6436 	jmp	CABORT
                    6408   6437 
                    6409   6438 
                    6410   6439  endif ;NSTARS
                    6411   6440 
                    6412   6441 ;***Command ROutine Continuation******************
                    6413   6442 ;BO (Boot from SD Systems Versafloppy disk or
                    6414   6443 ;    Versafloppy II disk, either minidisk or 8")
                    6415   6444 ;*************************************************
                    6416   6445  if VERSA1 or VERSA2 or SALFDC
                    6417   6446 
                    6418   6447 GBOCMD:	lxi	b,4000h+MAXTRYS	;b=home error code
                    6419   6448 				;c=Retry counter
                    6420   6449 
                    6421   6450   endif ;VERSA1 or VERSA2 or SALFDC
                    6422   6451  if VERSA1
                    6423   6452 
                    6424   6453 	mvi	a,(VDSEL0N + VINTEN) xor 0FFh ;select drive 0
                    6425   6454 
                    6426   6455  endif ;VERSA1
                    6427   6456  if VERSA2 or SALFDC
                    6428   6457 
                    6429   6458 	mvi	a,VDSEL0 + VMINI ;select drive 0,
                    6430   6459 				 ;..assume mini for now
                    6431   6460  endif ;VERSA2 or SALFDC
                    6432   6461  if VERSA1 or VERSA2 or SALFDC
                    6433   6462 
                    6434   6463 	out	VDRSEL
                    6435   6464 
                    6436   6465 	mvi	a,RESTOR	;Issue HOME command, load head
                    6437   6466 	out	VDCOM
                    6438   6467 
                    6439   6468 	mvi	a,4*CPUMHZ	;delay for 52 uS min
                    6440   6469 WDELAY:	dcr	a		;(5)
                    6441   6470 	jnz	WDELAY		;(10)
                    6442   6471 
                    6443   6472 HOME1:	in	VDSTAT		;Wait for restore to complete
                    6444   6473 	mov	d,a
                    6445   6474 	rrc			;test WD1793 busy bit
                    6446   6475 	jc	HOME1
                    6447   6476 
                    6448   6477 	mvi	a,SNORDY	;drive ready?
                    6449   6478 	ana	d
                    6450   6479 	jnz	DNRERR		;Fail if not ready
                    6451   6480 	
                    6452   6481 	mvi	a,STRAK0
                    6453   6482 	ana	d
                    6454   6483 	jz	T0FAIL		;Error if can't find home
                    6455   6484 
                    6456   6485 ;Assume successful home without checking
                    6457   6486 ;other error bits. Load at address 0.
                    6458   6487 
                    6459   6488 TRETRY:	lxi	h,VLOAD		;load address
                    6460   6489 
                    6461   6490 	mvi	a,1		;sector 0
                    6462   6491 	out	VSECT
                    6463   6492 
                    6464   6493 ;Enable auto-wait circuit
                    6465   6494 
                    6466   6495  endif ; VERSA1 or VERSA2 or SALFDC
                    6467   6496  if VERSA1
                    6468   6497 
                    6469   6498 	mvi	a,(VDSEL0N + VINTEN + VWAITN) xor 0FFh
                    6470   6499 
                    6471   6500  endif ;VERSA1
                    6472   6501  if VERSA2 or SALFDC
                    6473   6502 
                    6474   6503 	in	VDRSEL		;get drive sel, mini/maxi
                    6475   6504 	ori	VWAIT
                    6476   6505 
                    6477   6506  endif ;VERSA2 or SALFDC
                    6478   6507  if (VERSA1 or VERSA2 or SALFDC)
                    6479   6508 
                    6480   6509 	out	VDRSEL		;enable auto-wait	
                    6481   6510 
                    6482   6511  endif ;(VERSA1 or VERSA2 or SALFDC)
                    6483   6512  if (VERSA1 or VERSA2 or SALFDC) and (ENINTS or CRXINT or TRXINT)
                    6484   6513 	di			;disable interrupts
                    6485   6514  endif ;(VERSA1 or VERSA2 or SALFDC) and (ENINTS or CRXINT or TRXINT)
                    6486   6515  if (VERSA1 or VERSA2 or SALFDC)
                    6487   6516 
                    6488   6517 	mvi	a,RDSECT	;Read sector command
                    6489   6518 	out	VDCOM
                    6490   6519 
                    6491   6520 ;Loop to read the sector data into memory at hl
                    6492   6521 
                    6493   6522 	mvi	b,SECSIZ	;byte count
                    6494   6523 
                    6495   6524 RLOOP:	in	VDDATA		;read the data
                    6496   6525 	mov	m,a		;write it into memory
                    6497   6526 	inx	h		;Next memory address
                    6498   6527 	dcr	b
                    6499   6528 	jnz	RLOOP
                    6500   6529 
                    6501   6530 ;Turn off auto-wait
                    6502   6531 
                    6503   6532  endif ;VERSA1 or VERSA2 or SALFDC
                    6504   6533  if VERSA1
                    6505   6534 
                    6506   6535 	mvi	a,(VDSEL0N + VINTEN) xor 0FFh
                    6507   6536 
                    6508   6537  endif ;VERSA1
                    6509   6538  if VERSA2 or SALFDC
                    6510   6539 
                    6511   6540 	in	VDRSEL		;get drive sel, mini/maxi
                    6512   6541 	ani	VWAIT xor 0FFh
                    6513   6542 
                    6514   6543  endif ;VERSA2 or SALFDC
                    6515   6544  if VERSA1 or VERSA2 or SALFDC
                    6516   6545 
                    6517   6546 	out	VDRSEL		;disable auto-wait	
                    6518   6547 
                    6519   6548 ;Wait for command to complete
                    6520   6549 
                    6521   6550 RWAIT:	in	VDSTAT		;Disk status
                    6522   6551 	mov	b,a
                    6523   6552 	rrc			;test WD1793 busy bit
                    6524   6553 	jc	RWAIT
                    6525   6554 
                    6526   6555 ;Check status for any errors
                    6527   6556 
                    6528   6557 	mvi	a,SNORDY+SRNFER+SCRCER+SLOSTD
                    6529   6558 	ana	b		;any errors?
                    6530   6559 	jz	VBOOT		;N: go execute loaded code
                    6531   6560 
                    6532   6561 ;----------------------------------
                    6533   6562 ;Read fail. Try again if possible.
                    6534   6563 ;Give user feedback about retries.
                    6535   6564 ;  c=retry count-down
                    6536   6565 ;----------------------------------
                    6537   6566 	mov	b,a		;error code
                    6538   6567 
                    6539   6568  endif ;VERSA1 or VERSA2 or SALFDC
                    6540   6569  if VERSA2 or SALFDC
                    6541   6570 
                    6542   6571 ;If we tried a minidisk, then try 8" instead
                    6543   6572 	in	VDRSEL
                    6544   6573 	xri	VMINI
                    6545   6574 	out	VDRSEL
                    6546   6575 
                    6547   6576 	ani	VMINI		;Was it mini?
                    6548   6577 	jz	RBRTRY
                    6549   6578 
                    6550   6579  endif ;VERSA2 or SALFDC
                    6551   6580  if VERSA1 or VERSA2 or SALFDC
                    6552   6581 
                    6553   6582 	mvi	a,MAXTRYS+1
                    6554   6583 	cmp	c		;first retry?
                    6555   6584 	jnz	RBR1		;n: just print dot
                    6556   6585 
                    6557   6586 	call	CILPRT
                    6558   6587 	db	'Retryin','g'+80h
                    6559   6588 
                    6560   6589 RBR1:	call	ILPRNT
                    6561   6590 	db	'.'+80h
                    6562   6591 
                    6563   6592 	dcr	c		;too many retries?
                    6564   6593 	jnz	RBRTRY
                    6565   6594 
                    6566   6595 ;Fall into BOTERR
                    6567   6596 
                    6568   6597 ;---Error Routines---------
                    6569   6598 ;These all repair the stack
                    6570   6599 ;and return to the prompt.
                    6571   6600 ;On Entry:
                    6572   6601 ;  b=error code
                    6573   6602 ;--------------------------
                    6574   6603 BOTERR:	call	CILPRT
                    6575   6604 	db	'Boot failed:',' '+80h
                    6576   6605 
                    6577   6606 	mov	a,b		;error code
                    6578   6607 	call	PCAHEX
                    6579   6608 
                    6580   6609 	call	ILPRNT
                    6581   6610 	db	'h'+80h
                    6582   6611 
                    6583   6612 	jmp	CABORT
                    6584   6613 
                    6585   6614 T0FAIL:	call	CILPRT
                    6586   6615 	db	'Track 0 fai','l'+80h
                    6587   6616 	jmp	CABORT
                    6588   6617 
                    6589   6618 DNRERR:	call	CILPRT
                    6590   6619 	db	'Drive not read','y'+80h
                    6591   6620 	jmp	CABORT
                    6592   6621 
                    6593   6622  endif ;VERSA1 or VERSA2 or SALFDC
                    6594   6623 
                    6595   6624 ;***Command ROutine Continuation******************
                    6596   6625 ;BO (Boot from Tarbell Floppy Disk)
                    6597   6626 ;*************************************************
                    6598   6627  if TARBL1
                    6599   6628 GBOCMD:	mvi	a,TSEL0		;Select drive 0
                    6600   6629 	out	TEXTP
                    6601   6630  endif ;TARBL1
                    6602   6631 
                    6603   6632  if TARBL2
                    6604   6633 GBOCMD:	xra	a
                    6605   6634 	out	TEXTP0		;select drive 0
                    6606   6635 	out	TESTP1		;Memory bank 0	
                    6607   6636  endif ;TARBL2
                    6608   6637 
                    6609   6638  if (TARBL1 or TARBL2)
                    6610   6639 	lxi	b,4000h+MAXTRYS	;b=home error code
                    6611   6640 				;c=Retry counter
                    6612   6641 
                    6613   6642 TRETRY:	mvi	a,FINTCM	;Cancel any pending command
                    6614   6643 	out	TDCOM
                    6615   6644 
                    6616   6645 	mvi	a,4*CPUMHZ	;delay for 52 uS min
                    6617   6646 WDELAY:	dcr	a		;(5)
                    6618   6647 	jnz	WDELAY		;(10)
                    6619   6648 
                    6620   6649 HOME1:	in	TDSTAT		;Wait for cancel to complete
                    6621   6650 	rrc			;test WD1793 busy bit
                    6622   6651 	jc	HOME1
                    6623   6652 
                    6624   6653 	mvi	a,RESTOR	;Issue restore command
                    6625   6654 	out	TDCOM
                    6626   6655 
                    6627   6656 	in	TWAIT		;Wait for restore to complete
                    6628   6657 
                    6629   6658 	ora	a		;Test for success
                    6630   6659 	jm	DNRERR		;Fail if not ready
                    6631   6660 
                    6632   6661 	in	TDSTAT		;controller status
                    6633   6662 	ani	STRAK0		;b is home error code too
                    6634   6663 	jz	T0FAIL		;Error if can't find home
                    6635   6664 
                    6636   6665 ;Assume successful home without checking
                    6637   6666 ;other error bits. Load at address 0.
                    6638   6667 
                    6639   6668 	lxi	h,SLOAD		;Load address
                    6640   6669 
                    6641   6670 	mvi	a,1		;Load sector 1
                    6642   6671 	out	TSECT
                    6643   6672 
                    6644   6673 	mvi	a,RDSECT	;Read sector command
                    6645   6674 	out	TDCOM
                    6646   6675 
                    6647   6676 ;Loop to read the sector data into memory at hl
                    6648   6677 
                    6649   6678  endif ;(TARBL1 or TARBL2)
                    6650   6679  if (TARBL1 or TARBL2) and (ENINTS or CRXINT or TRXINT)
                    6651   6680 	di			;disable interrupts
                    6652   6681  endif ;(TARBL1 or TARBL2) and (ENINTS or CRXINT or TRXINT)
                    6653   6682  if (TARBL1 or TARBL2)
                    6654   6683 
                    6655   6684 RLOOP:	in	TWAIT		;(10)Wait for DRQ or INTRQ
                    6656   6685 
                    6657   6686 	ora	a		;(4)
                    6658   6687 	jp	RDONE		;(10)Done if INTRQ
                    6659   6688 
                    6660   6689 	in	TDDATA		;(10)read the data
                    6661   6690 	mov	m,a		;(7)write it into memory
                    6662   6691 	inx	h		;(5)Next memory address
                    6663   6692 	jmp	RLOOP		;(10) 56 cycles=28 uS
                    6664   6693 
                    6665   6694 ;Check status for any errors
                    6666   6695 
                    6667   6696 RDONE:	in	TDSTAT		;Disk status
                    6668   6697 	ani	SNORDY+SRNFER+SCRCER+SLOSTD
                    6669   6698 	jz	SBOOT		;N: go execute loaded code
                    6670   6699 
                    6671   6700 ;----------------------------------
                    6672   6701 ;Read fail. Try again if possible.
                    6673   6702 ;Give user feedback about retries.
                    6674   6703 ;  c=retry count-down
                    6675   6704 ;----------------------------------
                    6676   6705 	mov	b,a		;error code
                    6677   6706 
                    6678   6707 	mvi	a,MAXTRYS+1
                    6679   6708 	cmp	c		;first retry?
                    6680   6709 	jnz	RBR1		;n: just print dot
                    6681   6710 
                    6682   6711 	call	CILPRT
                    6683   6712 	db	'Retryin','g'+80h
                    6684   6713 
                    6685   6714 RBR1:	call	ILPRNT
                    6686   6715 	db	'.'+80h
                    6687   6716 
                    6688   6717 	dcr	c		;too many retries?
                    6689   6718 	jnz	RBRTRY
                    6690   6719 
                    6691   6720 ;Fall into BOTERR
                    6692   6721 
                    6693   6722 ;---Error Routines---------
                    6694   6723 ;These all repair the stack
                    6695   6724 ;and return to the prompt.
                    6696   6725 ;On Entry:
                    6697   6726 ;  b=error code
                    6698   6727 ;--------------------------
                    6699   6728 BOTERR:	call	CILPRT
                    6700   6729 	db	'Boot failed:',' '+80h
                    6701   6730 
                    6702   6731 	mov	a,b		;error code
                    6703   6732 	call	PCAHEX
                    6704   6733 
                    6705   6734 	call	ILPRNT
                    6706   6735 	db	'h'+80h
                    6707   6736 
                    6708   6737 	jmp	CABORT
                    6709   6738 
                    6710   6739 T0FAIL:	call	CILPRT
                    6711   6740 	db	'Track 0 fai','l'+80h
                    6712   6741 	jmp	CABORT
                    6713   6742 
                    6714   6743 DNRERR:	call	CILPRT
                    6715   6744 	db	'Drive not read','y'+80h
                    6716   6745 	jmp	CABORT
                    6717   6746 
                    6718   6747  endif ;TARBL1 or TARBL2
                    6719   6748 
                    6720   6749 ;========================
                    6721   6750 ;= Memon/80 Subroutines =
                    6722   6751 ;========================
                    6723   6752 
                    6724   6753 ;***Subroutine*******************
                    6725   6754 ;Report a verify error
                    6726   6755 ;On Entry:
                    6727   6756 ;  de=destination address of fail
                    6728   6757 ;  hl=source address of fail
                    6729   6758 ;Trashes a
                    6730   6759 ;********************************
fcad  c5            6731   6760 VERROR:	push	b
                    6732   6761 
fcae  cd 90 fd      6733   6762 	call	PHLADR		;Fail address on new line
                    6734   6763 				;also sets b=0, trashes c
                    6735   6764 
fcb1  cd a5 fd      6736   6765 	call	PMHCSM		;b=0 so source data to Console
                    6737   6766 
fcb4  cd 5d fd      6738   6767 	call	ILPRNT
fcb7  a0            6739   6768 	db	' '+80h
                    6740   6769 
fcb8  1a            6741   6770 	ldax	d		;destination data
fcb9  cd a6 fd      6742   6771 	call	PAHCSM		;b=0 so print on Console
                    6743   6772 
fcbc  cd 5d fd      6744   6773 	call	ILPRNT
fcbf  bf            6745   6774 	db	'?'+80h		;flag the error
                    6746   6775 
fcc0  c1            6747   6776 	pop	b
                    6748   6777 
                    6749   6778 ;Fall into CPAUSE for Pause and abort opportunity
                    6750   6779 
                    6751   6780 ;***Subroutine**************************************
                    6752   6781 ;Get a keyboard character, abort if control-C, pause
                    6753   6782 ;until the next keyboard character if anything else.
                    6754   6783 ;On Exit:
                    6755   6784 ;  a=keyboard chr
                    6756   6785 ;***************************************************
fcc1  cd d1 fc      6757   6786 CPAUSE:	call	CHKKBD		;anything from the keyboard?
fcc4  c8            6758   6787 	rz			;N: done
                    6759   6788 
                    6760   6789 ;Fall into GETKBD to wait for the user
                    6761   6790 
                    6762   6791 ;***Subroutine****************************************
                    6763   6792 ;Get a keyboard character, abort if CABKEY (control-C)
                    6764   6793 ;On Exit:
                    6765   6794 ;  a=keyboard chr
                    6766   6795 ;  Z set if BS or delete
                    6767   6796 ;*****************************************************
                    6768   6797  if not TPORT
                    6769   6798 GETTPD:				;No transfer port
                    6770   6799  endif ;not TPORT		;..so use the console
                    6771   6800 
fcc5  cd d1 fc      6772   6801 GETKBD:	call	CHKKBD		;get kbd chr, test for ^C
fcc8  ca c5 fc      6773   6802 	jz	GETKBD		;wait for chr
                    6774   6803 
fccb  fe 7f         6775   6804 	cpi	DEL		;delete?
fccd  c8            6776   6805 	rz
fcce  fe 08         6777   6806 	cpi	BS		;backspace?
fcd0  c9            6778   6807 	ret
                    6779   6808 
                    6780   6809 ;***Subroutine*********************************
                    6781   6810 ;Get keyboard status. if a chr is waiting, then
                    6782   6811 ;return it in a with parity stripped. Abort if
                    6783   6812 ;CABKEY (control-C).
                    6784   6813 ;On Exit:
                    6785   6814 ;  if a chr is waiting, then chr is in a
                    6786   6815 ;  if no chr waiting, Z set, a=0
                    6787   6816 ;**********************************************	
fcd1  cd df fd      6788   6817 CHKKBD:	call	KSTAT		;anything typed?
fcd4  c8            6789   6818 	rz			;N: ret W/ Z set
                    6790   6819 
fcd5  cd d4 fd      6791   6820 	call	KDATA		;Y:get chr, strip parity
fcd8  fe 03         6792   6821 	cpi	CABKEY		;abort character typed?
fcda  c0            6793   6822 	rnz
                    6794   6823 
fcdb  c3 0b fd      6795   6824 	jmp	CABORT		;repair stack, go to MAIN
                    6796   6825 
                    6797   6826 ;***Subroutine*****************************************
                    6798   6827 ;Get 2 hex digits from the Transfer Port, combine them
                    6799   6828 ;into one byte, and add the result to the checksum in d
                    6800   6829 ;On Entry:
                    6801   6830 ;  d=checksum so far
                    6802   6831 ;On Exit:
                    6803   6832 ;  b=byte of data
                    6804   6833 ;  a=d=new checksum value
                    6805   6834 ;  Z flag set if checksum is now 0
                    6806   6835 ;  all other registers preserved, unless error abort
                    6807   6836 ;******************************************************
fcde  cd ee fc      6808   6837 GTPBYT:	call	GTPNIB		;get high nibble
fce1  87            6809   6838 	add	a		;shift high nibble up
fce2  87            6810   6839 	add	a
fce3  87            6811   6840 	add	a
fce4  87            6812   6841 	add	a
fce5  47            6813   6842 	mov	b,a
fce6  cd ee fc      6814   6843 	call	GTPNIB		;get low nibble
                    6815   6844 
fce9  b0            6816   6845 	ora	b		;combine nibbleS
fcea  47            6817   6846 	mov	b,a		;save result for return
fceb  82            6818   6847 	add	d		;Compute checksum
fcec  57            6819   6848 	mov	d,a		;ret with checksum in a & d
fced  c9            6820   6849 	ret
                    6821   6850 
                    6822   6851 ;---Local Subroutine--------------------
                    6823   6852 ;Get a hex digit from the Transfer Port,
                    6824   6853 ;validate it, and return it in a<3:0>
                    6825   6854 ;---------------------------------------
fcee  cd 7c fd      6826   6855 GTPNIB:	call	GETTPD		;get Tx port byte
fcf1  cd 4c fd      6827   6856 	call	HEXCON		;convert hex to binary
fcf4  d8            6828   6857 	rc			;carry means okay
                    6829   6858 
                    6830   6859 ;Abort: ASCII character error - not a valid hex digit
                    6831   6860 
fcf5  cd 59 fd      6832   6861 	call	CILPRT
fcf8  43 68 f2      6833   6862 	db	'Ch','r'+80h
                    6834   6863 
fcfb  c3 07 fd      6835   6864 	jmp	CMDERR		;error handler
                    6836   6865 
                    6837   6866 ;***Subroutine*****************************************
                    6838   6867 ;Get two hex values from the keyboard input line buffer
                    6839   6868 ;abort to CMDERR if none provided
                    6840   6869 ;On Entry:
                    6841   6870 ;  de=address of next item in the input line buffer
                    6842   6871 ;On Exit:
                    6843   6872 ;  1st hex value is at top of the stack
                    6844   6873 ;  prior hl value is next on the stack
                    6845   6874 ;  hl=2nd hex value
                    6846   6875 ;  de advanced past both hex values
                    6847   6876 ;  abort to CMDERR if no value found
                    6848   6877 ;******************************************************
fcfe  e3            6849   6878 GETHX2:	xthl			;save old hl
fcff  cd 02 fd      6850   6879 	call	GETHEX		;get 1st hex value
                    6851   6880 
                    6852   6881 ;Fall into GETHEX to get 2nd hex value
                    6853   6882 
                    6854   6883 ;***Subroutine**************************************
                    6855   6884 ;Get a hex value from the keyboard input line buffer
                    6856   6885 ;abort to CMDERR if none provided
                    6857   6886 ;On Entry:
                    6858   6887 ;  de=address of next item in the input line buffer
                    6859   6888 ;On Exit:
                    6860   6889 ;  prior hl value is on the stack
                    6861   6890 ;  hl=value
                    6862   6891 ;  de advanced past chr
                    6863   6892 ;  abort to CMDERR if no value found
                    6864   6893 ;***************************************************
fd02  e3            6865   6894 GETHEX:	xthl			;save old hl
fd03  cd a0 f8      6866   6895 	call	PHFHEX		;restore our return address
                    6867   6896 				;get hl=hex value
fd06  d0            6868   6897 	rnc
                    6869   6898 
                    6870   6899 ;Fall into CMDERR if no hex value provided
                    6871   6900 
                    6872   6901 ;*********************
                    6873   6902 ;command Error Handler
                    6874   6903 ;*********************
fd07  cd 59 fd      6875   6904 CMDERR:	call	CILPRT
fd0a  bf            6876   6905 	db	'?'+80h
                    6877   6906 
                    6878   6907 ;Fall into CABORT
                    6879   6908 
                    6880   6909 ;*********************************************
                    6881   6910 ;Command abort: repair stack and go to MAIN
                    6882   6911 ;On Entry:
                    6883   6912 ;
                    6884   6913 ; if TPORT:
                    6885   6914 ;  Bottom of stack (XXFF)=Transfer Port flag
                    6886   6915 ;                  (XXFE)=junk
                    6887   6916 ;  next on stack (XXFc, XXFD)=MAIN
                    6888   6917 ;
                    6889   6918 ; if not TPORT:
                    6890   6919 ;  Bottom of stack (XXFE, XXFF)=MAIN
                    6891   6920 ;*********************************************
fd0b                6892   6921 CABORT:
                    6893   6922 
                    6894   6923  if RAMHNT and TPORT
fd0b  cd b3 fa      6895   6924 	call	RAMPAG		;get hl=stack address
fd0e  2e ac         6896   6925 	mvi	l,(STACK-4) and 0FFh ;return address on stack
fd10  f9            6897   6926 	sphl			;fix stack
fd11  c9            6898   6927 	ret			;return to MAIN
                    6899   6928  endif ;RAMHNT and TPORT
                    6900   6929 
                    6901   6930  if RAMHNT and (not TPORT)
                    6902   6931 	call	RAMPAG		;get hl=stack address
                    6903   6932 	mvi	l,(STACK-2) and 0FFh ;return address on stack
                    6904   6933 	sphl			;fix stack
                    6905   6934 	ret			;return to MAIN
                    6906   6935  endif ;RAMHNT and (not TPORT)
                    6907   6936 
                    6908   6937 
                    6909   6938  if (not RAMHNT) and TPORT
                    6910   6939 	lxi	sp,STACK-4
                    6911   6940 	ret			;return to MAIN
                    6912   6941  endif ;(not RAMHNT) and TPORT
                    6913   6942 
                    6914   6943  if (not RAMHNT) and (not TPORT)
                    6915   6944 	lxi	sp,STACK-2
                    6916   6945 	ret			;return to MAIN
                    6917   6946  endif ;not RAMHNT and (not TPORT)
                    6918   6947 
                    6919   6948 ;***Subroutine**************************************
                    6920   6949 ;Read a command line from the keyboard, echoing and
                    6921   6950 ;saving it in the input line buffer. CR input ends
                    6922   6951 ;the sequence. LBCHR replaces the terminating CR
                    6923   6952 ;with 0 for easy testing later.
                    6924   6953 ;On Exit:
                    6925   6954 ;  Complete command line is in the input line buffer
                    6926   6955 ;  de=address of the first non-space chr on the line
                    6927   6956 ;  Carry set if nothing but spaces found
                    6928   6957 ;***************************************************
fd12  e5            6929   6958 GETLIN:	push	h
                    6930   6959 
                    6931   6960  if RAMHNT
fd13  cd b3 fa      6932   6961 	call	RAMPAG		;get RAM address
fd16  2e b0         6933   6962 	mvi	l,RAMBUF	;buffer location in page
                    6934   6963  endif ;RAMHNT
                    6935   6964 
                    6936   6965  if not RAMHNT
                    6937   6966 	lxi	h,RAMBUF
                    6938   6967  endif ;not RAMHNT
                    6939   6968 
fd18  e5            6940   6969 	push	h		;save input line buffer'S
                    6941   6970 				;..start address
                    6942   6971 
                    6943   6972 ;Get & echo chrs, stashing them in the input line buffer
                    6944   6973 ;at hl, until a CR is encountered or the line overflows
                    6945   6974 
fd19                6946   6975 GLLOOP:
                    6947   6976  if not HELPC
                    6948   6977 	mvi	a,(RAMBUF+LBSIZE-1) and 0FFh ;input buf full?
                    6949   6978  endif ;not HELPC
                    6950   6979  if HELPC
fd19  3e fe         6951   6980 	mvi	a,(RAMBUF+LBSIZE-2) and 0FFh ;input buf full?
                    6952   6981  endif ;HELPC
                    6953   6982 
fd1b  95            6954   6983 	sub	l		;carry set if full
                    6955   6984 
fd1c  d4 30 fd      6956   6985 	cnc	LBCHR		;N:get another character
fd1f  d2 19 fd      6957   6986 	jnc	GLLOOP		;carry means CR found
                    6958   6987 
fd22  af            6959   6988 	xra	a
fd23  77            6960   6989 	mov	m,a		;replace CR with a null
                    6961   6990 
                    6962   6991  if HELPC
fd24  23            6963   6992 	inx	h		;install another null
fd25  77            6964   6993 	mov	m,a		;..for single-chr command
                    6965   6994  endif ;HELPC
                    6966   6995 
fd26  d1            6967   6996 	pop	d		;de=line buffer address
fd27  e1            6968   6997 	pop	h		;restore original hl
                    6969   6998 
                    6970   6999 ;Fall into SSPACE to skip leading spaces
                    6971   7000 
                    6972   7001 ;***Subroutine*************************************
                    6973   7002 ;Scan past spaces in line buffer, looking for the
                    6974   7003 ;first non-space character
                    6975   7004 ;On Entry:
                    6976   7005 ;  de=starting address within the input line buffer
                    6977   7006 ;On Exit:
                    6978   7007 ;  Carry set if no chr or only control chrs found
                    6979   7008 ;  a=character value if found, 0 if end of line
                    6980   7009 ;  de advanced past spaces
                    6981   7010 ;**************************************************
fd28  1a            6982   7011 SSPACE:	ldax	d	;get next character
                    6983   7012 
fd29  fe 20         6984   7013 	cpi	' '	;another space?
                    6985   7014 			;carry set for any ctrl chr
fd2b  c0            6986   7015 	rnz		;carry clear for all else
                    6987   7016 
fd2c  13            6988   7017 	inx	d	;next scan address
fd2d  c3 28 fd      6989   7018 	jmp	SSPACE	;keep skipping
                    6990   7019 
                    6991   7020 ;***Subroutine****************************************
                    6992   7021 ;Get, echo, and store a Console character in the input
                    6993   7022 ;line buffer. Handle deletes and backspaces. This
                    6994   7023 ;assumes that the line buffer is all in one page. CR's
                    6995   7024 ;are not echoed, but are replaced with 0.
                    6996   7025 ;On Entry:
                    6997   7026 ;  hl=next free spot in the input line buffer
                    6998   7027 ;On Exit (no deletes, no CR):
                    6999   7028 ;  chr stored in buffer at original hl
                    7000   7029 ;  hl=hl+1
                    7001   7030 ;  Carry clear
                    7002   7031 ;On Exit (CR)
                    7003   7032 ;  Carry set
                    7004   7033 ;On Exit (BS or DEL)
                    7005   7034 ;  hl=hl-1
                    7006   7035 ;  Carry clear
                    7007   7036 ;*****************************************************
fd30  cd c5 fc      7008   7037 LBCHR:	call	GETKBD		;get a chr, test BS & DEL
fd33  ca 40 fd      7009   7038 	jz	LDELET		;BS or delete?
                    7010   7039 
fd36  fe 0d         7011   7040 	cpi	CR
fd38  37            7012   7041 	stc			;flag CR found
fd39  c8            7013   7042 	rz
                    7014   7043 
fd3a  3f            7015   7044 	cmc			;clear carry for ret
fd3b  77            7016   7045 	mov	m,a		;enqueue
fd3c  2c            7017   7046 	inr	l		;Bump line buffer pointer
fd3d  c3 c8 fd      7018   7047 	jmp	PRINTA		;echo & ret with carry clear
                    7019   7048 
                    7020   7049 ;Backspace if possible
                    7021   7050 
fd40  7d            7022   7051 LDELET:	mov	a,l		;buffer size
fd41  fe b0         7023   7052 	cpi	RAMBUF and 0FFh	;back up if we can
fd43  c8            7024   7053 	rz			;done if not (carry clear)
                    7025   7054 	
fd44  cd 5d fd      7026   7055 	call	ILPRNT		;back up, clear Carry
fd47  08 20 88      7027   7056 	db	BS,' ',BS+80h	;erase old chr & back up	
                    7028   7057 
fd4a  2d            7029   7058 	dcr	l		;back up
                    7030   7059 
fd4b  c9            7031   7060 	ret
                    7032   7061 
                    7033   7062 ;***Subroutine************************
                    7034   7063 ;Convert ASCII hex digit to binary
                    7035   7064 ;On Entry:
                    7036   7065 ;  a=chr to convert
                    7037   7066 ;On Exit:
                    7038   7067 ;  a=binary
                    7039   7068 ;  Carry set if OK, clear if bogus chr
                    7040   7069 ;*************************************
fd4c  d6 30         7041   7070 HEXCON:	sui	'0'		;remove ASCII bias
fd4e  fe 0a         7042   7071 	cpi	10
fd50  d8            7043   7072 	rc			;if 0-9 then we're done
                    7044   7073 
fd51  d6 11         7045   7074 	sui	9+('A'-'9')	;should be 0-5 now
fd53  fe 06         7046   7075 	cpi	6		;gap chr or too high?
fd55  d0            7047   7076 	rnc			;error: return W/O carry
                    7048   7077 
fd56  d6 f6         7049   7078 	sui	0F6h		;add 0Ah, set Carry
fd58  c9            7050   7079 	ret
                    7051   7080 
                    7052   7081 ;***Subroutine***********************************
                    7053   7082 ;Print CR LF, followed by inline message at (sp)
                    7054   7083 ;on Console. (CallS to CILPRT are followed by the
                    7055   7084 ;string.) The last string byte has its msb set
                    7056   7085 ;On Exit:
                    7057   7086 ;  carry & Z cleared
                    7058   7087 ;  Interrupts enabled if ENINTS=TRUE
                    7059   7088 ;Trashes a. All other registers preserved
                    7060   7089 ;************************************************
fd59                7061   7090 CILPRT:
                    7062   7091  if (ENINTS or CRXINT or TRXINT)
                    7063   7092 	ei			;enable interrupts
                    7064   7093  endif ;(ENINTS or CRXINT or TRXINT)
                    7065   7094 
fd59  cd 5d fd      7066   7095 	call	ILPRNT
                    7067   7096  if not HELPC
                    7068   7097 	db	CR,LF+80h
                    7069   7098  endif ;not HELPC
                    7070   7099 
                    7071   7100  if HELPC
fd5c  8d            7072   7101 	db	CR+80h
                    7073   7102  endif ;HELPC
                    7074   7103 
                    7075   7104 ;Fall into ILPRNT
                    7076   7105 
                    7077   7106 ;***Subroutine********************************
                    7078   7107 ;Print inline message at (sp) on Console.
                    7079   7108 ;(Calls to ILPRNT are followed by the string.)
                    7080   7109 ;The last string byte has its msb set.
                    7081   7110 ;On Exit:
                    7082   7111 ;  carry & Z cleared
                    7083   7112 ;Trashes a. All other registers preserved
                    7084   7113 ;
                    7085   7114 ;The help screen has a lot of lines, making it
                    7086   7115 ;more efficient to follow all CRs with LFs
                    7087   7116 ;automatically.. Otherwise, it's not worth it.
                    7088   7117 ;*********************************************
fd5d  e3            7089   7118 ILPRNT:	xthl			;save hl, get msg addr
                    7090   7119 
fd5e  7e            7091   7120 IPLOOP:	mov	a,m		;LOOP through message
fd5f  e6 7f         7092   7121 	ani	7Fh		;strip end-marker
fd61  cd c8 fd      7093   7122 	call	PRINTA
                    7094   7123 
                    7095   7124  if HELPC
fd64  fe 0d         7096   7125 	cpi	CR
fd66  3e 0a         7097   7126 	mvi	a,LF
fd68  cc c8 fd      7098   7127 	cz	PRINTA
                    7099   7128  endif ;HELPC
                    7100   7129 
fd6b  b6            7101   7130 	ora	m		;End? (clears carry too)
fd6c  23            7102   7131 	inx	h
fd6d  f2 5e fd      7103   7132 	jp	IPLOOP		;test msb in memory string
                    7104   7133 
fd70  e3            7105   7134 	xthl			;restore hl
                    7106   7135 				;..get ret address
fd71  c9            7107   7136 	ret
                    7108   7137 
                    7109   7138 ;***Subroutine***************************************
                    7110   7139 ;Test which port is the Transfer Port
                    7111   7140 ;On Entry:
                    7112   7141 ;  sp points into the RAM page
                    7113   7142 ;  RAM page flag=0 for Console, <>0 for Transfer Port
                    7114   7143 ;On Exit:
                    7115   7144 ;  Z set only if the Transfer Port is the Console
                    7116   7145 ;****************************************************
                    7117   7146  if TPORT
fd72  e5            7118   7147 TESTTP:	push	h
                    7119   7148  endif ;TPORT
                    7120   7149 
                    7121   7150  if TPORT and RAMHNT
fd73  cd b3 fa      7122   7151 	call	RAMPAG		;find RAM page
fd76  2e af         7123   7152 	mvi	l,(STACK-1) and 0FFh ;get flag from RAM page
                    7124   7153  endif ;TPORT and RAMHNT
                    7125   7154 
                    7126   7155  if TPORT and (not RAMHNT)
                    7127   7156 	lxi	h,STACK-1
                    7128   7157  endif ;TPORT and (not RAMHNT)
                    7129   7158 
                    7130   7159  if TPORT
fd78  34            7131   7160 	inr	m		;test flag
fd79  35            7132   7161 	dcr	m		;Z means disabled
                    7133   7162 
fd7a  e1            7134   7163 	pop	h
fd7b  c9            7135   7164 	ret
                    7136   7165  endif ;TPORT
                    7137   7166 
                    7138   7167 ;***Subroutine******************************************
                    7139   7168 ;Get a byte from the Transfer Port
                    7140   7169 ;Strips parity,  checks for control-C abort
                    7141   7170 ;from the Console keyboard
                    7142   7171 ;On Entry:
                    7143   7172 ;  sp points into the RAM page
                    7144   7173 ;  RAM page byte FE=0 for Console, <>0 for Transfer Port
                    7145   7174 ;On Exit:
                    7146   7175 ;  chr in a, with parity stripped
                    7147   7176 ;*******************************************************
                    7148   7177  if TPORT
fd7c  cd 72 fd      7149   7178 GETTPD:	call	TESTTP		;which port?
fd7f  ca c5 fc      7150   7179 	jz	GETKBD		;Z means Console
                    7151   7180 
fd82  cd d1 fc      7152   7181 GTPLUP:	call	CHKKBD		;user abort?
fd85  cd e7 fd      7153   7182 	call	TPISTA		;Transfer Port chr?
fd88  ca 82 fd      7154   7183 	jz	GTPLUP
                    7155   7184  endif ;TPORT
                    7156   7185 
                    7157   7186  if TPORT and (not TMEMAP) and (not TRXINT)
fd8b  db 22         7158   7187 	in	TDATA		;get Transfer Port chr
fd8d  e6 7f         7159   7188 	ani	7Fh		;strip parity
fd8f  c9            7160   7189 	ret
                    7161   7190  endif ;TPORT and (not TMEMAP) and (not TRXINT)
                    7162   7191 
                    7163   7192  if TPORT and TMEMAP and (not TRXINT)
                    7164   7193 	lda	TDATA		;get Transfer Port chr
                    7165   7194 	ani	7Fh		;strip parity
                    7166   7195 	ret
                    7167   7196  endif ;TPORT and TMEMAP and (not TRXINT)
                    7168   7197 
                    7169   7198  if TPORT and TRXINT
                    7170   7199 	call	TPIDAI
                    7171   7200 	ani	7Fh		;strip parity
                    7172   7201 	ret
                    7173   7202  endif ;TPORT and TRXINT
                    7174   7203 
                    7175   7204 ;***Subroutine*******************
                    7176   7205 ;Print hl on a new line in hex on
                    7177   7206 ;the Console, followed by ': '
                    7178   7207 ;Trashes psw,bc
                    7179   7208 ;********************************
fd90  cd 59 fd      7180   7209 PHLADR:	call	CILPRT		;CR LF space begins line
fd93  a0            7181   7210 	db	' '+80h
                    7182   7211 
fd94  cd 9d fd      7183   7212 	call	PHLCHX		;hl=address on Console
                    7184   7213 				;Trashes bc
                    7185   7214 
                    7186   7215 ;Fall into PCCOLS to print ': '
                    7187   7216 
                    7188   7217 ;***Subroutine*******************
                    7189   7218 ;Print ': ' on the Console
                    7190   7219 ;Trashes psw
                    7191   7220 ;********************************
fd97  cd 5d fd      7192   7221 PCCOLS:	call	ILPRNT		;print colon space
fd9a  3a a0         7193   7222 	db	':',' '+80h
fd9c  c9            7194   7223 	ret
                    7195   7224 
                    7196   7225 ;***Subroutine********************
                    7197   7226 ;print hl as 4 hex digits on the
                    7198   7227 ;Console & accumulate the checksum
                    7199   7228 ;On Entry:
                    7200   7229 ;  (c=checksum so far)
                    7201   7230 ;  hl=2 bytes to print
                    7202   7231 ;On Exit:
                    7203   7232 ;  b=0
                    7204   7233 ;  (c=updated checksum)
                    7205   7234 ;Trashes psw
                    7206   7235 ;*********************************
fd9d  06 00         7207   7236 PHLCHX:	mvi	b,0		;print on Console
                    7208   7237 
                    7209   7238 ;Fall into PHLHEX
                    7210   7239 
                    7211   7240 ;***Subroutine*********************************
                    7212   7241 ;Print hl as 4 hex digits & accumulate checksum
                    7213   7242 ;On Entry:
                    7214   7243 ;  b=0 for Console, <>0 for Transfer Port
                    7215   7244 ;  c=checksum so far
                    7216   7245 ;  hl=2 bytes to print
                    7217   7246 ;On Exit:
                    7218   7247 ;  c=updated checksum
                    7219   7248 ;Trashes psw
                    7220   7249 ;**********************************************
fd9f  7c            7221   7250 PHLHEX:	mov	a,h		;h first
fda0  cd a6 fd      7222   7251 	call	PAHCSM		;returns with carry clear
fda3  7d            7223   7252 	mov	a,l		;then l
                    7224   7253 
                    7225   7254 ;	db	CPI		;skip over PMHCSM
fda4  fe            7226   7255 	db	0FEH
                    7227   7256 
                    7228   7257 ;Skip into PAHCSM
                    7229   7258 
                    7230   7259 ;***Subroutine********************************
                    7231   7260 ;Print m as 2 hex digits & accumulate checksum
                    7232   7261 ;On Entry:
                    7233   7262 ;  (HL)=byte to print
                    7234   7263 ;  b=0 for Console, <>0 for Transfer Port
                    7235   7264 ;  c=checksum so far
                    7236   7265 ;On Exit:
                    7237   7266 ;  c=updated checksum
                    7238   7267 ;Trashes psw
                    7239   7268 ;*********************************************
fda5  7e            7240   7269 PMHCSM:	mov	a,m
                    7241   7270 
                    7242   7271 ;Fall into PAHCSM
                    7243   7272 
                    7244   7273 ;***Subroutine********************************
                    7245   7274 ;Print a as 2 hex digits & accumulate checksum
                    7246   7275 ;On Entry:
                    7247   7276 ;  a=byte to print
                    7248   7277 ;  b=0 for Console, <>0 for Transfer Port
                    7249   7278 ;  c=checksum so far
                    7250   7279 ;On Exit:
                    7251   7280 ;  c=opdated checksum
                    7252   7281 ;Trashes psw
                    7253   7282 ;*********************************************
fda6  f5            7254   7283 PAHCSM:	push	psw
fda7  81            7255   7284 	add	c		;Compute checksum
fda8  4f            7256   7285 	mov	c,a
fda9  f1            7257   7286 	pop	psw		;recover chr
                    7258   7287 
                    7259   7288  if TPORT
                    7260   7289 ;	db	CPI		;CPI opcode skips 1
fdaa  fe            7261   7290 	db	0FEH
                    7262   7291 
                    7263   7292 ;Skip into PAHEX2 (executing a NOP on the way)
                    7264   7293  endif ;TPORT
                    7265   7294 
                    7266   7295 ;***Subroutine*********************
                    7267   7296 ;Print a on Console as 2 hex digits
                    7268   7297 ;On Entry:
                    7269   7298 ;  a=byte to print
                    7270   7299 ;Trashes psw, b
                    7271   7300 ;**********************************
fdab                7272   7301 PCAHEX:
                    7273   7302 
                    7274   7303  if TPORT
fdab  06 00         7275   7304 	mvi	b,0		;print on the Console
                    7276   7305  endif ;TPORT
                    7277   7306 
                    7278   7307 ;Fall into PAHEX2
                    7279   7308 
                    7280   7309 ;***Subroutine***************************
                    7281   7310 ;Print a as 2 hex digits
                    7282   7311 ;On Entry:
                    7283   7312 ;  a=byte to print
                    7284   7313 ;  b=0 for Console, <>0 for Transfer Port
                    7285   7314 ;    (only if TPORT is TRUE)
                    7286   7315 ;Trashes psw
                    7287   7316 ;****************************************
fdad  f5            7288   7317 PAHEX2:	push	psw		;save for low digit
                    7289   7318 	
fdae  0f            7290   7319 	rrc			;move the high four down
fdaf  0f            7291   7320 	rrc
fdb0  0f            7292   7321 	rrc
fdb1  0f            7293   7322 	rrc
fdb2  cd b6 fd      7294   7323 	call	PAHEX1		;print high digit
fdb5  f1            7295   7324 	pop	psw		;this time the low four
                    7296   7325 
                    7297   7326 ;Fall into PAHEX1 to print low digit
                    7298   7327 
                    7299   7328 ;***Subroutine***************************
                    7300   7329 ;Print low nibble of a as 1 hex digit
                    7301   7330 ;On Entry:
                    7302   7331 ;  b=0 for Console, <>0 for Transfer Port
                    7303   7332 ;    (only if TPORT is TRUE)
                    7304   7333 ;On Exit:
                    7305   7334 ;  psw trashed
                    7306   7335 ;****************************************
fdb6  e6 0f         7307   7336 PAHEX1:	ani	0Fh		;Four on the floor
fdb8  c6 30         7308   7337 	adi	'0'		;We work with ASCII here
fdba  fe 3a         7309   7338 	cpi	'9'+1		;0-9?
fdbc  da c1 fd      7310   7339 	jc	PNIB1		;Yup: print & return
                    7311   7340 
fdbf  c6 07         7312   7341 	adi	'A'-'9'-1	;make it a letter
fdc1                7313   7342 PNIB1:
                    7314   7343 
                    7315   7344  if TPORT
fdc1  04            7316   7345 	inr	b		;which port?
fdc2  05            7317   7346 	dcr	b
fdc3  c2 08 fe      7318   7347 	jnz	TPOUT		;print on Transfer Port
                    7319   7348  endif ;TPORT
                    7320   7349 
                    7321   7350 ;	db	CPI		;CPI opcode skips PRINTC
fdc6  fe            7322   7351 	db	0FEH
                    7323   7352 
                    7324   7353 ;Skip into PRINTA
                    7325   7354 
                    7326   7355 ;***CP/M External Subroutine*******
                    7327   7356 ;Print C on the Console
                    7328   7357 ;On Entry:
                    7329   7358 ;  the character for output is in c
                    7330   7359 ;On Exit:
                    7331   7360 ;  a=c=chR
                    7332   7361 ;  all other regs preserved
                    7333   7362 ;**********************************
fdc7  79            7334   7363 PRINTC:	mov	a,c
                    7335   7364 
                    7336   7365 ;Fall into PRINTA
                    7337   7366 
                    7338   7367 ;***Subroutine*************
                    7339   7368 ;Print a on the Console
                    7340   7369 ;On Entry:
                    7341   7370 ;  a=the character to print
                    7342   7371 ;all regs preserved
                    7343   7372 ;**************************
fdc8  f5            7344   7373 PRINTA:	push	psw
                    7345   7374 
                    7346   7375  if not CMEMAP
fdc9  db 03         7347   7376 PAWAIT:	in	CSTAT
fdcb  e6 01         7348   7377 	ani	CTXRDY		;wait for transmitter ready
                    7349   7378 
                    7350   7379  endif ;not CMEMAP
                    7351   7380 
                    7352   7381  if CMEMAP
                    7353   7382 PAWAIT:	lda	CSTAT
                    7354   7383 	ani	CTXRDY		;wait for transmitter ready
                    7355   7384  endif ;CMEMAP
                    7356   7385 
                    7357   7386  if CISTAT
                    7358   7387 	jnz	PAWAIT
                    7359   7388 
                    7360   7389  endif ;CISTAT
                    7361   7390 
                    7362   7391  if not CISTAT
fdcd  ca c9 fd      7363   7392 	jz	PAWAIT
                    7364   7393  endif ;not CISTAT
                    7365   7394 
                    7366   7395  if not CMEMAP
fdd0  f1            7367   7396 	pop	psw		;recover chr
fdd1  d3 02         7368   7397 	out	CDATA
fdd3  c9            7369   7398 	ret
                    7370   7399  endif ;not CMEMAP
                    7371   7400 
                    7372   7401  if CMEMAP
                    7373   7402 	pop	psw		;recover chr
                    7374   7403 	sta	CDATA
                    7375   7404 	ret
                    7376   7405  endif ;CMEMAP
                    7377   7406 
                    7378   7407 
                    7379   7408 ;***CP/M External Subroutine************
                    7380   7409 ;Wait for and get Console keyboard data
                    7381   7410 ;On Exit:
                    7382   7411 ;  a=keyboard character, parity stripped
                    7383   7412 ;  Z clear
                    7384   7413 ;***************************************
fdd4  cd df fd      7385   7414 KDATA:	call	KSTAT
fdd7  ca d4 fd      7386   7415 	jz	KDATA
                    7387   7416 
                    7388   7417  if (not CMEMAP) and (not CRXINT)
fdda  db 02         7389   7418 	in	CDATA		;get keyboard chr
                    7390   7419  endif ;(not CMEMAP) and (not CRXINT)
                    7391   7420 
                    7392   7421  if CMEMAP and (not CRXINT)
                    7393   7422 	lda	CDATA		;get keyboard chr
                    7394   7423  endif ;CMEMAP and (not CRXINT)
                    7395   7424 
                    7396   7425  if CRXINT
                    7397   7426 	xra	a		;clear flag
                    7398   7427 	di			;mask while we work
                    7399   7428 	sta	CIFLAG
                    7400   7429 	lda	CRXBUF		;get data
                    7401   7430 	ei
                    7402   7431  endif ;CRXINT
                    7403   7432 
fddc  e6 7f         7404   7433 	ani	7Fh		;strip parity
fdde  c9            7405   7434 	ret
                    7406   7435 
                    7407   7436 ;***CP/M External Subroutine************
                    7408   7437 ;Get Console keyboard status
                    7409   7438 ;On Exit:
                    7410   7439 ;  a=0 and Z set if nothing waiting
                    7411   7440 ;  a=FF and Z cleared if kbd chr waiting
                    7412   7441 ;***************************************
fddf                7413   7442 KSTAT:
                    7414   7443  if (not CMEMAP) and (not CRXINT)
fddf  db 03         7415   7444 	in	CSTAT
                    7416   7445  endif ;(not CMEMAP) and (not CRXINT)
                    7417   7446 
                    7418   7447  if CMEMAP and (not CRXINT)
                    7419   7448 	lda	CSTAT
                    7420   7449  endif ;CMEMAP and (not CRXINT)
                    7421   7450 
                    7422   7451  if CISTAT and (not CRXINT)
                    7423   7452 	cma			;inverted status bit
                    7424   7453  endif ;CISTAT and (not CRXINT)
                    7425   7454 
                    7426   7455  if not CRXINT
fde1  e6 02         7427   7456 	ani	CRXRDY
                    7428   7457  endif ;not CRXINT
                    7429   7458 
                    7430   7459  if CRXINT
                    7431   7460 	lda	CIFLAG
                    7432   7461 	ora	a
                    7433   7462  endif ;CRXINT
                    7434   7463 
                    7435   7464 ;Fall into DOSTAT
                    7436   7465 
                    7437   7466 ;***Subroutine*****************
                    7438   7467 ;Create CP/M-style return value
                    7439   7468 ;On Exit:
                    7440   7469 ;  if Z then a=0
                    7441   7470 ;  if NZ then a=0FFh
                    7442   7471 ;******************************
fde3  c8            7443   7472 DOSTAT:	rz			;CP/M-style return values
fde4  3e ff         7444   7473 	mvi	a,0FFh
fde6  c9            7445   7474 	ret
                    7446   7475 
                    7447   7476 ;***CP/M External Subroutine***
                    7448   7477 ;Get Transfer Port Rx status
                    7449   7478 ;On Exit:
                    7450   7479 ;  a=0 & Z set if no data
                    7451   7480 ;  a=FF  & Z clear if data
                    7452   7481 ;******************************
                    7453   7482 
fde7                7454   7483 TPISTA:
                    7455   7484  if TPORT and (not TMEMAP) and (not TRXINT)
fde7  db 23         7456   7485 	in	TSTAT
                    7457   7486  endif ;TPORT and (not TMEMAP) and (not TRXINT)
                    7458   7487 
                    7459   7488  if TPORT and TMEMAP and (not TRXINT)
                    7460   7489 	lda	TSTAT
                    7461   7490  endif ;TPORT and TMEMAP and (not TRXINT)
                    7462   7491 
                    7463   7492  if TPORT and TISTAT and (not TRXINT)
                    7464   7493 	cma			;inverted status bit
                    7465   7494  endif ;TPORT and TISTAT and (not TRXINT)
                    7466   7495 
                    7467   7496  if TPORT and (not TRXINT)
fde9  e6 02         7468   7497 	ani	TRXRDY
fdeb  c3 e3 fd      7469   7498 	jmp	DOSTAT
                    7470   7499  endif ;TPORT and (not TRXINT)
                    7471   7500 
                    7472   7501  if TPORT and TRXINT
                    7473   7502 	lda	TIFLAG
                    7474   7503 	ora	a	;a=0 or FF
                    7475   7504 	ret
                    7476   7505  endif ;TPORT and TRXINT
                    7477   7506 
                    7478   7507 ;***CP/M External Subroutine***
                    7479   7508 ;Get Transfer Port Rx data
                    7480   7509 ;On Exit:
                    7481   7510 ;  a=byte from port
                    7482   7511 ;  Z cleared
                    7483   7512 ;******************************
                    7484   7513  if TPORT
fdee  cd e7 fd      7485   7514 TPIDAT:	call	TPISTA		;wait for chr
fdf1  ca ee fd      7486   7515 	jz	TPIDAT
                    7487   7516  endif ;TPORT
                    7488   7517 
                    7489   7518  if TPORT and (not TMEMAP) and (not TRXINT)
fdf4  db 22         7490   7519 	in	TDATA
fdf6  c9            7491   7520 	ret
                    7492   7521  endif ;TPORT and (not TMEMAP) and (not TRXINT)
                    7493   7522 
                    7494   7523  if TPORT and TMEMAP and (not TRXINT)
                    7495   7524 	lda	TDATA
                    7496   7525 	ret
                    7497   7526  endif ;TPORT and TMEMAP and (not TRXINT)
                    7498   7527 
                    7499   7528  if TPORT and TRXINT
                    7500   7529 TPIDAI:	xra	a		;clear flag
                    7501   7530 	di			;mask while we work
                    7502   7531 	sta	TIFLAG
                    7503   7532 	lda	TRXBUF		;Get data
                    7504   7533 	ei
                    7505   7534 	ret
                    7506   7535  endif ;TPORT and TRXINT
                    7507   7536 
                    7508   7537 ;***Subroutine*******************************
                    7509   7538 ;Finish writing Intel end-of-file hex record
                    7510   7539 ;(the CRLF and colon have already been sent.)
                    7511   7540 ;********************************************
fdf7  06 05         7512   7541 HDEOF:	mvi	b,5		;5 bytes for EOF
                    7513   7542 
fdf9  af            7514   7543 HDELUP:	xra	a
fdfa  cd ad fd      7515   7544 	call	PAHEX2		;B<>0 for Transfer Port
fdfd  05            7516   7545 	dcr	b
fdfe  c2 f9 fd      7517   7546 	jnz	HDELUP
                    7518   7547 
                    7519   7548 ;Fall into TPCRLF for a final CR LF
                    7520   7549 
                    7521   7550 ;***Subroutine************************************
                    7522   7551 ;Send CR LF to the Transfer Port
                    7523   7552 ;On Entry:
                    7524   7553 ;  sp points into the RAM page
                    7525   7554 ;  RAM page byte FE=1 for channel B, 0 for Console
                    7526   7555 ;Trashes psw
                    7527   7556 ;*************************************************
fe01  3e 0d         7528   7557 TPCRLF:	mvi	a,CR		;CR,LF to Transfer Port
fe03  cd 08 fe      7529   7558 	call	TPOUT
                    7530   7559 
fe06  3e 0a         7531   7560 	mvi	a,LF
                    7532   7561 
                    7533   7562 ;Fall into TPOUT
                    7534   7563 
                    7535   7564 ;***Subroutine************************************
                    7536   7565 ;Send a to the Transfer Port
                    7537   7566 ;On Entry:
                    7538   7567 ;  sp points into the RAM page
                    7539   7568 ;  RAM page byte FE=1 for channel B, 0 for Console
                    7540   7569 ;Trashes flags
                    7541   7570 ;*************************************************
fe08                7542   7571 TPOUT:
                    7543   7572  if TPORT
fe08  cd 72 fd      7544   7573 	call	TESTTP		;which physical port?
fe0b  ca c8 fd      7545   7574 	jz	PRINTA		;Z means Console
                    7546   7575 
                    7547   7576 ;	db	CPI		;CPI opcode skips TPDATC
                    7548   7577 				;..TO Fall into PBODAT
fe0e  fe            7549   7578 	db	0FEH
                    7550   7579  endif ;TPORT
                    7551   7580 
                    7552   7581  if not TPORT
                    7553   7582 	jmp	PRINTA
                    7554   7583  endif ;not TPORT
                    7555   7584 
                    7556   7585 ;***CP/M External Subroutine***
                    7557   7586 ;Send c to Transfer Port
                    7558   7587 ;On Exit:
                    7559   7588 ;  a=c=chr
                    7560   7589 ;All other regs preserved
                    7561   7590 ;******************************
                    7562   7591  if TPORT
fe0f  79            7563   7592 TPDATC:	mov	a,c
                    7564   7593 
                    7565   7594 ;Fall into PBODAT
                    7566   7595  endif ;TPORT
                    7567   7596 
                    7568   7597 ;***Subroutine**********
                    7569   7598 ;Send a to Transfer Port
                    7570   7599 ;All regs preserved
                    7571   7600 ;***********************
                    7572   7601  if TPORT
fe10  f5            7573   7602 PBODAT:	push	psw
                    7574   7603 
fe11  cd 18 f8      7575   7604 PBODA1:	call	TPOSTA		;wait for transmitter
fe14  ca 11 fe      7576   7605 	jz	PBODA1
                    7577   7606  endif ;TPORT
                    7578   7607 
                    7579   7608  if TPORT and (not TMEMAP)
fe17  f1            7580   7609 	pop	psw		;recover chr
fe18  d3 22         7581   7610 	out	TDATA
fe1a  c9            7582   7611 	ret
                    7583   7612  endif ;TPORT and (not TMEMAP)
                    7584   7613 
                    7585   7614  if TPORT and TMEMAP
                    7586   7615 	pop	psw		;recover chr
                    7587   7616 	sta	TDATA
                    7588   7617 	ret
                    7589   7618  endif ;TPORT and TMEMAP
                    7590   7619 
                    7591   7620 ;*************************
                    7592   7621 ;8251 initialization table
                    7593   7622 ;*************************
                    7594   7623  if C8251 or T8251
                    7595   7624 
fe1b  aa 40 4e 37   7596   7625 IN8251:	db	SI21,SI22,SI23,SI24
                    7597   7626 
                    7598   7627  endif	;C8251 or T8251
                    7599   7628 
                    7600   7629 ;*********************************
                    7601   7630 ;Z80-DART initialization table
                    7602   7631 ;(Gets sent to both DART channels)
                    7603   7632 ;*********************************
                    7604   7633  if DART
                    7605   7634 DITAB:	db	DI1,dI2,dI3,dI4,dI5,dI6,dI7
                    7606   7635  endif	;DART
                    7607   7636 
                    7608   7637 ;****************************************************
                    7609   7638 ;Transfer Port Baud Rate Table
                    7610   7639 ;Each entry has 4 bytes:
                    7611   7640 ;  Byte 0=value for BRATE0 port (written 1st)
                    7612   7641 ;  Byte 1=value for BRATE1 port (written 2nd)
                    7613   7642 ;  Byte 3-4=Decimal value for baud rate string,
                    7614   7643 ;             encoded as 4 hex digits. Leading zeros
                    7615   7644 ;             get suppressed, and a "0" gets appended
                    7616   7645 ;             to these digits when printed.
                    7617   7646 ;****************************************************
                    7618   7647  if TSBAUD and ROM2K
                    7619   7648 BTABLE:	dw	TBD110	;0= 110 baud 2 stop bits
                    7620   7649 	db	00h,11h	;string
                    7621   7650 
                    7622   7651 	dw	TBD150	;1= 150 baud
                    7623   7652 	db	00h,15h
                    7624   7653 
                    7625   7654 	dw	TBD300	;2= 300 baud
                    7626   7655 	db	00h,30h
                    7627   7656 
                    7628   7657 	dw	TBD600	;3= 600 baud
                    7629   7658 	db	00h,60h
                    7630   7659 
                    7631   7660 	dw	TBD1200	;4= 1200 baud
                    7632   7661 	db	01h,20h
                    7633   7662 
                    7634   7663 	dw	TBD2400	;5= 2400 baud
                    7635   7664 	db	02h,40h
                    7636   7665 
                    7637   7666 	dw	TBD4800	;6= 4800 baud
                    7638   7667 	db	04h,80h
                    7639   7668 
                    7640   7669 	dw	TBD9600	;7= 9600 baud
                    7641   7670 	db	09h,60h
                    7642   7671  endif ;TSBAUD and ROM2K
                    7643   7672 
                    7644   7673  if BD192 and TSBAUD and ROM2K
                    7645   7674 	dw	TBD192	;8= 19200 baud
                    7646   7675 	db	19h,20h
                    7647   7676  endif ;BD192 and TSBAUD and ROM2K
                    7648   7677 
                    7649   7678  if BD384 and TSBAUD and ROM2K
                    7650   7679 	dw	TBD384	;9= 38400 baud
                    7651   7680 	db	38h,40h
                    7652   7681  endif ;BD383 and TSBAUD and ROM2K
                    7653   7682 
                    7654   7683  if BD576 and TSBAUD and ROM2K
                    7655   7684 	dw	TBD576	;a= 57600 baud
                    7656   7685 	db	57h,60h
                    7657   7686  endif ;BD576 and TSBAUD and ROM2K
                    7658   7687 
                    7659   7688  if BD768 and TSBAUD and ROM2K
                    7660   7689 	dw	TBD768	;b= 76800 baud
                    7661   7690 	db	76h,80h
                    7662   7691  endif ;BD768 and TSBAUD and ROM2K
                    7663   7692 
                    7664   7693  if TSBAUD and ROM2K
                    7665   7694 BTEND:
                    7666   7695  endif ;TSBAUD and ROM2K
                    7667   7696 
                    7668   7697 ;***Command Routine Continuation***
                    7669   7698 ;? Print (Minimal) Help Screen
                    7670   7699 ;**********************************
                    7671   7700  if HELPC
fe1f  cd 59 fd      7672   7701 GHELP:	call	CILPRT
                    7673   7702 
                    7674   7703 ;Memory commands
                    7675   7704 
fe22  43 4f 20 73   7676   7705 	db 'CO s d c [r]',CR
fe26  20 64 20 63   7676   7706
fe2a  20 5b 72 5d   7676   7707
fe2e  0d            7676   7708
fe2f  44 55 20 61   7677   7709 	db 'DU a c',CR
fe33  20 63 0d      7677   7710
fe36  45 4e 20 61   7678   7711 	db 'EN a',CR
fe3a  0d            7678   7712
fe3b  46 49 20 5b   7679   7713 	db 'FI [a [c [v]]]',CR
fe3f  61 20 5b 63   7679   7714
fe43  20 5b 76 5d   7679   7715
fe47  5d 5d 0d      7679   7716
                    7680   7717  endif ;HELPC
                    7681   7718 
                    7682   7719  if HELPC and ROM2K
fe4a  4d 54 20 61   7683   7720 	db 'MT a c',CR
fe4e  20 63 0d      7683   7721
fe51  53 45 20 61   7684   7722 	db 'SE a v v ',QUOTE,'t',QUOTE,'...',CR
fe55  20 76 20 76   7684   7723
fe59  20 27 74 27   7684   7724
fe5d  2e 2e 2e 0d   7684   7725
                    7685   7726  endif ;HELPC and ROM2K
                    7686   7727 
                    7687   7728  if HELPC
fe61  56 45 20 73   7688   7729 	db 'VE s d c',CR,LF
fe65  20 64 20 63   7688   7730
fe69  0d 0a         7688   7731
                    7689   7732 
                    7690   7733 ;I/O commands
                    7691   7734 
fe6b  49 4e 20 70   7692   7735 	db 'IN p',CR
fe6f  0d            7692   7736
fe70  4f 54 20 70   7693   7737 	db 'OT p v',CR,LF
fe74  20 76 0d 0a   7693   7738
                    7694   7739  endif ;HELPC
                    7695   7740 
                    7696   7741 ;Disk commands
                    7697   7742 
                    7698   7743  if HELPC and BOOTER
fe78  42 4f         7699   7744 	db 'BO'
                    7700   7745  endif ;HELPC and BOOTER
                    7701   7746 
                    7702   7747  if HELPC and (C4FDC or C16FDC or C64FDC)
                    7703   7748 	db ' d'		;Cromemco can boot from any disk
                    7704   7749  endif ;HELPC and (C4FDC or C16FDC or C64FDC)
                    7705   7750 
                    7706   7751  if HELPC and BOOTER
fe7a  0d            7707   7752 	db CR
                    7708   7753  endif ;HELPC and BOOTER
                    7709   7754 
                    7710   7755  if HELPC and ROM2K
fe7b  43 45 20 63   7711   7756 	db 'CE cl',CR
fe7f  6c 0d         7711   7757
                    7712   7758  endif ;HELPC and ROM2K
                    7713   7759 
                    7714   7760  if HELPC
fe81  45 58 20 61   7715   7761 	db 'EX a'
                    7716   7762  endif ;HELPC
                    7717   7763 
                    7718   7764  if HELPC and EXOPT
fe85  20 5b 30 2f   7719   7765 	db ' [0/1]'
fe89  31 5d         7719   7766
                    7720   7767  endif ;HELPC and EXOPT
                    7721   7768 
                    7722   7769  if HELPC
fe8b  0d 0a         7723   7770 	db CR,LF
                    7724   7771 
                    7725   7772 ;Transfer Port Commands
                    7726   7773 
fe8d  48 44 20 61   7727   7774 	db 'HD a c',CR
fe91  20 63 0d      7727   7775
                    7728   7776  endif ;HELPC
                    7729   7777 
                    7730   7778  if TPORT and HELPC
fe94  48 4c 20 5b   7731   7779 	db 'HL [o]',CR
fe98  6f 5d 0d      7731   7780
                    7732   7781  endif ;TPORT and HELPC
                    7733   7782 
                    7734   7783  if (not TPORT) and HELPC
                    7735   7784 	db 'HL [o]',CR+80h
                    7736   7785  endif ;(not TPORT) and HELPC
                    7737   7786 
                    7738   7787  if HELPC and TSBAUD
                    7739   7788 	db 'TB 0-'
                    7740   7789  endif ;HELPC and TSBAUD
                    7741   7790 
                    7742   7791  if (HELPC and TSBAUD) and not (BD192 or BD384 or BD576 or BD768)
                    7743   7792 	db '7'
                    7744   7793  endif ;(HELPC and TSBAUD) and not (BD192 or BD384 or BD576 or BD768)
                    7745   7794 
                    7746   7795  if (HELPC and TSBAUD and BD192) and not (BD384 or BD576 or BD768)
                    7747   7796 	db '8'
                    7748   7797  endif ;(HELPC and TSBAUD and BD192) and not (BD384 or BD576 or BD768)
                    7749   7798 
                    7750   7799  if (HELPC and TSBAUD and BD384) and not (BD576 or BD768)
                    7751   7800 	db '9'
                    7752   7801  endif ;(HELPC and TSBAUD and BD384) and not (BD576 or BD768)
                    7753   7802 
                    7754   7803  if (HELPC and TSBAUD and BD576) and not BD768
                    7755   7804 	db 'A'
                    7756   7805  endif ;(HELPC and TSBAUD and BD576) and not BD768
                    7757   7806 
                    7758   7807  if HELPC and TSBAUD and BD768
                    7759   7808 	db 'B'
                    7760   7809  endif ;TSBAUD and HELPC and BD768
                    7761   7810 
                    7762   7811  if TPORT and HELPC and TSBAUD
                    7763   7812 	db CR
                    7764   7813  endif ;TPORT and HELPC and TSBAUD
                    7765   7814 
                    7766   7815  if TPORT and HELPC
fe9b  54 45 20 65   7767   7816 	db 'TE e',CR
fe9f  0d            7767   7817
fea0  54 50 20 30   7768   7818 	db 'TP 0/1',CR+80h
fea4  2f 31 8d      7768   7819
                    7769   7820  endif ;TPORT and HELPC
                    7770   7821 
                    7771   7822  if HELPC
fea7  c9            7772   7823 	ret
                    7773   7824  endif ;HELPC
                    7774   7825 
                    7775   7826 ;==========================================
                    7776   7827 ;command table
                    7777   7828 ;EACH entry is 3 bytes:
                    7778   7829 ;  byte 0:       1st command character
                    7779   7830 ;  byte 1 <6:0>: 2nd command character
                    7780   7831 ;  byte 1 <7>:   address offset msb
                    7781   7832 ;  byte 2:       address offset from CMDBAS
                    7782   7833 ;the table terminates with byte 0=0.
                    7783   7834 ;==========================================
fea8  44 55         7784   7835 COMTAB:	db	'DU'		;Dump
feaa  f3            7785   7836 	db	DUCMD-CMDBAS
                    7786   7837 
feab  45 4e         7787   7838 	db	'EN'		;Enter
fead  50            7788   7839 	db	ENCMD-CMDBAS
                    7789   7840 
feae  45 58         7790   7841 	db	'EX'		;Execute
feb0  d9            7791   7842 	db	EXCMD-CMDBAS
                    7792   7843 
feb1  46 49         7793   7844 	db	'FI'		;Fill memory
feb3  67            7794   7845 	db	FICMD-CMDBAS
                    7795   7846 
feb4  49 4e         7796   7847 	db	'IN'
feb6  bc            7797   7848 	db	INCMD-CMDBAS	;In from port
                    7798   7849 
feb7  4f 54         7799   7850 	db	'OT'
feb9  cc            7800   7851 	db	OTCMD-CMDBAS	;Out to port
                    7801   7852 
                    7802   7853  if TPORT
feba  54 45         7803   7854 	db	'TE'		;Terminal mode
febc  03            7804   7855 	db	TECMD-CMDBAS
                    7805   7856 
febd  54 50         7806   7857 	db	'TP'		;Set Transfer Port
febf  ec            7807   7858 	db	TPCMD-CMDBAS
                    7808   7859  endif ;TPORT
                    7809   7860 
01a0  =             7810   7861 VED	equ	VECMD-CMDBAS
fec0  56 c5         7811   7862 	db	'V','E'+((VED/2) and 80h) ;verify
fec2  a0            7812   7863 	db	VED and 0FFh
                    7813   7864 
01a7  =             7814   7865 COD	equ	COCMD-CMDBAS
fec3  43 cf         7815   7866 	db	'C','O'+((COD/2) and 80h) ;COPY
fec5  a7            7816   7867 	db	COD and 0FFh
                    7817   7868 
0080  =             7818   7869 HDD	equ	HDCMD-CMDBAS
fec6  48 44         7819   7870 	db	'H','D'+((HDD/2) and 80h) ;Intel hex dump
fec8  80            7820   7871 	db	HDD and 0FFh
                    7821   7872 
0144  =             7822   7873 HLD	equ	HLCMD-CMDBAS
fec9  48 cc         7823   7874 	db	'H','L'+((HLD/2) and 80h) ;Intel hex load
fecb  44            7824   7875 	db	HLD and 0FFh
                    7825   7876 
0000  #             7826   7877 TBD	set	0
                    7827   7878  if TPORT and TSBAUD and ROM2K
                    7828   7879 TBD	set	TBCMD-CMDBAS
                    7829   7880 	db	'T','B'+((TBD/2) and 80h) ;Set T Port Baud Rate
                    7830   7881 	db	TBD and 0FFh
                    7831   7882  endif ;TPORT and TSBAUD and ROM2K
                    7832   7883 
0000  #             7833   7884 BOD	set	0
                    7834   7885  if BOOTER
0042  #             7835   7886 BOD	set	BOCMD-CMDBAS
fecc  42 4f         7836   7887 	db	'B','O'+((BOD/2) and 80h) ;Boot frm disk
fece  42            7837   7888 	db	BOD and 0FFh
                    7838   7889  endif ;BOOTER
                    7839   7890 
0000  #             7840   7891 SED	set	0
                    7841   7892  if ROM2K
fecf  43 45         7842   7893 	db	'CE'			;Execute CP/M program
fed1  00            7843   7894 	db	CECMD-CMDBAS
                    7844   7895 
fed2  4d 54         7845   7896 	db	'MT'			;Memory Test
fed4  3c            7846   7897 	db	MTCMD-CMDBAS
                    7847   7898 
003f  #             7848   7899 SED	set	SECMD-CMDBAS
fed5  53 45         7849   7900 	db	'S','E'+((SED/2) and 80h) ;Search
fed7  3f            7850   7901 	db	SED and 0FFh
                    7851   7902  endif ;ROM2K
                    7852   7903 
                    7853   7904  if HELPC
fed8  3f 00         7854   7905 	db	'?',0			;Help
feda  39            7855   7906 	db	HELP-CMDBAS
                    7856   7907  endif ;HELPC
                    7857   7908 
fedb  00            7858   7909 	db	0			;End of table mark
                    7859   7910 
                    7860   7911 ;========================================================
                    7861   7912 ;Interrupt code for the H8-5 Rx Interrupt, as the console
                    7862   7913 ;This code assumes RAMHNT = FALSE
                    7863   7914 ;  RAM page variables
                    7864   7915 ;   CRXBUF:  1-byte receive queue
                    7865   7916 ;   CIFLAG: 0FFh means CRXBUF has a character to send
                    7866   7917 ;========================================================
                    7867   7918  if CH85
                    7868   7919 CONINT:	push	psw		;onto MEMON's stack
                    7869   7920 
                    7870   7921 ;Receive and enqueue a character, ignoring any overflow	
                    7871   7922 
                    7872   7923 	in	CDATA		;get chr now
                    7873   7924 	sta	CRXBUF		;enqueue chr
                    7874   7925 
                    7875   7926 	mvi	a,0FFh		;flag received chr
                    7876   7927 	sta	CIFLAG
                    7877   7928 
                    7878   7929 ;Restore registers and return from the interrupt
                    7879   7930 
                    7880   7931 	pop	psw
                    7881   7932 	ei
                    7882   7933 	ret
                    7883   7934 
                    7884   7935  endif ;CH85
                    7885   7936 
                    7886   7937 ;==============================================================
                    7887   7938 ;Interrupt code for the H8-5 Rx Interrupt, as the transfer port
                    7888   7939 ;This code assumes RAMHNT = FALSE
                    7889   7940 ;  RAM page variables
                    7890   7941 ;   TRXBUF:  1-byte receive queue
                    7891   7942 ;   TIFLAG: 0FFh means TRXBUF has a character to send
                    7892   7943 ;==============================================================
                    7893   7944  if TH85
                    7894   7945 TBINT:	push	psw		;onto MEMON's stack
                    7895   7946 
fedc                7896   7947 :Receive and enqueue a character, ignoring any overflow	
                    7897   7948 
                    7898   7949 	in	TDATA		;get chr now
                    7899   7950 	sta	TRXBUF		;enqueue chr
                    7900   7951 
                    7901   7952 	mvi	a,0FFh		;flag received chr
                    7902   7953 	sta	TIFLAG
                    7903   7954 
                    7904   7955 ;Restore registers and return from the interrupt
                    7905   7956 
                    7906   7957 	pop	h
                    7907   7958 	pop	psw
                    7908   7959 	ei
                    7909   7960 	ret
                    7910   7961 
                    7911   7962  endif ;TH85
                    7912   7963 
                    7913   7964 ;======================================
                    7914   7965 ;Create an assembly error if MEMON/80's
                    7915   7966 ;RAM is not all in the same page
                    7916   7967 ;======================================
                    7917   7968  if (not RAMHNT) and ((RAMBEG/256) - (RAMEND/256))
fedc                7918   7969 ERROR: RAMEND Problem. MEMON RAM spans 2 pages
                    7919   7970  endif ;(not RAMHNT) and ((RAMBEG/256) - (RAMEND/256))
                    7920   7971 
                    7921   7972 ;==========================================
                    7922   7973 ;Create an assembly error if interrupts are
                    7923   7974 ;required and RAMHNT is true
                    7924   7975 ;==========================================
                    7925   7976  if RAMHNT and (ENINTS or CRXINT or TRXINT)
fedc                7926   7977 ERROR: RAMHNT with a port that uses interrupts
                    7927   7978  endif ;RAMHNT and (ENINTS or CRXINT or TRXINT)
                    7928   7979 
                    7929   7980 ;==========================================
                    7930   7981 ;Create an assembly error if any of the
                    7931   7982 ;command execution routines is out of range
                    7932   7983 ;==========================================
                    7933   7984  if (SED or TBD or HLD or HDD or COD or VED)/512
fedc                7934   7985 ERROR: command routine out of range
                    7935   7986  endif ;(SED or TBD or HLD or HDD or COD or VED)/512
                    7936   7987 
                    7937   7988 ;===================================
                    7938   7989 ;Create an assembly error if the
                    7939   7990 ;code is larger than the EPROM space
                    7940   7991 ;===================================
fedc  =             7941   7992 CODEND	equ	$
                    7942   7993 
                    7943   7994  if (not RAMCOD) and ((CODEND-MEBASE-1)/ROMSIZ)
fedc                7944   7995 ERROR: code is larger than available EPROM space
                    7945   7996  endif ;(not RAMCOD) and ((CODEND-MEBASE-1)/ROMSIZ)
                    7946   7997 
fedc                7947   7998 	END

Symbol table

A88DCD  0000    A88MCD  0000    ADLOOP  f9ed    BD192   0000    BD384   0000 
BD576   0000    BD768   0000    BOCMD   f908    BOD     0042    BOOTER  ffff 
BOTERR  fc92*   BS      0008    C16FDC  0000    C4FDC   0000    C64FDC  0000 
C6850   0000    C8250   0000    C8251   ffff    CA2SIO  0000    CABKEY  0003 
CABORT  fd0b    CALSIO  0000    CB8251  0002    CBASE   0002    CBAUD   0009 
CBD18   0000    CBITS1  0000    CBITS2  0000    CC2422  0000    CC2718A 0000 
CC2718B 0000    CC2719A 0000    CC2719B 0000    CC2810  0000    CCFDCS  0000 
CCTRL   0003    CDATA   0002    CECMD   f8c6    CER2IO  0000    CH84    0000 
CH85    0000    CHKKBD  fcd1    CIFAC   0000    CIFAC2  0000    CIFLAG  008f*
CILPRT  fd59    CISIO2A ffff    CISIO2B 0000    CISTAT  0000    CIVIO2  0000 
CJADSP  0000    CLLOOP  fabe    CMDBAS  f8c6    CMDERR  fd07    CMDUBLR 0000 
CMEMAP  0000    CML1    fbb4    CML2    fbbc    CML3    fbc1    CMLOOP  fba8 
CMPERR  fbdb    COCMD   fa6d    COD     01a7    CODEND  fedc    COLOOP  fa85 
COMBUF  0080    COMTAB  fea8    CORLUP  fa7e    CORPT   ffff    CPAUSE  fcc1 
CPT3PS  0000    CPUMHZ  0004*   CR      000d    CRXBUF  008e*   CRXINT  0000 
CRXRDY  0002    CSAL21  0000    CSBAUD  0000    CSIO5   0000    CSMERR  fc1c 
CSTAT   0003    CTARBL  0000    CTRLC   0003    CTUART  0000    CTXMTY  0004*
CTXRDY  0001    CWIOB1  0000    DART    0000    DEL     007f    DIBASE  00fd 
DLDONE  f9db    DMBASE  0000*   DNOPAD  f9ec    DOSTAT  fde3    DPLOOP  f9e2 
DTEXIT  0003    DUCMD   f9b9    DULINE  f9c0    DULOOP  f9c5    DUPRTY  ffff 
ENCMD   f916    ENINTS  0000    ENLOOP  f91d    EXCMD   f99f    EXECDP  f9a4*
EXOPT   ffff    EXSTK   f9ab    FALSE   0000    FHEXLP  f8a5    FICMD   f92d 
FIL0    fb7d    FIL1    fb89    FIL2    fb91    FIL3    fb99    FILOOP  f93a 
FNDHEX  f8a2*   FSEND   f83f    FSLOOP  f832    FXHL1   f8b4    GBOCMD  fc47 
GCECMD  fab8    GETCOL  fa0f    GETCSM  fa4a    GETHEX  fd02    GETHX2  fcfe 
GETKBD  fcc5    GETLIN  fd12    GETTPD  fd7c    GHELP   fe1f    GLLOOP  fd19 
GMTCMD  fb63    GSECMD  fad5    GTPBYT  fcde    GTPLUP  fd82    GTPNIB  fcee 
H17R    0000    HDCMD   f946    HDD     0080    HDELUP  fdf9    HDEOF   fdf7 
HDLIN1  f95e    HDLINE  f94b    HDLOOP  f96d    HDRLEN  0010    HELP    f8ff 
HELPC   ffff    HEXCON  fd4c    HLCMD   fa0a    HLD     0144    HLHDR   fa1a 
HLLOOP  fa36    HLRECS  ffff    HUNTA   00b0    IBCMD   0080    IBSECT  0084*
IBSTAT  0081    IBTRK   0082*   IBUFAD  0085*   IDISK   00fd    IDWAIT  fc6c 
IEXEC0  0000*   IFIF    ffff    ILPRNT  fd5d    IMD8R   0000    IMDMR   0000 
IN8251  fe1b    INCMD   f982    INIT    f81f    IOCMD   f99b    IPLOOP  fd5e 
IRDSEC  0021    IRESTR  0021    ISSPTR  0010    ISUCCS  0001    JMPBOT  ffff 
KDATA   fdd4    KSTAT   fddf    LBCHR   fd30    LBSIZE  0050    LDELET  fd40 
LF      000a    LOWERC  ffff    MAIN    f86a    MAXTRYS 0010    MDUBLR  0000 
MEBASE  f800    MECIN   f809*   MECOUT  f80c*   MECSTA  f806*   MEINIT  f800*
MEMERR  fc2e    METPDI  f815*   METPDO  f812*   METPSI  f80f*   METPSO  f818*
MEWARM  f803    MICROP  0000    MICROR  0000    MTCMD   f902    MTLOOP  fb79 
MTPAT   fbfe    NOMTCH  fb32    NSTARD  0000    NSTARS  0000    NSTRDR  0000 
NSTRSR  0000    NXTCOM  f87c    OTCMD   f992    OVMERR  fc25    PAHCSM  fda6 
PAHEX1  fdb6    PAHEX2  fdad    PAWAIT  fdc9    PBODA1  fe11    PBODAT  fe10 
PCAHEX  fdab    PCCOLS  fd97    PCFIER  002e    PHFHEX  f8a0    PHLADR  fd90 
PHLCHX  fd9d    PHLHEX  fd9f    PMHCSM  fda5    PNIB1   fdc1    PRINTA  fdc8 
PRINTC  fdc7    PRNTBL  f9f8    PROMPT  003e    QUOTE   0027    RAMBEG  008f 
RAMBUF  00b0    RAMCOD  0000    RAMEND  ffff    RAMHNT  ffff    RAMPAG  fab3 
RBR1    fc8a    RBRTRY  fc65    ROM2K   ffff    ROMSIZ  0800    RPTERR  fc34 
SALFDC  0000    SCHHEX  fb54    SCHLUP  fadf    SECMD   f905    SED     003f 
SI21    00aa    SI22    0040    SI23    004e    SI24    0037    SI2LUP  f822 
SIOCTL  0008    SLOOP1  faf3    SLOOP2  faf6    SSPACE  fd28    SSTRNG  fb47 
STACK   00b0    STKSIZ  0020    STLOOP  fb48    T5511   0000    T6850   0000 
T8250   0000    T8251   ffff    TA2SIO  0000    TALSIO  0000    TARBL1  0000 
TARBL2  0000    TB8251  0022    TBASE   0022    TBAUD   000a    TBD     0000 
TBD18   0000    TBITS1  0000    TBITS2  0000    TC2718A 0000    TC2718B 0000 
TC2719A 0000    TC2719B 0000    TC2810  0000    TCFDCS  0000    TCTRL   0023 
TDATA   0022    TECMD   f8c9    TER2IO  0000    TESTTP  fd72    TH84    0000 
TH85    0000    TIFAC   0000    TIFAC2  0000    TIFLAG  008d*   TISIO2A ffff 
TISIO2B 0000    TISTAT  0000    TIVIO2  0000    TJADSP  0000    TLOOP   f8e7 
TMDUBLR 0000    TMEMAP  0000    TMNL1   f8db    TMRCTC  0000    TPCMD   f9b2 
TPCRLF  fe01    TPDATC  fe0f    TPIDAT  fdee    TPISTA  fde7    TPORT   ffff 
TPOSTA  f818    TPOUT   fe08    TPT3PS  0000    TRUE    ffff    TRXBUF  008c*
TRXINT  0000    TRXRDY  0002    TSAL21  0000    TSBAUD  0000    TSIO5   0000 
TSTAT   0023    TTARBL  0000    TTUART  0000    TTXMTY  0004*   TTXRDY  0001 
TWIOB1  0000    UCMDEI  0036*   UCMDEN  0037    UCMDRE  0040    UMOD16  004e 
USAREA  0100    VECMD   fa66    VED     01a0    VELOOP  faa6    VERIFY  fa98 
VERROR  fcad    VERSA1  0000    VERSA2  0000    VERSION 0026    WBOOT   0000 
WBOOTA  0001    WD179X  0000    
