Z80/8080-Macro-Assembler  Release 2.1

LOC   OBJECT CODE   LINE   STMT SOURCE CODE
                       1      1 *HEADING IMSAI 8080 4K BASIC
                       2      2 ;
                       3      3 ; MODIFIED TO WORK WITH SIO-2 TTY IDENTICAL TO 8K VERSION
                       4      4 ; OCTOBER 2008, UDO MUNK
                       5      5 ;
                       6      6       ORG   0
                       7      7 ;
                       8      8 ;
0000  =                9      9 BASIC EQU   $
0000  21 00 14        10     10       LD    HL,RAM+1024      ;POINT FIRST POSSIBLE END OF RAM
                      11     11 ;     LD    A,0FAH           ;GET MODE SET
0003  3e ba           12     12       LD    A,0BAH           ;**UM**
0005  c3 49 00        13     13       JP    CONTI            ;GO CONTINUE
                      14     14 ;
                      15     15 ;
                      16     16       ORG   8
0008  =               17     17 RST1  EQU   $
                      18     18 ;
                      19     19 ;SKIP CHARS POINTED TO BY HL UNTIL NON-BLANK,
                      20     20 ;LEAVE IN REG A
                      21     21 ;
0008  7e              22     22       LD    A,(HL)           ;LOAD THE BYTE AT (HL)
0009  fe 20           23     23       CP    ' '              ;TEST  IF BLANK
000b  c0              24     24       RET   NZ               ;RETURN IF NOT
000c  23              25     25       INC   HL               ;POINT NEXT
000d  c3 08 00        26     26       JP    RST1             ;LOOP
                      27     27 ;
                      28     28 ;
                      29     29       ORG   16
0010  =               30     30 RST2  EQU   $
                      31     31 ;
                      32     32 ;COMPARE STRING AT (HL) TO STRING AT (DE)
                      33     33 ;RETURN IF EQUAL (THRU X'00' IN DE) OR ON FIRST NOT EQUAL
                      34     34 ;IGNORE ALL SPACES
                      35     35 ;
0010  cf              36     36       RST   8                ;SKIP SPACES
0011  1a              37     37       LD    A,(DE)           ;GET CHAR TO MATCH WITH
0012  b7              38     38       OR    A                ;TEST IT
0013  c2 66 0e        39     39       JP    NZ,COMP2         ;BRIF NOT EQUAL
0016  7e              40     40       LD    A,(HL)           ;GET CHAR FOLLOWING
0017  c9              41     41       RET                    ;RETURN
                      42     42 ;
                      43     43 ;
                      44     44       ORG   24
0018  =               45     45 RST3  EQU   $
                      46     46 ;
                      47     47 ;PRINT: 'XX ERR @ NNNN'
                      48     48 ;
0018  21 02 10        49     49       LD    HL,IOBUF         ;POINT BUFFER
001b  70              50     50       LD    (HL),B           ;MOVE HI CHAR
001c  23              51     51       INC   HL               ;POINT NEXT
001d  c3 41 0f        52     52       JP    ERROR            ;CONTINUE ELSEWHERE
                      53     53 ;
                      54     54 ;
                      55     55       ORG   32
0020  =               56     56 RST4  EQU   $
                      57     57 ;
                      58     58 ;SHIFT THE LOW ORDER 4 BITS OF REG A TO THE HIGH 4 BITS
                      59     59 ;
0020  e6 0f           60     60       AND   0FH              ;ISOLATE LOW 4
0022  17              61     61       RLA                    ;SHIFT ONE BIT
0023  17              62     62       RLA                    ;AGAIN
0024  17              63     63       RLA                    ;AGAIN
0025  17              64     64       RLA                    ;ONE LAST TIME
0026  c9              65     65       RET                    ;RETURN
                      66     66 ;
                      67     67 ;
                      68     68       ORG   40
0028  =               69     69 RST5  EQU   $
                      70     70 ;
                      71     71 ;LOAD THE FLOATING POINT ACCUMULATOR WITH THE 4 BYTES AT (HL)
                      72     72 ;
0028  11 2a 10        73     73       LD    DE,FACC          ;POINT FLOAT ACC
002b  06 04           74     74       LD    B,4              ;BYTE COUNT
002d  c3 57 0e        75     75       JP    COPYH            ;GO MOVE IT
                      76     76 ;
                      77     77 ;
                      78     78       ORG 48
0030  =               79     79 RST6  EQU   $
                      80     80 ;
                      81     81 ;STORE THE FLOATING POINT ACCUMULATOR AT (HL)
                      82     82 ;
0030  11 2a 10        83     83       LD    DE,FACC          ;POINT FLOAT ACC
0033  06 04           84     84       LD    B,4              ;BYTE COUNT
0035  c3 60 0e        85     85       JP    COPYD            ;GO MOVE IT
                      86     86 ;
                      87     87 ;
                      88     88       ORG   56
0038  =               89     89 RST7  EQU   $
                      90     90 ;
                      91     91 ;INCREMENT HL BY BYTE AT (SP), RETURN TO (SP)+1
                      92     92 ;
0038  e3              93     93       EX    (SP),HL          ;GET RETURN ADDR IN HL
0039  7e              94     94       LD    A,(HL)           ;GET THE INCREMENT
003a  23              95     95       INC   HL               ;POINT TRUE RETURN
003b  e3              96     96       EX    (SP),HL          ;PUT BACK TO STACK
003c  d5              97     97       PUSH  DE               ;SAVE DE
003d  5f              98     98       LD    E,A              ;PUT IT IN LOW
003e  b7              99     99       OR    A                ;TEST SIGN
003f  16 00          100    100       LD    D,0              ;DEFAULT POSITIVE
0041  f2 46 00       101    101       JP    P,RST7A          ;BRIF +
0044  16 ff          102    102       LD    D,0FFH           ;ELSE, NEG
0046  19             103    103 RST7A ADD   HL,DE            ;BUMP HL
0047  d1             104    104       POP   DE               ;RESTORE DE
0048  c9             105    105       RET                    ;RETURN
                     106    106 ;
                     107    107 ;
                     108    108 ;
0049  =              109    109 CONTI EQU   $
                     110    110 ;
                     111    111 ;INITIALIZATION ROUTINE
                     112    112 ;DETERMINE MEMORY SIZE. (START AT 4K AND TRY 1K INCREMENTS)
                     113    113 ;SETUP POINTERS FOR STACK, DATA, AND PROGRAM
                     114    114 ;INIT SIO BOARD
                     115    115 ;
                     116    116 ;     OUT   (TTY-1),A        ;WRITE TO SIO
0049  d3 03          117    117       OUT   (TTY+1),A        ;**UM**
                     118    118 ;     LD    A,17H            ;CMND: DTR, ENABLE TRNS, & RCVR,
004b  3e 37          119    119       LD    A,37H            ;**UM**
                     120    120 ;     OUT   (TTY-1),A        ;WRITE TO SIO
004d  d3 03          121    121       OUT   (TTY+1),A        ;**UM**
004f  01 00 04       122    122       LD    BC,1024          ;1K INCR
0052  =              123    123 FINDL EQU   $
0052  7e             124    124       LD    A,(HL)           ;GET A BYTE FROM MEMORY
0053  2f             125    125       CPL                    ;COMPLEMENT
0054  77             126    126       LD    (HL),A           ;REPLACE
0055  be             127    127       CP    (HL)             ;TEST IF RAM/ROM/END
0056  c2 5f 00       128    128       JP    NZ,MEMEN         ;BRIF OUT OF RAM
0059  2f             129    129       CPL                    ;RE-COMPLEMENT
005a  77             130    130       LD    (HL),A           ;PUT ORIG BACK
005b  09             131    131       ADD   HL,BC            ;POINT NEXT 1K BLOCK
005c  d2 52 00       132    132       JP    NC,FINDL         ;LOOP TILL 64K
005f  f9             133    133 MEMEN LD    SP,HL            ;SET STACK POINTER TO END OF MEMORY
0060  ff             134    134       RST   RST7             ;GO BUMP HL ADDR
0061  9c             135    135       DEFB  -100             ;ALLOW 100 BYTES
0062  22 18 11       136    136       LD    (DATAB),HL       ;SAVE ADDR OF START OF DATA
0065  af             137    137       XOR   A                ;GET A ZERO IN A
0066  77             138    138       LD    (HL),A           ;MARK EMPTY DATA
0067  32 61 10       139    139       LD    (OUTSW),A        ;TURN OUTPUT SUPPRESS OFF
006a  f5             140    140       PUSH  AF               ;SET STACK 1 LEVEL DEEP WITHOUT
006b  21 00 00       141    141       LD    HL,0             ;CLEAR HL
006e  39             142    142       ADD   HL,SP            ;SP TO HL
006f  22 6c 10       143    143       LD    (STACK),HL       ;SAVE BEG OF STACK
0072  21 1c 11       144    144       LD    HL,BEGPR-1       ;POINT ONE BEFORE START OF PROGRAM
0075  77             145    145       LD    (HL),A           ;MARK EMPTY
0076  21 fb 0f       146    146       LD    HL,RNDX          ;POINT INIT RND NUMBER
0079  ef             147    147       RST   RST5             ;GO LOAD TO FACC
007a  21 64 10       148    148       LD    HL,RNDNU         ;POINT RAM AREA
007d  f7             149    149       RST   RST6             ;GO STORE
007e  21 00 10       150    150       LD    HL,RAM           ;POINT 1 BEFORE IOBUFF
0081  36 ff          151    151       LD    (HL),0FFH        ;SET HIGH VALUE
0083  cd d1 0a       152    152 GENRN CALL  RND              ;GO GENERATE A RANDUM NUMBER
                     153    153 ;     IN    A,(TTY-1)        ;GET TTY STATUS
                     154    154 ;     AND   40H              ;ISOLATE RXRDY
0086  db 03          155    155       IN    A,(TTY+1)        ;**UM**
0088  e6 02          156    156       AND   2                ;**UM**
008a  ca 83 00       157    157       JP    Z,GENRN
                     158    158 *HEADING IMSAI 8080 4K BASIC
008d  =              159    159 READY EQU   $
                     160    160 ;
                     161    161 ;
                     162    162 ;COMMAND INPUT ROUTINE
                     163    163 ;
                     164    164 ;READ A LINE FROM THE TTY
                     165    165 ;IF STARTS WITH NUMERIC CHARACTERS, ASSUME IT'S A BASIC STA
                     166    166 ;IF NOT, THEN IT IS EITHER AN IMMEDIATE STATEMENT OR A COM
                     167    167 ;
008d  af             168    168 GETCM XOR   A                ;SET NO PROMPT
008e  2a 6c 10       169    169       LD    HL,(STACK)       ;GET STACK ADDRESS
0091  f9             170    170       LD    SP,HL            ;SET REG SP
0092  cd 59 0d       171    171       CALL  TERMI            ;GET A LINE
0095  cd 8d 0e       172    172       CALL  PACK             ;GO PACK THE NUMBER INTO BC
0098  78             173    173       LD    A,B              ;GET HI BYTE OF LINE NUMBER
0099  b1             174    174       OR    C                ;PLUS LOW BYTE
009a  ca 23 01       175    175       JP    Z,EXEC           ;BRIF EXEC STATEMENT
009d  c5             176    176       PUSH  BC               ;SAVE LINE NUMBER
009e  11 d1 10       177    177       LD    DE,IMMED+1       ;POINT SAVE AREA
00a1  eb             178    178       EX    DE,HL            ;FLIP/FLOP
00a2  70             179    179       LD    (HL),B           ;PUT LO LINE
00a3  23             180    180       INC   HL               ;POINT NEXT
00a4  71             181    181       LD    (HL),C           ;PUT LO LINE
00a5  23             182    182       INC   HL               ;POINT NEXT
00a6  06 03          183    183       LD    B,3              ;INIT COUNT
00a8  1a             184    184 EDIT1 LD    A,(DE)           ;GET A BYTE
00a9  77             185    185       LD    (HL),A           ;PUT IT DOWN
00aa  04             186    186       INC   B                ;COUNT IT
00ab  23             187    187       INC   HL               ;POINT NEXT
00ac  13             188    188       INC   DE               ;DITTO
00ad  b7             189    189       OR    A                ;TEST BYTE JUST MOVED
00ae  c2 a8 00       190    190       JP    NZ,EDIT1         ;LOOP
00b1  78             191    191       LD    A,B              ;GET COUNT
00b2  32 d0 10       192    192       LD    (IMMED),A        ;STORE THE COUNT
00b5  c1             193    193       POP   BC               ;GET LINE NUMBER
00b6  21 1d 11       194    194       LD    HL,BEGPR         ;POINT BEGINNING OF PROGRAM
00b9  7e             195    195 EDIT2 LD    A,(HL)           ;GET LEN CODE
00ba  e5             196    196       PUSH  HL               ;SAVE ADDR
00bb  b7             197    197       OR    A                ;TEST IT
00bc  ca f2 00       198    198       JP    Z,EDIT5          ;BRIF END
00bf  23             199    199       INC   HL               ;POINT HI LINE
00c0  7e             200    200       LD    A,(HL)           ;LOAD IT
00c1  b8             201    201       CP    B                ;COMPARE
00c2  da e5 00       202    202       JP    C,EDIT4          ;BRIF LOW
00c5  c2 f2 00       203    203       JP    NZ,EDIT5         ;EDIT5 BRIF HIGH
00c8  23             204    204       INC   HL               ;POINT LO LINE
00c9  7e             205    205       LD    A,(HL)           ;LOAD IT
00ca  b9             206    206       CP    C                ;COMPARE
00cb  da e5 00       207    207       JP    C,EDIT4          ;BRIF LOW
00ce  c2 f2 00       208    208       JP    NZ,EDIT5         ;BRIF HIGH
00d1  2b             209    209       DEC   HL               ;POINT BACK
00d2  2b             210    210       DEC   HL               ;TO BEGIN
00d3  54             211    211       LD    D,H              ;COPY ADDR
00d4  5d             212    212       LD    E,L              ;TO DE
00d5  06 00          213    213       LD    B,0              ;GET A ZERO
00d7  4e             214    214       LD    C,(HL)           ;GET LEN
00d8  09             215    215       ADD   HL,BC            ;POINT NEXT STMT
00d9  7e             216    216 EDIT3 LD    A,(HL)           ;GET LEN NEXT STMT
00da  b7             217    217       OR    A                ;TEST IT
00db  ca ed 00       218    218       JP    Z,EDITX          ;BRIF END
00de  47             219    219       LD    B,A              ;SET LENGTH
00df  cd 57 0e       220    220       CALL  COPYH            ;ELSE MOVE LINE
00e2  c3 d9 00       221    221       JP    EDIT3            ;LOOP
00e5  e1             222    222 EDIT4 POP   HL               ;GET ADDR
00e6  16 00          223    223       LD    D,0              ;ZERO HI LEN
00e8  5e             224    224       LD    E,(HL)           ;GET LO LEN
00e9  19             225    225       ADD   HL,DE            ;COMPUTE ADDR NEXT LINE
00ea  c3 b9 00       226    226       JP    EDIT2            ;LOOP
00ed  eb             227    227 EDITX EX    DE,HL            ;PUT NEW ADDR TO HL
00ee  77             228    228       LD    (HL),A           ;MARK END
00ef  22 1a 11       229    229       LD    (PROGE),HL       ;AND UPDATE ADDRESS
00f2  3a d0 10       230    230 EDIT5 LD    A,(IMMED)        ;GET LEN OF INSERT
00f5  fe 04          231    231       CP    4                ;TEST IF DELETE
00f7  ca 8d 00       232    232       JP    Z,GETCM          ;BRIF IS
00fa  4f             233    233       LD    C,A              ;SET LO LEN
00fb  06 00          234    234       LD    B,0              ;ZERO HI LEN
00fd  2a 1a 11       235    235       LD    HL,(PROGE)       ;GET END OF PROG
0100  54             236    236       LD    D,H              ;COPY TO
0101  5d             237    237       LD    E,L              ;DE
0102  09             238    238       ADD   HL,BC            ;DISP LEN OF INSERT
0103  22 1a 11       239    239       LD    (PROGE),HL       ;UPDATE END POINT
0106  c1             240    240       POP   BC               ;GET ADDR
0107  1a             241    241 EDIT6 LD    A,(DE)           ;GET A BYTE
0108  77             242    242       LD    (HL),A           ;COPY IT
0109  1b             243    243       DEC   DE               ;POINT PRIOR
010a  2b             244    244       DEC   HL               ;DITTO
010b  7a             245    245       LD    A,D              ;GET HI ADDR
010c  b8             246    246       CP    B                ;COMPARE
010d  ca 13 01       247    247       JP    Z,EDIT7          ;BRIF HI EQUAL
0110  d2 07 01       248    248       JP    NC,EDIT6         ;BRIF NOT LESS
0113  7b             249    249 EDIT7 LD    A,E              ;GET LO ADDR
0114  b9             250    250       CP    C                ;COMPARE
0115  d2 07 01       251    251       JP    NC,EDIT6         ;BRIF NOT LESS
0118  13             252    252       INC   DE               ;POINT FORWARD
0119  21 d0 10       253    253       LD    HL,IMMED         ;POINT INSERT
011c  46             254    254       LD    B,(HL)           ;GET LENGTH
011d  cd 57 0e       255    255       CALL  COPYH            ;GO MOVE IT
0120  c3 8d 00       256    256       JP    GETCM            ;GO COMMAND
                     257    257 *HEADING IMSAI 8080 4K BASIC
0123  =              258    258 EXEC  EQU   $
                     259    259 ;
                     260    260 ;
                     261    261 ;
                     262    262 ;DECODE COMMAND IN IOBUFF
                     263    263 ;EXECUTE IF POSSIBLE
                     264    264 ;THEN GOTO GET NEXT COMMAND
                     265    265 ;
                     266    266 ;
0123  11 63 0f       267    267       LD    DE,NEWLI         ;POINT "NEW"
0126  21 02 10       268    268       LD    HL,IOBUF         ;POINT BUFFER
0129  d7             269    269       RST   RST2             ;GO COMPARE
012a  c2 3c 01       270    270       JP    NZ,NOTSC         ;BRIF NOT
012d  21 1d 11       271    271       LD    HL,BEGPR         ;POINT BEGINNING OF PGM
0130  22 1a 11       272    272       LD    (PROGE),HL       ;SAVE END ADDRESS
0133  af             273    273       XOR   A                ;GET A ZERO
0134  77             274    274       LD    (HL),A           ;MARK EMPTY
0135  2a 18 11       275    275       LD    HL,(DATAB)       ;POINT BEGINNING OF DATA
0138  77             276    276       LD    (HL),A           ;MARK EMPTY
0139  c3 8d 00       277    277       JP    READY            ;GO GET NEXT COMMAND
013c  11 5f 0f       278    278 NOTSC LD    DE,LISTL         ;POINT LITERAL
013f  21 02 10       279    279       LD    HL,IOBUF         ;POINT BUFFER
0142  d7             280    280       RST   RST2             ;GO COMPARE
0143  ca d3 01       281    281       JP    Z,LIST           ;BRIF 'LIST'
0146  11 67 0f       282    282       LD    DE,RUNLI         ;POINT LITERAL
0149  21 02 10       283    283       LD    HL,IOBUF         ;POINT BUFFER
014c  d7             284    284       RST   RST2             ;GO COMPARE
014d  ca 6d 01       285    285       JP    Z,RUNIT          ;BRIF 'RUN'
0150  32 62 10       286    286       LD    (RUNSW),A        ;SET IMMEDIATE MODE
0153  21 02 10       287    287       LD    HL,IOBUF         ;POINT STMT
0156  11 d0 10       288    288       LD    DE,IMMED         ;POINT NEW AREA
0159  7e             289    289 IMED  LD    A,(HL)           ;GET A BYTE
015a  12             290    290       LD    (DE),A           ;PUT TO D
015b  13             291    291       INC   DE               ;POINT NEXT
015c  23             292    292       INC   HL               ;DITTO
015d  b7             293    293       OR    A                ;TEST IF END
015e  c2 59 01       294    294       JP    NZ,IMED          ;LOOP
0161  21 00 10       295    295       LD    HL,NULLI         ;POINT FFFF
0164  22 6a 10       296    296       LD    (LINE),HL        ;SAVE ADDR
0167  21 d0 10       297    297       LD    HL,IMMED         ;POINT START OF CMMD
016a  c3 a2 01       298    298       JP    IMMD             ;GO IMMEDIATE
                     299    299 *HEADING IMSAI 8080 4K BASIC
016d  =              300    300 RUNIT EQU   $
                     301    301 ;
                     302    302 ;
                     303    303 ;RUN PROCESSOR, GET NEXT STATEMENT, AND EXECUTE IT
                     304    304 ;IF IN IMMEDIATE MODE, THEN RETURN TO GETCMMD
                     305    305 ;
                     306    306 ;
016d  af             307    307       XOR   A                ;CLEAR A REG
016e  32 62 10       308    308       LD    (RUNSW),A        ;RESET SWITCH
0171  32 6e 10       309    309       LD    (FORNE),A        ;INIT FOR/NEXT TABLE
0174  2a 18 11       310    310       LD    HL,(DATAB)       ;POINT START OF VARIABLES
0177  36 00          311    311       LD    (HL),0           ;CLEAR IT
0179  21 1c 11       312    312       LD    HL,BEGPR-1       ;GET ADDR OF PROGRAM
017c  22 16 11       313    313       LD    (DATAP),HL       ;'RESTORE'
017f  23             314    314       INC   HL               ;POINT 1ST BYTE
0180  22 5d 10       315    315       LD    (STMT),HL        ;SAVE IT
0183  c3 90 01       316    316       JP    NEXTS            ;GO PROCESS IT
                     317    317 ;
0186  2a 5d 10       318    318 RUN   LD    HL,(STMT)        ;GET ADDR OF PREVIOUS STMT
0189  5e             319    319       LD    E,(HL)           ;GET LEN CODE
018a  16 00          320    320       LD    D,0              ;CLEAR HIGH BYTE OF ADDR
018c  19             321    321       ADD   HL,DE            ;INCR STMT POINTER
018d  22 5d 10       322    322       LD    (STMT),HL        ;SAVE IT
                     323    323 ;
0190  =              324    324 NEXTS EQU   $
0190  3a 62 10       325    325       LD    A,(RUNSW)        ;GET RUN TYPE
0193  b7             326    326       OR    A                ;TEST IT
0194  c2 8d 00       327    327       JP    NZ,GETCM         ;BRIF IMMEDIATE MODE
0197  7e             328    328       LD    A,(HL)           ;GET LEN CODE
0198  b7             329    329       OR    A                ;SEE IF NO MORE STATEMENTS
0199  ca 8d 00       330    330       JP    Z,READY          ;BRIF END
019c  =              331    331 NOTDO EQU   $
019c  23             332    332       INC   HL               ;POINT LINE NUMBER
019d  22 6a 10       333    333       LD    (LINE),HL        ;SAVE ADDR
01a0  23             334    334       INC   HL               ;POINT 2ND BYTE
01a1  23             335    335       INC   HL               ;POINT 1ST PGM BYTE
01a2  cf             336    336 IMMD  RST   RST1             ;SKIP BLANKS
01a3  22 57 10       337    337 CONTX LD    (ADDR1),HL       ;SAVE ADDR
01a6  cd 2d 0e       338    338       CALL  TSTCH            ;GO SEE IF CONTROL-C
01a9  11 7b 0f       339    339       LD    DE,JMPTB         ;POINT TO TABLE
01ac  1a             340    340 TABLO LD    A,(DE)           ;GET FIRST BYTE OF LIT
01ad  b7             341    341       OR    A                ;TEST IF END OF TABLE
01ae  ca cd 01       342    342       JP    Z,TABEN          ;BRIF IS
01b1  2a 57 10       343    343       LD    HL,(ADDR1)       ;GET ADDRESS OF CMMD
01b4  d7             344    344       RST   RST2             ;GO COMPARE
01b5  c2 c1 01       345    345       JP    NZ,NOJMP         ;BRIF NOT EQUAL
01b8  e5             346    346       PUSH  HL               ;SAVE HL
01b9  13             347    347       INC   DE               ;POINT NEXT BYTE
01ba  1a             348    348       LD    A,(DE)           ;LOAD IT
01bb  6f             349    349       LD    L,A              ;LOW BYTE TOL
01bc  13             350    350       INC   DE               ;POINT NEXT BYTE
01bd  1a             351    351       LD    A,(DE)           ;LOAD IT
01be  67             352    352       LD    H,A              ;HIGH BYTE TO H
01bf  e3             353    353       EX    (SP),HL          ;HL TO STACK, STACK TO HL
01c0  c9             354    354       RET                    ;JUMP TO PROPER ROUTINE
01c1  13             355    355 NOJMP INC   DE               ;POINT NEXT
01c2  1a             356    356       LD    A,(DE)           ;LOAD IT
01c3  b7             357    357       OR    A                ;TEST IT
01c4  c2 c1 01       358    358       JP    NZ,NOJMP         ;BRIF NOT
01c7  13             359    359       INC   DE               ;POINT NEXT
01c8  13             360    360       INC   DE               ;DITTO
01c9  13             361    361       INC   DE               ;POINT FIRST BYTE NEXT LIT
01ca  c3 ac 01       362    362       JP    TABLO            ;LOOP
                     363    363 ;
01cd  2a 57 10       364    364 TABEN LD    HL,(ADDR1)       ;RESTORE HL POINTER
01d0  c3 1a 04       365    365       JP    LET              ;ASSUME IT'S A LET STATEMENT
                     366    366 *HEADING IMSAI 8080 4K BASIC
01d3  =              367    367 LIST  EQU   $
                     368    368 ;
                     369    369 ;
                     370    370 ;LIST PROCESSOR
                     371    371 ;DUMP THE SOURCE PROGRAM TO TTY OR PAPER TAPE
                     372    372 ;
                     373    373 ;
01d3  21 1d 11       374    374       LD    HL,BEGPR         ;POINT BEGINNING OF PROGRAM
01d6  7e             375    375 LISTX LD    A,(HL)           ;GET LEN CODE
01d7  b7             376    376       OR    A                ;TEST IF END OF PGM
01d8  ca 8d 00       377    377       JP    Z,READY          ;BRIF END OF PGM
01db  d6 03          378    378       SUB   3                ;SUBTRACT THREE
01dd  47             379    379       LD    B,A              ;SAVE LEN
01de  23             380    380       INC   HL               ;POINT HI BYTE OF LINE #
01df  11 02 10       381    381       LD    DE,IOBUF         ;POINT BUFFER AREA
01e2  cd 19 0e       382    382       CALL  LINEO            ;CONVERT LINE NUMBER
01e5  cd 57 0e       383    383       CALL  COPYH            ;GO MOVE THE LINE
01e8  cd 2d 0e       384    384       CALL  TSTCH            ;GO SEE IF CONTROL-C
01eb  e5             385    385       PUSH  HL               ;SAVE HL ADDR
01ec  cd f4 0d       386    386       CALL  TERMO            ;GO TYPE IT
01ef  e1             387    387       POP   HL               ;RETREIVE H ADDR
01f0  c3 d6 01       388    388       JP    LISTX            ;CONTINUE
                     389    389 ;
                     390    390 *HEADING IMSAI 8080 4K BASIC
01f3  =              391    391 GOSUB EQU   $
                     392    392 ;
                     393    393 ;
                     394    394 ; STMT:  GOSUB NNNN
                     395    395 ;
01f3  eb             396    396       EX    DE,HL            ;FLIP/FLOP DE HL
01f4  2a 5d 10       397    397       LD    HL,(STMT)        ;GET STATEMENT ADDRESS
01f7  e5             398    398       PUSH  HL               ;SAVE RETURN ADDRESS IN STACK
01f8  3e ff          399    399       LD    A,0FFH           ;MARK AS GOSUB
01fa  f5             400    400       PUSH  AF               ;SAVE STATUS
01fb  eb             401    401       EX    DE,HL            ;RESTORE HL
                     402    402 ;
                     403    403 ;
01fc  =              404    404 GOTO  EQU   $
                     405    405 ;
                     406    406 ;
                     407    407 ; STMT:  GOTO NNNN
                     408    408 ;
01fc  cd 8d 0e       409    409       CALL  PACK             ;GO GET LINE NUMBER IN BC
01ff  21 1d 11       410    410       LD    HL,BEGPR         ;POINT BEGINNING OF PROGRAM
0202  7e             411    411 GOTO1 LD    A,(HL)           ;GET LEN
0203  b7             412    412       OR    A                ;TEST IF END OF PROGRAM
0204  ca 6d 0e       413    413       JP    Z,ULERR          ;BRIF UNDEFIND STATEMENT
0207  23             414    414       INC   HL               ;POINT NEXT
0208  7e             415    415       LD    A,(HL)           ;GET THE HIGH LINE NUMBER
0209  b8             416    416       CP    B                ;TEST WITH DESIRED
020a  da 1e 02       417    417       JP    C,GOTO2          ;BRIF LOW
020d  23             418    418       INC   HL               ;POINT NEXT BYTE
020e  7e             419    419       LD    A,(HL)           ;GET LOW LINE NUMBER
020f  2b             420    420       DEC   HL               ;POINT BACK
0210  b9             421    421       CP    C                ;TEST WITH WANTED
0211  da 1e 02       422    422       JP    C,GOTO2          ;BRIF LOW
0214  c2 6d 0e       423    423       JP    NZ,ULERR         ;BRIF LINE MISSING
0217  2b             424    424       DEC   HL               ;POINT TO START OF STMT
0218  22 5d 10       425    425       LD    (STMT),HL        ;SAVE ADDR
021b  c3 90 01       426    426       JP    NEXTS            ;GO PROCESS THE STATEMENT
021e  2b             427    427 GOTO2 DEC   HL               ;POINT START OF STMT
021f  5e             428    428       LD    E,(HL)           ;GET LENGTH
0220  16 00          429    429       LD    D,0              ;ZERO MDB
0222  19             430    430       ADD   HL,DE            ;POINT NEXT STMT
0223  c3 02 02       431    431       JP    GOTO1            ;LOOP
                     432    432 *HEADING IMSAI 8080 4K BASIC
0226  =              433    433 RETUR EQU   $
                     434    434 ;
                     435    435 ;
                     436    436 ; STMT:  RETURN
                     437    437 ;
0226  f1             438    438       POP   AF               ;POP THE STACK
0227  fe ff          439    439       CP    0FFH             ;TEST IF GOSUB IN EFFECT
0229  c2 7d 0e       440    440       JP    NZ,RTERR         ;BRIF ERROR
022c  e1             441    441       POP   HL               ;GET RETURNED STATEMENT ADDRESS
022d  22 5d 10       442    442       LD    (STMT),HL        ;RESTORE
0230  c3 86 01       443    443       JP    RUN              ;CONTINUE AT STMT FOLLOWING GOSUB
                     444    444 *HEADING IMSAI 8080 4K BASIC
0233  =              445    445 PRINT EQU   $
                     446    446 ;
                     447    447 ;
                     448    448 ; STMT:  PRINT . . . .
                     449    449 ;
                     450    450 ;
0233  af             451    451       XOR   A                ;CLEAR REG A
0234  32 56 10       452    452       LD    (PRSW),A         ;SET SWITCH
0237  11 02 10       453    453 PR1   LD    DE,IOBUF         ;POINT BUFFER
023a  cf             454    454       RST   RST1             ;SKIP TO NEXT FIELD
023b  fe 22          455    455       CP    '"'              ;TEST IF QUOTE
023d  c2 66 02       456    456       JP    NZ,PR6           ;BRIF NOT LITERAL
0240  23             457    457 PR2   INC   HL               ;POINT NEXT
0241  7e             458    458       LD    A,(HL)           ;GET THE CHAR
0242  b7             459    459       OR    A                ;TEST IF END OF STMT
0243  ca 79 0e       460    460       JP    Z,SNERR          ;BRIF MISSING END OF QUOTE
0246  fe 22          461    461 PR3   CP    '"'              ;TEST IF END QUOTE
0248  c2 61 02       462    462       JP    NZ,PR5           ;BRIF NOT
024b  23             463    463       INC   HL               ;POINT NEXT
024c  3e fe          464    464 PRNXT LD    A,0FEH           ;SET CODE = NO CR/LF
024e  12             465    465       LD    (DE),A           ;PUT TO BUFFER
024f  e5             466    466       PUSH  HL               ;SAVE HL
0250  cd f4 0d       467    467       CALL  TERMO            ;GO PRINT IT
0253  e1             468    468       POP   HL               ;RESTORE HL
0254  c3 33 02       469    469       JP    PRINT            ;RECURSIVE TO NEXT FIELD
0257  3a 56 10       470    470 PR4   LD    A,(PRSW)         ;GET SWITCH
025a  b7             471    471       OR    A                ;TEST IF STMT ENDED WITH , OR ;
025b  cc b9 0d       472    472       CALL  Z,CRLF           ;CALL IF NOT
025e  c3 86 01       473    473       JP    RUN              ;CONTINUE NEXT STMT
0261  12             474    474 PR5   LD    (DE),A           ;PUT CHAR TO BUFFER
0262  13             475    475       INC   DE               ;POINT NEXT OUT
0263  c3 40 02       476    476       JP    PR2              ;LOOP
0266  b7             477    477 PR6   OR    A                ;TEST IF END OF STMT
0267  ca 57 02       478    478       JP    Z,PR4            ;BRIF IT IS
026a  fe 2c          479    479       CP    ','              ;TEST IF COMMA
026c  ca 87 02       480    480       JP    Z,PR7            ;BRIF IT IS
026f  fe 3b          481    481       CP    ';'              ;TEST IF SEMI-COLON
0271  ca ad 02       482    482       JP    Z,PR8            ;BRIF IT IS
0274  d5             483    483       PUSH  DE               ;SAVE DE
0275  cd ef 0a       484    484       CALL  EXPR             ;GO EVALUATE EXPRESSION
0278  d1             485    485       POP   DE               ;RESTORE DE
0279  e5             486    486       PUSH  HL               ;SAVE HL
027a  eb             487    487       EX    DE,HL            ;FLIP/FLOP
027b  cd 07 06       488    488       CALL  FOUT             ;GO CONVERT OUTPUT
027e  23             489    489       INC   HL               ;POINT NEXT
027f  36 20          490    490       LD    (HL),' '         ;SPACE FOLLOWS NUMBERS
0281  23             491    491       INC   HL               ;POINT NEXT
0282  eb             492    492       EX    DE,HL            ;FLIP/FLOP
0283  e1             493    493       POP   HL               ;RESTORE HL
0284  c3 4c 02       494    494       JP    PRNXT            ;CONTINUE
0287  3a 63 10       495    495 PR7   LD    A,(COLUM)        ;GET COLUMN POINTER
028a  fe 38          496    496       CP    56               ;COMPARE TO 56
028c  d2 b4 02       497    497       JP    NC,TBEND         ;BRIF NO ROOM LEFT
028f  47             498    498       LD    B,A              ;SAVE IT
0290  af             499    499       XOR   A                ;INIT POSITION
0291  b8             500    500 TBLP  CP    B                ;COMPARE
0292  ca 98 02       501    501       JP    Z,TBLP2          ;BRIF ON A TAB STOP
0295  d2 9d 02       502    502       JP    NC,TBON          ;BRIF SHY OF TAB
0298  c6 0e          503    503 TBLP2 ADD   A,14             ;POINT NEXT STOP
029a  c3 91 02       504    504       JP    TBLP             ;LOOP
029d  32 63 10       505    505 TBON  LD    (COLUM),A        ;UPDATE CTR
02a0  90             506    506       SUB   B                ;COMPUTE NUMBER OF SPACES
02a1  47             507    507       LD    B,A              ;SAVE IT
02a2  cd a5 0d       508    508 TBSPA CALL  TESTO            ;WAIT TILL READY
02a5  3e 20          509    509       LD    A,' '            ;SPACE TO REG A
02a7  d3 02          510    510       OUT   (TTY),A          ;OUTPUT IT
02a9  05             511    511       DEC   B                ;SUB 1 FROM CTR
02aa  c2 a2 02       512    512       JP    NZ,TBSPA         ;LOOP IF NOT
02ad  23             513    513 PR8   INC   HL               ;POINT NEXT
02ae  32 56 10       514    514       LD    (PRSW),A         ;SET THE SWITCH
02b1  c3 37 02       515    515       JP    PR1              ;GO NEXT FIELD
02b4  cd b9 0d       516    516 TBEND CALL  CRLF             ;PUT CR/LF
02b7  c3 ad 02       517    517       JP    PR8              ;GO SET SW
                     518    518 *HEADING IMSAI 8080 4K BASIC
02ba  =              519    519 FOR   EQU   $
                     520    520 ;
                     521    521 ;
                     522    522 ; STMT:  FOR VAR = EXPR TO EXPR :STEP EXPR:
                     523    523 ;
                     524    524 ;
02ba  cd 2f 0f       525    525       CALL  VAR              ;NEXT WORD MUST BE VARIABLE
02bd  eb             526    526       EX    DE,HL            ;FLIP/FLOP
02be  22 5f 10       527    527       LD    (INDX),HL        ;SAVE VARIABLE NAME
02c1  eb             528    528       EX    DE,HL            ;FLIP/FLOP AGAIN
02c2  fe 3d          529    529       CP    '='              ;TEST FOR EQUAL SIGN
02c4  c2 79 0e       530    530       JP    NZ,SNERR         ;BRIF NO EQUAL
02c7  23             531    531       INC   HL               ;POINT NEXT
02c8  cd ef 0a       532    532       CALL  EXPR             ;GO EVALUATE EXPR IF ANY
02cb  e5             533    533       PUSH  HL               ;SAVE HL
02cc  2a 5f 10       534    534       LD    HL,(INDX)        ;GET INDEX NAME
02cf  eb             535    535       EX    DE,HL            ;FLIP/FLOP
02d0  cd fd 0e       536    536       CALL  SEARC            ;GO LOCATE NAME
02d3  eb             537    537       EX    DE,HL            ;PUT ADDR IN HL
02d4  22 57 10       538    538       LD    (ADDR1),HL       ;SAVE ADDR
02d7  f7             539    539       RST   RST6             ;GO STORE THE VALUE
02d8  e1             540    540       POP   HL               ;RESTORE POINTER TO STMT
02d9  11 bf 0f       541    541       LD    DE,TOLIT         ;GET LIT ADDR
02dc  d7             542    542       RST   RST2             ;GO COMPARE
02dd  c2 79 0e       543    543       JP    NZ,SNERR         ;BRIF ERROR
02e0  cd ef 0a       544    544       CALL  EXPR             ;GO EVALUATE TO-EXPR
02e3  e5             545    545       PUSH  HL               ;SAVE HL
02e4  21 3a 10       546    546       LD    HL,TVAR1         ;POINT SAVE AREA
02e7  f7             547    547       RST   RST6             ;SAVE 'TO' EXPR
02e8  21 ef 0f       548    548       LD    HL,ONE           ;POINT CONSTANT: 1
02eb  ef             549    549       RST   RST5             ;LOAD IT
02ec  e1             550    550       POP   HL               ;RESTORE HL
02ed  7e             551    551       LD    A,(HL)           ;GET THAT CHAR
02ee  b7             552    552       OR    A                ;TEST FOR END OF STATEMENT
02ef  ca fc 02       553    553       JP    Z,NOSTP          ;BRIF NO STEP
02f2  11 dd 0f       554    554       LD    DE,STEPL         ;TEST FOR LIT STEP
02f5  d7             555    555       RST   RST2             ;GO COMPARE
02f6  c2 79 0e       556    556       JP    NZ,SNERR         ;BRIF NOT STEP
02f9  cd ef 0a       557    557 FORST CALL  EXPR             ;GO EVAL STEP
02fc  21 3e 10       558    558 NOSTP LD    HL,TVAR2         ;GET ADDR OF TEMP VARIABLE
02ff  f7             559    559       RST   RST6             ;SAVE END VALUE
0300  cd 9e 09       560    560       CALL  FTEST            ;GET SIGN OF FACC
0303  f5             561    561       PUSH  AF               ;SAVE A, STATUS
0304  21 3a 10       562    562       LD    HL,TVAR1         ;GET END VALUE
0307  ef             563    563       RST   RST5             ;LOAD IT
0308  2a 57 10       564    564       LD    HL,(ADDR1)       ;GET ADDR OF INDEX
030b  cd cb 07       565    565       CALL  FSUB             ;COMPAE TO END VALUE
030e  f1             566    566       POP   AF               ;RESTORE STATUS
030f  f2 1e 03       567    567       JP    P,FORPO          ;BRIF FOR IS POS
0312  cd 9e 09       568    568 FORXE CALL  FTEST            ;GET SIGN OF DIFFERENCE
0315  ca 24 03       569    569       JP    Z,FORTA          ;BRIF START = END
0318  fa 24 03       570    570       JP    M,FORTA          ;BRIF START > END
031b  c3 6e 03       571    571       JP    LNEXT            ;GO LOCATE MATCHING NEXT
031e  cd 9e 09       572    572 FORPO CALL  FTEST            ;GET SIGN OF DIFFERENCE
0321  fa 6e 03       573    573       JP    M,LNEXT          ;BRIF START > END
0324  11 6e 10       574    574 FORTA LD    DE,FORNE         ;POINT TABLE
0327  2a 5f 10       575    575       LD    HL,(INDX)        ;GET INDEX NAME
032a  eb             576    576       EX    DE,HL            ;FLIP/FLOP
032b  7e             577    577       LD    A,(HL)           ;GET COUNT
032c  47             578    578       LD    B,A              ;STORE IT
032d  0e 01          579    579       LD    C,1              ;NEW CTR
032f  b7             580    580       OR    A                ;TEST IF ZERO
0330  23             581    581       INC   HL               ;POINT
0331  ca 47 03       582    582       JP    Z,FOREQ          ;BRIF TABLE EMPTY
0334  7e             583    583 FORLP LD    A,(HL)           ;GET 1ST BYTE
0335  ba             584    584       CP    D                ;TEST IF EQUAL
0336  c2 40 03       585    585       JP    NZ,FORNO         ;BRIF NOT
0339  23             586    586       INC   HL               ;POINT NEXT
033a  7e             587    587       LD    A,(HL)           ;GET NEXT BYTE
033b  2b             588    588       DEC   HL               ;POINT BACK
033c  bb             589    589       CP    E                ;TEST IF EQUAL
033d  c2 47 03       590    590       JP    NZ,FOREQ         ;BRIF EQUAL
0340  ff             591    591 FORNO RST   RST7             ;GO BUMP HL
0341  0c             592    592       DEFB  12               ;BY 12
0342  0c             593    593       INC   C                ;COUNT IT
0343  05             594    594       DEC   B                ;DECR CTR
0344  c2 34 03       595    595       JP    NZ,FORLP         ;LOOP
0347  79             596    596 FOREQ LD    A,C              ;GET UPDATED COUNT
0348  fe 09          597    597       CP    9                ;TEST IF TBL EXCEEDED
034a  d2 85 0e       598    598       JP    NC,FOERR         ;ERROR IF MORE THAN 8 OPEN FOR/NEXT
034d  32 6e 10       599    599       LD    (FORNE),A        ;PUT IN TABLE
0350  72             600    600       LD    (HL),D           ;STORE IT
0351  23             601    601       INC   HL               ;POINT NEXT
0352  73             602    602       LD    (HL),E           ;STORE IT TOO
0353  23             603    603       INC   HL               ;POINT NEXT
0354  e5             604    604       PUSH  HL               ;SAVE HL
0355  21 3e 10       605    605       LD    HL,TVAR2         ;POINT STEP
0358  ef             606    606       RST   RST5             ;GO LOAD IT
0359  e1             607    607       POP   HL               ;RESTORE HL
035a  f7             608    608       RST   RST6             ;PUT IN TABLE
035b  e5             609    609       PUSH  HL               ;SAVE HL
035c  21 3a 10       610    610       LD    HL,TVAR1         ;POINT TO-VAL
035f  ef             611    611       RST   RST5             ;GO LOAD IT
0360  e1             612    612       POP   HL               ;RESTORE HL
0361  f7             613    613       RST   RST6             ;PUT IN TABLE
0362  3a 5e 10       614    614       LD    A,(STMT+1)       ;GET HIGH STMT ADDR
0365  77             615    615       LD    (HL),A           ;PUT IT
0366  23             616    616       INC   HL               ;POINT NEXT
0367  3a 5d 10       617    617       LD    A,(STMT)         ;GET LOW STMT ADDR
036a  77             618    618       LD    (HL),A           ;PUT IT
036b  c3 86 01       619    619       JP    RUN              ;CONTINUE
036e  2a 5d 10       620    620 LNEXT LD    HL,(STMT)        ;GET ADDR OF STMT
0371  5e             621    621       LD    E,(HL)           ;GET LENGTH CODE
0372  16 00          622    622       LD    D,0              ;INIT INCREMENT
0374  19             623    623       ADD   HL,DE            ;COMPUTE ADDR OF NEXT STATEMENT
0375  7e             624    624       LD    A,(HL)           ;GET NEW LEN CODE
0376  b7             625    625       OR    A                ;SEE IF END OF PGM
0377  ca 89 0e       626    626       JP    Z,NXERR          ;BRIF IT IS
037a  22 5d 10       627    627       LD    (STMT),HL        ;SAVE ADDRESS
037d  ff             628    628       RST   RST7             ;GO BUMP HL
037e  03             629    629       DEFB  3                ;BY THREE
037f  cf             630    630       RST   RST1             ;SKIP SPACES
0380  11 94 0f       631    631       LD    DE,NEXTL         ;POINT 'NEXT'
0383  d7             632    632       RST   RST2             ;SEE IF IT IS A NEXT STMT
0384  c2 6e 03       633    633       JP    NZ,LNEXT         ;LOOP IF NOT
0387  cf             634    634       RST   RST1             ;SKIP SPACES
0388  3a 60 10       635    635       LD    A,(INDX+1)       ;GET FIRST CHAR
038b  be             636    636       CP    (HL)             ;COMPARE
038c  c2 6e 03       637    637       JP    NZ,LNEXT         ;BRIF NOT MATCH NEXT
038f  3a 5f 10       638    638       LD    A,(INDX)         ;GET 2ND CHAR
0392  23             639    639       INC   HL               ;DITTO
0393  fe 20          640    640       CP    ' '              ;SEE IF SINGLE CHAR
0395  ca 9c 03       641    641       JP    Z,FORN1          ;BRIF IT IS
0398  be             642    642       CP    (HL)             ;COMPARE THE TWO
0399  c2 6e 03       643    643       JP    NZ,LNEXT         ;BRIF NOT EQUAL
039c  cf             644    644 FORN1 RST   RST1             ;SKIP TO END (HOPEFULLY)
039d  b7             645    645       OR    A                ;SEE IF END
039e  c2 6e 03       646    646       JP    NZ,LNEXT         ;BRIF NOT END
03a1  c3 86 01       647    647       JP    RUN              ;ELSE, GO NEXT STMT
                     648    648 *HEADING IMSAI 8080 4K BASIC
03a4  =              649    649 IF    EQU   $
                     650    650 ;
                     651    651 ;
                     652    652 ; STMT:  IF EXPR RELATION EXPR THEN STMT #
                     653    653 ;
                     654    654 ;
03a4  cd ef 0a       655    655       CALL  EXPR             ;GO EVALUATE LEFT EXPRESSION
03a7  e5             656    656       PUSH  HL               ;SAVE HL
03a8  21 3a 10       657    657       LD    HL,TVAR1         ;GET ADDR OF TEMP STORAGE
03ab  f7             658    658       RST   RST6             ;SAVE IT
03ac  e1             659    659       POP   HL               ;RESTORE HL
03ad  af             660    660       XOR   A                ;CLEAR A
03ae  4f             661    661       LD    C,A              ;SAVE IN REG C
03af  47             662    662       LD    B,A              ;INIT REG
03b0  7e             663    663 IFREL LD    A,(HL)           ;GET OPERATOR
03b1  04             664    664       INC   B                ;COUNT
03b2  fe 3d          665    665       CP    '='              ;TEST FOR EQUAL
03b4  c2 b9 03       666    666       JP    NZ,IFEQ          ;BRIF IT IS
03b7  0c             667    667       INC   C                ;ADD 1 TO C
03b8  23             668    668       INC   HL               ;POINT NEXT
03b9  fe 3e          669    669 IFEQ  CP    '>'              ;TEST FOR GREATER THAN
03bb  c2 c1 03       670    670       JP    NZ,IFGT          ;BRIF IT IS
03be  0c             671    671       INC   C                ;ADD TWO
03bf  0c             672    672       INC   C                ;TO REL CODE
03c0  23             673    673       INC   HL               ;POINT NEXT
03c1  fe 3c          674    674 IFGT  CP    '<'              ;TEST FOR LESS THAN
03c3  c2 cb 03       675    675       JP    NZ,IFLT          ;BRIF IT IS
03c6  79             676    676       LD    A,C              ;GET REL CODE
03c7  c6 04          677    677       ADD   A,4              ;PLUS FOUR
03c9  4f             678    678       LD    C,A              ;PUT BACK
03ca  23             679    679       INC   HL               ;POINT NEXT
03cb  79             680    680 IFLT  LD    A,C              ;GET REL CODE
03cc  b7             681    681       OR    A                ;TEST IT
03cd  ca 79 0e       682    682       JP    Z,SNERR          ;BRIF SOME ERROR
03d0  32 38 10       683    683       LD    (REL),A          ;SAVE CODE
03d3  78             684    684       LD    A,B              ;GET COUNT
03d4  fe 02          685    685       CP    2                ;TEST FOR TWO
03d6  c2 b0 03       686    686       JP    NZ,IFREL         ;SEE IF MULTIPLE RELATION
03d9  cd ef 0a       687    687       CALL  EXPR             ;GO EVALUATE RIGHT SIDE
03dc  e5             688    688       PUSH  HL               ;SAVE STMT LOCATION
03dd  21 3a 10       689    689       LD    HL,TVAR1         ;POINT LEFT
03e0  cd cb 07       690    690       CALL  FSUB             ;SUBTRACT LEFT FROM RIGHT
03e3  e1             691    691       POP   HL               ;RESTORE STMT ADDR
03e4  3a 38 10       692    692       LD    A,(REL)          ;GET RELATION
03e7  1f             693    693       RRA                    ;TEST BIT D0
03e8  d2 f1 03       694    694       JP    NC,IFNOT         ;BRIF NO EQUAL TEST
03eb  cd 9e 09       695    695       CALL  FTEST            ;GET SIGN OF DIFFERENCE
03ee  ca 10 04       696    696       JP    Z,TRUE           ;BRIF LEFT=RIGHT
03f1  3a 38 10       697    697 IFNOT LD    A,(REL)          ;LOAD RELATION
03f4  e6 02          698    698       AND   02H              ;MASK IT
03f6  ca ff 03       699    699       JP    Z,IFNTX          ;BRIF NO >
03f9  cd 9e 09       700    700       CALL  FTEST            ;GET SIGN OF DIFFERENCE
03fc  fa 10 04       701    701       JP    M,TRUE           ;BRIF GT
03ff  3a 38 10       702    702 IFNTX LD    A,(REL)          ;LOAD RELATION
0402  e6 04          703    703       AND   04H              ;MASK IT
0404  ca 86 01       704    704       JP    Z,RUN            ;BRIF NO <
0407  cd 9e 09       705    705       CALL  FTEST            ;GET SIGN OF DIFFERENCE
040a  fa 86 01       706    706       JP    M,RUN            ;BRIF GT
040d  ca 86 01       707    707       JP    Z,RUN            ;BRIF EQUAL
0410  11 e2 0f       708    708 TRUE  LD    DE,THENL         ;GET ADDR 'THEN'
0413  d7             709    709       RST   RST2             ;GO COMPARE
0414  c2 79 0e       710    710       JP    NZ,SNERR         ;BRIF ERROR
0417  c3 fc 01       711    711       JP    GOTO             ;BRIF IT IS
                     712    712 *HEADING IMSAI 8080 4K BASIC
041a  =              713    713 LET   EQU   $
                     714    714 ;
                     715    715 ;
                     716    716 ; STMT:  :LET: VAR = EXPR
                     717    717 ;
                     718    718 ;
041a  cd 2f 0f       719    719       CALL  VAR              ;NEXT MUST BE VARIABLE NAME
041d  fe 3d          720    720       CP    '='              ;TEST FOR EQUAL SIGN
041f  c2 79 0e       721    721       JP    NZ,SNERR         ;BRIF MISSING EQUAL
0422  cd fd 0e       722    722       CALL  SEARC            ;GO FIND ADDRESS OF VAR
0425  d5             723    723       PUSH  DE               ;SAVE ADDRESS
0426  23             724    724       INC   HL               ;POINT NEXT
0427  cd ef 0a       725    725       CALL  EXPR             ;GO EVALUATE EXPRESSION
042a  e1             726    726       POP   HL               ;RESTORE ADDRESS
042b  f7             727    727       RST   RST6             ;GO STORE VARIABLE
042c  c3 86 01       728    728       JP    RUN              ;CONTINUE
                     729    729 *HEADING IMSAI 8080 4K BASIC
042f  =              730    730 NEXT  EQU   $
                     731    731 ;
                     732    732 ;
                     733    733 ; STMT:  NEXT VAR
                     734    734 ;
                     735    735 ;
042f  cd 2f 0f       736    736       CALL  VAR              ;GET VARIABLE NAME
0432  eb             737    737       EX    DE,HL            ;FLIP/FLOP
0433  22 5f 10       738    738       LD    (INDX),HL        ;SAVE VAR NAME
0436  e5             739    739       PUSH  HL               ;SAVE VAR NAME
0437  21 6e 10       740    740       LD    HL,FORNE         ;POINT FOR/NEXT TABLE
043a  46             741    741       LD    B,(HL)           ;GET SIZE
043b  78             742    742       LD    A,B              ;LOAD IT
043c  b7             743    743       OR    A                ;TEST IT
043d  ca 89 0e       744    744       JP    Z,NXERR          ;BRIF TABLE EMPTY
0440  23             745    745       INC   HL               ;POINT NEXT
0441  d1             746    746       POP   DE               ;RESTORE VAR NAME
0442  7e             747    747 NXLP  LD    A,(HL)           ;GET 1ST BYTE
0443  23             748    748       INC   HL               ;POINT NEXT
0444  ba             749    749       CP    D                ;COMPARE
0445  c2 4d 04       750    750       JP    NZ,NXNE          ;BRIF NOT EQUAL
0448  7e             751    751       LD    A,(HL)           ;GET 2ND BYTE
0449  bb             752    752       CP    E                ;COMPARE
044a  ca 56 04       753    753       JP    Z,NXEQ           ;BRIF EQUAL
044d  ff             754    754 NXNE  RST   RST7             ;GO BUMP HL
044e  0b             755    755       DEFB  11               ;BY ELEVEN
044f  05             756    756       DEC   B                ;DECR COUNT
0450  c2 42 04       757    757       JP    NZ,NXLP          ;LOOP
0453  c3 89 0e       758    758       JP    NXERR            ;GO PUT ERROR MSG
0456  3a 6e 10       759    759 NXEQ  LD    A,(FORNE)        ;GET ORIG COUNT
0459  90             760    760       SUB   B                ;MINUS REMAIN
045a  3c             761    761       INC   A                ;PLUS ONE
045b  32 6e 10       762    762       LD    (FORNE),A        ;STORE NEW COUNT
045e  23             763    763       INC   HL               ;POINT STEP
045f  e5             764    764       PUSH  HL               ;SAVE HL ADDR
0460  cd fd 0e       765    765       CALL  SEARC            ;GO GET ADDR OF INDEX
0463  eb             766    766       EX    DE,HL            ;PUT TO HL
0464  22 57 10       767    767       LD    (ADDR1),HL       ;SAVR IT
0467  ef             768    768       RST   RST5             ;LOAD INDEX
0468  e1             769    769       POP   HL               ;GET HL (TBL)
0469  e5             770    770       PUSH  HL               ;RESAVE
046a  cd d2 06       771    771       CALL  FADD             ;ADD STEP VALUE
046d  21 3a 10       772    772       LD    HL,TVAR1         ;POINT NEW INDEX
0470  f7             773    773       RST   RST6             ;STORE IT
0471  e1             774    774       POP   HL               ;GET HL (TBL)
0472  e5             775    775       PUSH  HL               ;RESAVE
0473  ff             776    776       RST   RST7             ;GO BUMP HL
0474  04             777    777       DEFB  4                ;BY FOUR
0475  cd cb 07       778    778       CALL  FSUB             ;SUBTRACT TO VALUE
0478  cd 9e 09       779    779       CALL  FTEST            ;GET SIGN OF DIFFERENCE
047b  ca 93 04       780    780       JP    Z,NXTZR          ;BRIF ZERO
047e  e1             781    781       POP   HL               ;GET HL (PTR TO STEP)
047f  e5             782    782       PUSH  HL               ;RE-SAVE
0480  7e             783    783       LD    A,(HL)           ;GET SIGN & EXPONENT OF STEP
0481  b7             784    784       OR    A                ;TEST IT
0482  3a 2a 10       785    785       LD    A,(FACC)         ;GET SIGN & EXPONENT OF DIFFERENCE
0485  fa 8f 04       786    786       JP    M,NXTNE          ;BRIF NEGATIVE
0488  b7             787    787 NXTPO OR    A                ;TEST IT
0489  fa 93 04       788    788       JP    M,NXTZR          ;BRIF LESS THAN TO-EXPR
048c  c3 ab 04       789    789       JP    NEXTZ            ;GO PAST NEXT
048f  b7             790    790 NXTNE OR    A                ;TEST IT
0490  fa ab 04       791    791       JP    M,NEXTZ          ;BRIF END OF LOOP
0493  e1             792    792 NXTZR POP   HL               ;POP THE STACK
0494  ff             793    793       RST   RST7             ;GO BUMP HL
0495  08             794    794       DEFB  8                ;BY EIGHT
0496  56             795    795       LD    D,(HL)           ;GET HI BYTE
0497  23             796    796       INC   HL               ;POINT NEXT
0498  5e             797    797       LD    E,(HL)           ;GET LOW BYTE
0499  eb             798    798       EX    DE,HL            ;PUT TO HL
049a  22 5d 10       799    799       LD    (STMT),HL        ;SAVE ADDR OF FOR
049d  11 3a 10       800    800       LD    DE,TVAR1         ;POINT UPDATED INDEX VALUE
04a0  2a 57 10       801    801       LD    HL,(ADDR1)       ;GET ADDR
04a3  06 04          802    802       LD    B,4              ;LENGTH
04a5  cd 60 0e       803    803       CALL  COPYD            ;GO MOVE TO I
04a8  c3 86 01       804    804       JP    RUN              ;CONTINUE STMT AFTER FOR
04ab  =              805    805 NEXTZ EQU   $
04ab  21 6e 10       806    806       LD    HL,FORNE         ;GET ADDR TABLE
04ae  35             807    807       DEC   (HL)             ;SUBTRACT ONE FROM COUNT
04af  c3 86 01       808    808       JP    RUN              ;GO STMT AFTER NEXT
                     809    809 *HEADING IMSAI 8080 4K BASIC
04b2  =              810    810 INPUT EQU   $
                     811    811 ;
                     812    812 ;
                     813    813 ; STMT:  INPUT VAR :, VAR, VAR:
                     814    814 ;
                     815    815 ;
04b2  11 02 10       816    816       LD    DE,IOBUF         ;GET ADDR OF BUFFER
04b5  eb             817    817       EX    DE,HL            ;FLIP/FLOP
04b6  22 57 10       818    818       LD    (ADDR1),HL       ;SAVE ADDR
04b9  36 00          819    819       LD    (HL),0           ;MARK BUFFER EMPTY
04bb  eb             820    820       EX    DE,HL            ;FLIP/BACK
04bc  cd 2f 0f       821    821 IN1   CALL  VAR              ;GO GET VAR NAME
04bf  cd fd 0e       822    822       CALL  SEARC            ;GO ;LOOK UP ADDRESS
04c2  e5             823    823       PUSH  HL               ;SAVE HL ADDR
04c3  d5             824    824       PUSH  DE               ;SAVE VAR ADDRE
04c4  2a 57 10       825    825       LD    HL,(ADDR1)       ;GET ADDR PREV BUFFER
04c7  7e             826    826       LD    A,(HL)           ;LOAD CHAR
04c8  fe 2c          827    827       CP    ','              ;TEST IF COMMA
04ca  23             828    828       INC   HL               ;POINT NEXT
04cb  ca d7 04       829    829       JP    Z,IN2            ;BRIF CONTINUE FROM PREV
04ce  b7             830    830       OR    A                ;TEST IF END OF LINE
04cf  c2 79 0e       831    831       JP    NZ,SNERR         ;BRIF ERROR
04d2  3e 3f          832    832       LD    A,'?'            ;PROMPT CHAR
04d4  cd 59 0d       833    833       CALL  TERMI            ;GO READ FROM TTY
04d7  cd 44 05       834    834 IN2   CALL  FIN              ;GO CONVERT TO FLOATING
04da  22 57 10       835    835       LD    (ADDR1),HL       ;SAVE ADDRESS
04dd  e1             836    836       POP   HL               ;GET VAR ADDRESS
04de  f7             837    837       RST   RST6             ;GO STORE THE NUMBER
04df  e1             838    838       POP   HL               ;RESTORE STMT POINTER
04e0  cf             839    839       RST   RST1             ;SKIP SPACES
04e1  fe 2c          840    840       CP    ','              ;TEST FOR COMMA
04e3  23             841    841       INC   HL               ;POINT NEXT
04e4  ca bc 04       842    842       JP    Z,IN1            ;RECURSIVE IF COMMA
04e7  2b             843    843       DEC   HL               ;POINT BACK
04e8  c3 86 01       844    844       JP    RUN              ;GO NEXT STMT
                     845    845 *HEADING IMSAI 8080 4K BASIC
04eb  =              846    846 READ  EQU   $
                     847    847 ;
                     848    848 ; STMT:  READ VAR :,VAR ...:
                     849    849 ;
04eb  cd 2f 0f       850    850       CALL  VAR              ;GO GET VAR NAME
04ee  cd fd 0e       851    851       CALL  SEARC            ;GO GET ADDRESS
04f1  e5             852    852       PUSH  HL               ;SAVE HL
04f2  d5             853    853       PUSH  DE               ;SAVE DE
04f3  2a 16 11       854    854       LD    HL,(DATAP)       ;GET DATA STMT POINTER
04f6  7e             855    855       LD    A,(HL)           ;LOAD THE CHAR
04f7  b7             856    856       OR    A                ;TEST IF END OF STMT
04f8  c2 1c 05       857    857       JP    NZ,NOTDT         ;BRIF NOT END OF STMT
04fb  23             858    858       INC   HL               ;POINT START NEXT STMT
04fc  7e             859    859 DATAN LD    A,(HL)           ;LOAD LEN
04fd  22 16 11       860    860       LD    (DATAP),HL       ;SAVE ADDR
0500  b7             861    861       OR    A                ;TEST IF END OF PGM
0501  ca 81 0e       862    862       JP    Z,DAERR          ;BRIF OUT OF DATA
0504  23             863    863       INC   HL               ;POINT NEXT
0505  22 68 10       864    864       LD    (DASTM),HL       ;SAVE ADDR OF LINE NUMBER
0508  23             865    865       INC   HL               ;SKIP LINE NUMBER
0509  23             866    866       INC   HL               ;POINT 1ST DATA BYTE
050a  cf             867    867       RST   RST1             ;SKIP BLANKS
050b  11 87 0f       868    868       LD    DE,DATAL         ;POINT 'DATA'
050e  d7             869    869       RST   RST2             ;COMPARE
050f  ca 1c 05       870    870       JP    Z,NOTDT          ;BRIF IT IS DATA STMT
0512  2a 16 11       871    871       LD    HL,(DATAP)       ;GET ADDR START
0515  5e             872    872       LD    E,(HL)           ;GET LEN CODE
0516  16 00          873    873       LD    D,0              ;CLEAR D
0518  19             874    874       ADD   HL,DE            ;POINT NEXT STMT
0519  c3 fc 04       875    875       JP    DATAN            ;LOOP NEXT STMT
051c  cd 44 05       876    876 NOTDT CALL  FIN              ;GO CONVERT VALUE
051f  7e             877    877       LD    A,(HL)           ;GET CHAR WHICH STOPPED US
0520  fe 2c          878    878       CP    ','              ;TEST IF COMMA
0522  c2 37 05       879    879       JP    NZ,NOTCO         ;BRIF NOT
0525  23             880    880       INC   HL               ;POINT NEXT
0526  22 16 11       881    881 DATOK LD    (DATAP),HL       ;SAVE ADDRESS
0529  e1             882    882       POP   HL               ;RESTORE ADDR OF VAR
052a  f7             883    883       RST   RST6             ;STORE THE VALUE
052b  e1             884    884       POP   HL               ;RESTORE POINTER TO STM
052c  7e             885    885       LD    A,(HL)           ;LOAD THE CHAR
052d  fe 2c          886    886       CP    ','              ;TEST IF COMMA
052f  23             887    887       INC   HL               ;POINT NEXT
0530  ca eb 04       888    888       JP    Z,READ           ;RECURSIVE IF IT IS
0533  2b             889    889       DEC   HL               ;RESET
0534  c3 86 01       890    890       JP    RUN              ;CONTINUE
0537  b7             891    891 NOTCO OR    A                ;TEST IF END OF STMT
0538  ca 26 05       892    892       JP    Z,DATOK          ;BRIF OK
053b  2a 68 10       893    893       LD    HL,(DASTM)       ;GET DATA STMT LINE NUMBER
053e  22 6a 10       894    894       LD    (LINE),HL        ;SAVE IN LINE NUMBER
0541  c3 79 0e       895    895       JP    SNERR            ;GO PROCESS ERROR
                     896    896 ;
                     897    897 *HEADING IMSAI 8080 4K BASIC
0544  =              898    898 FIN   EQU   $
                     899    899 ;
                     900    900 ;FLOATING POINT INPUT CONVERSION ROUTINE
                     901    901 ;
                     902    902 ;THIS SUBROUTINE CONVERTS AN ASCII STRING OF CHARACTERS TO
                     903    903 ;POINT ACCUMULATOR.  THE INPUT FIELD MAY CONTAIN ANY VALID
                     904    904 ;INCLUDING SCIENTIFIC (NNN.NNNNE+NN)
                     905    905 ;THE INPUT STRING IS TERMINATED BY ANY NON-NUMERIC CHARACT
                     906    906 ;
                     907    907 ;
0544  eb             908    908       EX    DE,HL            ;FLIP/FLOP DE HL
0545  21 2a 10       909    909       LD    HL,FACC          ;POINT TO FACC
0548  06 04          910    910       LD    B,4              ;LOOP CTR
054a  cd 4f 0e       911    911       CALL  ZEROM            ;GO CLEAR THE FACC
054d  ff             912    912       RST   RST7             ;GO BUMP HL
054e  fc             913    913       DEFB  -4               ;BY NEG FOUR
054f  48             914    914       LD    C,B              ;INIT DIGIT COUNTER
0550  1a             915    915       LD    A,(DE)           ;GET FIRST BYTE
0551  fe 2b          916    916       CP    '+'              ;TEST FOR PLUS SIGN
0553  ca 5d 05       917    917       JP    Z,FIN2           ;BRIF IS
0556  fe 2d          918    918       CP    '-'              ;TEST FOR MINUS SIGN
0558  c2 5f 05       919    919       JP    NZ,FIN3          ;BRIF NOT
055b  36 80          920    920       LD    (HL),80H         ;SET MINUS MANTISSA
055d  13             921    921 FIN2  INC   DE               ;POINT NEXT DIGIT
055e  1a             922    922       LD    A,(DE)           ;GET THE BYTE
055f  fe 30          923    923 FIN3  CP    '0'              ;TEST FOR LEADING ZERO
0561  ca 5d 05       924    924       JP    Z,FIN2           ;BRIF IT IS
0564  fe 3a          925    925 FIN4  CP    '9'+1            ;TEST FOR NINE
0566  d2 bc 05       926    926       JP    NC,FIN14         ;BRIF NOT NUMERIC
0569  fe 30          927    927       CP    '0'              ;TEST FOR ZERO
056b  da 77 05       928    928       JP    C,FIN5           ;BRIF NOT NUMERIC
056e  04             929    929       INC   B                ;COUNT EXPONENT
056f  cd 9e 05       930    930       CALL  FIN9             ;STORE THE DIGIT
0572  13             931    931       INC   DE               ;POINT NEXT
0573  1a             932    932       LD    A,(DE)           ;GET THE DIGIT
0574  c3 64 05       933    933       JP    FIN4             ;LOOP
0577  fe 2e          934    934 FIN5  CP    '.'              ;TEST FOR DOT
0579  c2 f7 05       935    935       JP    NZ,FIN19         ;BRIF NOT
057c  79             936    936       LD    A,C              ;GET DIGIT COUNT
057d  b7             937    937       OR    A                ;TEST FOR ZERO
057e  c2 8c 05       938    938       JP    NZ,FIN7          ;BRIF NOT
0581  13             939    939 FIN6  INC   DE               ;POINT NEXT
0582  1a             940    940       LD    A,(DE)           ;GET DIGIT
0583  fe 30          941    941       CP    '0'              ;TEST FOR ZERO
0585  c2 8e 05       942    942       JP    NZ,FIN8          ;BRIF NOT
0588  05             943    943       DEC   B                ;COUNT IT
0589  c3 81 05       944    944       JP    FIN6             ;LOOP
058c  13             945    945 FIN7  INC   DE               ;POINT NEXT
058d  1a             946    946       LD    A,(DE)           ;GET THE DIGIT
058e  fe 30          947    947 FIN8  CP    '0'              ;TEST FOR ZERO
0590  da f7 05       948    948       JP    C,FIN19          ;BRIF LOWER
0593  fe 3a          949    949       CP    '9'+1            ;TEST FOR NINE
0595  d2 bc 05       950    950       JP    NC,FIN14         ;BRIF HIGH
0598  cd 9e 05       951    951       CALL  FIN9             ;GO STORE DIGIT
059b  c3 8c 05       952    952       JP    FIN7             ;LOOP
059e  79             953    953 FIN9  LD    A,C              ;GET DIGIT COUNT
059f  fe 06          954    954       CP    6                ;TEST FOR MAX
05a1  c8             955    955       RET   Z                ;RETURN IF EQUAL
05a2  3c             956    956       INC   A                ;ADD ONE
05a3  4f             957    957       LD    C,A              ;REPLACE PREV COUNT
05a4  3c             958    958       INC   A                ;PLUS ONE
05a5  1f             959    959       RRA                    ;DIVIDE BY TWO
05a6  e6 0f          960    960       AND   0FH              ;MASK OFF UNUSED BITS
05a8  85             961    961       ADD   A,L              ;PLUS LOW BYTE OF H
05a9  6f             962    962       LD    L,A              ;REPLACE LOW BYTE OF HL
05aa  79             963    963       LD    A,C              ;RE-LOAD DIGIT COUNT
05ab  1f             964    964       RRA                    ;TEST EVEN/ODD
05ac  1a             965    965       LD    A,(DE)           ;GET THE DIGIT
05ad  da b6 05       966    966       JP    C,FIN12          ;BRIF ODD DIGIT
05b0  e6 0f          967    967       AND   0FH              ;LOW 4 BITS ONLY
05b2  b6             968    968       OR    (HL)             ;GET HIGH 4 BITS
05b3  c3 b7 05       969    969       JP    FIN13            ;GO RETURN
05b6  e7             970    970 FIN12 RST   RST4             ;SHIFT LEFT
05b7  77             971    971 FIN13 LD    (HL),A           ;REPLACE
05b8  21 2a 10       972    972       LD    HL,FACC          ;POINT TO FACC
05bb  c9             973    973       RET                    ;RETURN
05bc  fe 45          974    974 FIN14 CP    'E'              ;TEST FOR EXPLICIT EXPONENT
05be  c2 f7 05       975    975       JP    NZ,FIN19         ;BRIF NOT EQUAL
05c1  13             976    976       INC   DE               ;POINT NEXT
05c2  1a             977    977       LD    A,(DE)           ;GET DIGIT
05c3  0e 00          978    978       LD    C,0              ;CLEAR COUNTER
05c5  fe 2b          979    979       CP    '+'              ;TEST FOR PLUS
05c7  ca f0 05       980    980       JP    Z,FIN17          ;BRIF EQUAL
05ca  fe 2d          981    981       CP    '-'              ;TEST FOR MINUS
05cc  c2 ef 05       982    982       JP    NZ,FIN16         ;BRIF NOT EQUAL
05cf  cd d8 05       983    983       CALL  FIN15            ;GET NUMERIC EXPONENT
05d2  79             984    984       LD    A,C              ;LOAD THE NUMBER
05d3  2f             985    985       CPL                    ;COMPLEMENT
05d4  3c             986    986       INC   A                ;PLUS ONE (TWOS COMPLEMENT)
05d5  c3 f4 05       987    987       JP    FIN18            ;CONTINUE
05d8  13             988    988 FIN15 INC   DE               ;POINT NEXT
05d9  1a             989    989       LD    A,(DE)           ;GET DIGIT
05da  fe 30          990    990       CP    '0'              ;TEST ZERO
05dc  d8             991    991       RET   C                ;RETURN IF ERROR
05dd  fe 3a          992    992       CP    '9'+1            ;TEST NINE
05df  d0             993    993       RET   NC               ;RETURN IF NOT NUMERIC
05e0  79             994    994       LD    A,C              ;GET PRIOR
05e1  87             995    995       ADD   A,A              ;TIMES TWO
05e2  4f             996    996       LD    C,A              ;SAVE
05e3  87             997    997       ADD   A,A              ;TIMES FOUR
05e4  87             998    998       ADD   A,A              ;TIMES EIGHT
05e5  81             999    999       ADD   A,C              ;TIMES TEN
05e6  4f            1000   1000       LD    C,A              ;SAVE
05e7  1a            1001   1001       LD    A,(DE)           ;GET THIS DIGIT
05e8  e6 0f         1002   1002       AND   0FH              ;MASK OFF HIGH FOUR BITS
05ea  81            1003   1003       ADD   A,C              ;PLUS PREV*10
05eb  4f            1004   1004       LD    C,A              ;SAVE
05ec  c3 d8 05      1005   1005       JP    FIN15            ;LOOP
05ef  1b            1006   1006 FIN16 DEC   DE               ;POINT PRIOR TEMP
05f0  cd d8 05      1007   1007 FIN17 CALL  FIN15            ;GO GET NUMERIC EXPONENT
05f3  79            1008   1008       LD    A,C              ;LOAD THE EXPONENT
05f4  80            1009   1009 FIN18 ADD   A,B              ;PLUS COMPUTED EXPONENT
05f5  47            1010   1010       LD    B,A              ;SAVE IT
05f6  1a            1011   1011       LD    A,(DE)           ;GET LAST CHAR
05f7  23            1012   1012 FIN19 INC   HL               ;POINT 1ST DIGIT
05f8  7e            1013   1013       LD    A,(HL)           ;LOAD
05f9  b7            1014   1014       OR    A                ;TEST IF ZERO
05fa  ca 05 06      1015   1015       JP    Z,FIN20          ;BRIF ZERO
05fd  2b            1016   1016       DEC   HL               ;POINT EXPONENT
05fe  05            1017   1017       DEC   B                ;SUB ONE FROM EXPONENT
05ff  78            1018   1018       LD    A,B              ;GET EXPONENT
0600  e6 7f         1019   1019       AND   7FH              ;TURN OFF HIGH BIT
0602  b6            1020   1020       OR    (HL)             ;OR IN MANTISSA SIGN
0603  77            1021   1021       LD    (HL),A           ;STORE IN FACC
0604  af            1022   1022       XOR   A                ;TURN CY OFF, CLEAR ACC
0605  eb            1023   1023 FIN20 EX    DE,HL            ;FLIP/FLOP
0606  c9            1024   1024       RET                    ;RETURN
                    1025   1025 *HEADING IMSAI 8080 4K BASIC
0607  =             1026   1026 FOUT  EQU   $
                    1027   1027 ;
                    1028   1028 ;FLOATING POINT OUTPUT FORMAT ROUTINE
                    1029   1029 ;
                    1030   1030 ;THIS SUBROUTINE CONVERTS A NUMBER IN THE FLOATING POINT AC
                    1031   1031 ;TO A FORMAT SUITABLE FOR PRINTING. THAT IS, THE NUMBER WIL
                    1032   1032 ;SCIENTIFIC NOTATION (+N.NNNNNE+NN) IF THE EXPONENT IS > 5
                    1033   1033 ;OTHERWISE IT WILL BE ZERO SUPPRESSED BOTH ON THE LEFT OF T
                    1034   1034 ;PORTION AND ON THE RIGHT OF THE FRACTION.
                    1035   1035 ;
0607  11 2a 10      1036   1036       LD    DE,FACC          ;POINT TO FLOATING POINT ACCUMULATOR
060a  1a            1037   1037       LD    A,(DE)           ;GET EXPONENT BYTE
060b  4f            1038   1038       LD    C,A              ;SAVE IT
060c  17            1039   1039       RLA                    ;SHIFT (TEST MANTISSA SIGN)
060d  36 20         1040   1040       LD    (HL),' '         ;DEFAULT POSITIVE
060f  d2 14 06      1041   1041       JP    NC,FOUT1         ;BRIF POSITIVE
0612  36 2d         1042   1042       LD    (HL),'-'         ;MOVE DASH
0614  13            1043   1043 FOUT1 INC   DE               ;POINT TO FIRST & SECOND DIGITS
0615  23            1044   1044       INC   HL               ;AND NEXT OUTPUT POSITION
0616  1a            1045   1045       LD    A,(DE)           ;PUT TO ACC
0617  cd f6 0e      1046   1046       CALL  RIGHT            ;SHIFT RIGHT
061a  f6 30         1047   1047       OR    '0'              ;DECIMAL ZONE
061c  77            1048   1048       LD    (HL),A           ;PUT OUT
061d  23            1049   1049       INC   HL               ;POINT NEXT OUT
061e  36 2e         1050   1050       LD    (HL),'.'         ;MOVE DECIMAL POINT
0620  06 03         1051   1051       LD    B,3              ;INIT LOOP COUNTER
0622  c3 2e 06      1052   1052       JP    FOUT3            ;JUMP INTO MIDDLE OF LOOP
0625  23            1053   1053 FOUT2 INC   HL               ;POINT NEXT OUT
0626  13            1054   1054       INC   DE               ;NEXT 2 DIGITS
0627  1a            1055   1055       LD    A,(DE)           ;GET HIGH & LOW
0628  cd f6 0e      1056   1056       CALL  RIGHT            ;SHIFT RIGHT
062b  f6 30         1057   1057       OR    '0'              ;DECIMAL ZONE
062d  77            1058   1058       LD    (HL),A           ;PUT TO OUTPUT
062e  23            1059   1059 FOUT3 INC   HL               ;POINT NEXT OUTPUT
062f  1a            1060   1060       LD    A,(DE)           ;GET DIGITS AGAIN
0630  e6 0f         1061   1061       AND   0FH              ;MASK OFF HIGH
0632  f6 30         1062   1062       OR    '0'              ;DECIMAL ZONE
0634  77            1063   1063       LD    (HL),A           ;PUT TO OUTPUT
0635  05            1064   1064       DEC   B                ;TEST LOOP COUNTER
0636  c2 25 06      1065   1065       JP    NZ,FOUT2         ;BRIF MORE
0639  23            1066   1066       INC   HL               ;POINT NEXT OUTPUT
063a  36 45         1067   1067       LD    (HL),'E'         ;MOVE LIT E
063c  23            1068   1068       INC   HL               ;POINT NEXT
063d  79            1069   1069       LD    A,C              ;GET EXPONENT BYTE
063e  e6 3f         1070   1070       AND   3FH              ;MASK OFF SIGNS
0640  47            1071   1071       LD    B,A              ;SAVE IN B
0641  79            1072   1072       LD    A,C              ;GET EXPONENT BYTE
0642  17            1073   1073       RLA                    ;IGNORE MANTISSA SIGN
0643  17            1074   1074       RLA                    ;TEST EXPONENT SIGN
0644  36 2b         1075   1075       LD    (HL),'+'         ;DEFAULT POSITIVE
0646  d2 51 06      1076   1076       JP    NC,FOUT4         ;BRIF POSITIVE
0649  36 2d         1077   1077       LD    (HL),'-'         ;ELSE MOVE DASH
064b  79            1078   1078       LD    A,C              ;RELOAD EXPONENT BYTE
064c  f6 c0         1079   1079       OR    0C0H             ;SET ALL ON
064e  2f            1080   1080       CPL                    ;COMPLEMENT ACC
064f  3c            1081   1081       INC   A                ;PLUS 1 (TWOS COMPLEMENT)
0650  47            1082   1082       LD    B,A              ;SAVE IN B
0651  23            1083   1083 FOUT4 INC   HL               ;POINT NEXT OUT
0652  78            1084   1084       LD    A,B              ;GET EXPONENT
0653  06 2f         1085   1085       LD    B,2FH            ;INIT COUNTER
0655  d6 0a         1086   1086 FOUT5 SUB   10               ;SUBTRACT 10
0657  04            1087   1087       INC   B                ;COUNT 1
0658  d2 55 06      1088   1088       JP    NC,FOUT5         ;BRIF NOT NEG
065b  70            1089   1089       LD    (HL),B           ;POINT TO OUTPUT
065c  23            1090   1090       INC   HL               ;POINT NEXT
065d  c6 3a         1091   1091       ADD   A,58             ;ADJUST
065f  77            1092   1092       LD    (HL),A           ;MOVE 2ND DIGIT
0660  79            1093   1093       LD    A,C              ;GET EXPONENT
0661  17            1094   1094       RLA                    ;SHIFT OFF MANTISSA SIGN
0662  b7            1095   1095       OR    A                ;TEST
0663  f2 6e 06      1096   1096       JP    P,FOUT6          ;BRIF POSITIVE
0666  37            1097   1097       SCF                    ;SET CY
0667  1f            1098   1098       RRA                    ;SHIFT BACK
0668  fe fe         1099   1099       CP    -2               ;TEST FOR MIN
066a  d8            1100   1100       RET   C                ;RETURN IF LESS THAN -2
066b  c3 72 06      1101   1101       JP    FOUT7            ;GO AROUND
066e  1f            1102   1102 FOUT6 RRA                    ;SHIFT BACK
066f  fe 06         1103   1103       CP    6                ;TEST IF TOO BIG
0671  d0            1104   1104       RET   NC               ;RETURN IF 6 OR GREATER
0672  4f            1105   1105 FOUT7 LD    C,A              ;SAVE EXPONENT
0673  06 04         1106   1106       LD    B,4              ;CTR
0675  36 20         1107   1107 FOUT8 LD    (HL),' '         ;SPACE OUT EXPONENT
0677  2b            1108   1108       DEC   HL               ;POINT PRIOR
0678  05            1109   1109       DEC   B                ;DECR CTR
0679  c2 75 06      1110   1110       JP    NZ,FOUT8         ;LOOP
067c  eb            1111   1111       EX    DE,HL            ;FLIP/FLOP
067d  7b            1112   1112       LD    A,E              ;GET LOW BYTE
067e  d6 05         1113   1113       SUB   5                ;POINT TO DOT
0680  6f            1114   1114       LD    L,A              ;PUT DOWN
0681  7a            1115   1115       LD    A,D              ;GET HIGH
0682  de 00         1116   1116       SBC   A,0              ;IN CASE OF BORROW
0684  67            1117   1117       LD    H,A              ;PUT DOWN
0685  79            1118   1118       LD    A,C              ;GET EXPONENT
0686  b7            1119   1119       OR    A                ;TEST SIGN
0687  ca 98 06      1120   1120       JP    Z,FOX1           ;BRIF ZERO
068a  fa ac 06      1121   1121       JP    M,FOX2           ;BRIF NEGATIVE
068d  46            1122   1122 FOUT9 LD    B,(HL)           ;GET HIGH BYTE
068e  23            1123   1123       INC   HL               ;POINT NEXT
068f  7e            1124   1124       LD    A,(HL)           ;GET LOW BYTE
0690  70            1125   1125       LD    (HL),B           ;SHIFT DOT TO RIGHT
0691  2b            1126   1126       DEC   HL               ;POINT BACK
0692  77            1127   1127       LD    (HL),A           ;MOVE THE DIGIT LEFT
0693  23            1128   1128       INC   HL               ;POINT NEXT
0694  0d            1129   1129       DEC   C                ;DECR CTR
0695  c2 8d 06      1130   1130       JP    NZ,FOUT9         ;LOOP
0698  eb            1131   1131 FOX1  EX    DE,HL            ;POINT END
0699  7e            1132   1132 FOX3  LD    A,(HL)           ;GET A DIGIT/DOT
069a  fe 30         1133   1133       CP    '0'              ;TEST FOR A TRAILING ZERO
069c  c2 a5 06      1134   1134       JP    NZ,FOX4          ;BRIF NOT
069f  36 20         1135   1135       LD    (HL),' '         ;SPACE FILL
06a1  2b            1136   1136       DEC   HL               ;POINT PRIOR
06a2  c3 99 06      1137   1137       JP    FOX3             ;LOOP
06a5  fe 2e         1138   1138 FOX4  CP    '.'              ;TEST FOR TRAILING DOT
06a7  c0            1139   1139       RET   NZ               ;RETURN IF NOT
06a8  36 20         1140   1140       LD    (HL),' '         ;SPACE IT OUT
06aa  2b            1141   1141       DEC   HL               ;POINT PRIOR
06ab  c9            1142   1142       RET                    ;RETURN
06ac  fe ff         1143   1143 FOX2  CP    0FFH             ;TEST IF -1
06ae  c2 ba 06      1144   1144       JP    NZ,FOX5          ;ELSE -2
06b1  2b            1145   1145       DEC   HL               ;POINT SIGNIFICANT
06b2  7e            1146   1146       LD    A,(HL)           ;GET THE CHAR
06b3  36 2e         1147   1147       LD    (HL),'.'         ;MOVE THE DOT
06b5  23            1148   1148       INC   HL               ;POINT NEXT
06b6  77            1149   1149       LD    (HL),A           ;SHIFT THE DIGIT
06b7  c3 98 06      1150   1150       JP    FOX1             ;GO ZERO SUPPRESS
06ba  2b            1151   1151 FOX5  DEC   HL               ;POINT ONE TO LEFT
06bb  7e            1152   1152       LD    A,(HL)           ;PICK UP DIGIT
06bc  36 30         1153   1153       LD    (HL),'0'         ;REPLACE
06be  23            1154   1154       INC   HL               ;POINT RIGHT
06bf  77            1155   1155       LD    (HL),A           ;PUT THE DIGIT
06c0  62            1156   1156       LD    H,D              ;GET LOW ADDR
06c1  6b            1157   1157       LD    L,E              ;POINT LAST DIGIT
06c2  06 06         1158   1158       LD    B,6              ;CTR
06c4  2b            1159   1159 FOX6  DEC   HL               ;POINT PRIOR
06c5  7e            1160   1160       LD    A,(HL)           ;GET A DIGIT
06c6  23            1161   1161       INC   HL               ;POINT
06c7  77            1162   1162       LD    (HL),A           ;PUT IT ONE TO RIGHT
06c8  2b            1163   1163       DEC   HL               ;POINT
06c9  05            1164   1164       DEC   B                ;DECR CTR
06ca  c2 c4 06      1165   1165       JP    NZ,FOX6          ;LOOP
06cd  36 2e         1166   1166       LD    (HL),'.'         ;MOVE THE DOT
06cf  c3 98 06      1167   1167       JP    FOX1             ;CONTINUE
                    1168   1168 *HEADING IMSAI 8080 4K BASIC
06d2  =             1169   1169 FADD  EQU   $
                    1170   1170 ;
                    1171   1171 ;
                    1172   1172 ;FLOATING POINT ADD THE NUMBER AT (HL) TO THE FACC
                    1173   1173 ;
                    1174   1174 ;
06d2  23            1175   1175       INC   HL               ;POINT FIRST DIGIT
06d3  7e            1176   1176       LD    A,(HL)           ;LOAD IT
06d4  b7            1177   1177       OR    A                ;TEST IT
06d5  c8            1178   1178       RET   Z                ;RETURN IF ZERO
06d6  2b            1179   1179       DEC   HL               ;POINT BACK
06d7  cd 9e 09      1180   1180       CALL  FTEST            ;GO TEST SIGN OF FACC
06da  ca 28 00      1181   1181       JP    Z,RST5           ;JUST LOAD IF FACC = 0
06dd  11 2a 10      1182   1182       LD    DE,FACC          ;POINT FACC
06e0  1a            1183   1183       LD    A,(DE)           ;GET EXPONENT OF FACC
06e1  cd ac 09      1184   1184       CALL  FEXP             ;GO GET EXPONENT
06e4  47            1185   1185       LD    B,A              ;SAVE EXPONENT
06e5  7e            1186   1186       LD    A,(HL)           ;GET EXPONENT OF ADDR
06e6  cd ac 09      1187   1187       CALL  FEXP             ;GO GET EXPONENT
06e9  4f            1188   1188       LD    C,A              ;SAVE THE EXPONENT
06ea  90            1189   1189       SUB   B                ;GET DIFFERENCE OF TWO EXPONENTS
06eb  ca fe 06      1190   1190       JP    Z,FADD4          ;BRIF THEY'RE EQUAL
06ee  f2 f3 06      1191   1191       JP    P,FADD3          ;BRIF DIFFERENCE IS POSITIVE
06f1  2f            1192   1192       CPL                    ;COMPLEMENT ACC
06f2  3c            1193   1193       INC   A                ;PLUS ONE (TWO'S COMPLEMENT)
06f3  fe 06         1194   1194 FADD3 CP    6                ;COMPARE DIFFERENCE TO SIX
06f5  da fe 06      1195   1195       JP    C,FADD4          ;BRIF 5 OR LESS
06f8  78            1196   1196       LD    A,B              ;GET EXPON OF ADDUEND
06f9  91            1197   1197       SUB   C                ;GET TRUE DIFFERENCE AGAIN
06fa  f0            1198   1198       RET   P                ;RETURN IF FACC > ADDER
06fb  c3 28 00      1199   1199       JP    RST5             ;ELSE, ADDER > FACC
06fe  f5            1200   1200 FADD4 PUSH  AF               ;SAVE DIFFERENCE
06ff  c5            1201   1201       PUSH  BC               ;SAVE EXPONENTS
0700  11 2e 10      1202   1202       LD    DE,FTEMP         ;GET ADDR OF TEMP ACC
0703  06 04         1203   1203       LD    B,4              ;FOUR BYTES
0705  cd 57 0e      1204   1204       CALL  COPYH            ;GO COPY
0708  c1            1205   1205       POP   BC               ;GET EXPONENTS
0709  f1            1206   1206       POP   AF               ;GET DIFFERENCE
070a  ca 32 07      1207   1207       JP    Z,FADD9          ;JUST ADD IF ZERO
070d  21 2f 10      1208   1208       LD    HL,FTEMP+1       ;DEFAULT
0710  f5            1209   1209       PUSH  AF               ;SAVE DIFFERENCE
0711  78            1210   1210       LD    A,B              ;GET FACC EXPON
0712  91            1211   1211       SUB   C                ;MINUS FTEMP EXPON
0713  f2 23 07      1212   1212       JP    P,FADD6          ;BRIF TEMP MUST BE SHIFTED
0716  21 2a 10      1213   1213       LD    HL,FACC          ;POINT FLOAT ACC
0719  79            1214   1214       LD    A,C              ;GET EXPONENT, SIGN
071a  e6 7f         1215   1215       AND   7FH              ;STRIP EXP SIGN
071c  4f            1216   1216       LD    C,A              ;PUT BACK
071d  7e            1217   1217       LD    A,(HL)           ;GET THE EXP
071e  e6 80         1218   1218       AND   80H              ;STRIP OFF OLD EXPON
0720  b1            1219   1219       OR    C                ;MOVE ADDER EXPON TO IT
0721  77            1220   1220       LD    (HL),A           ;REPLACE
0722  23            1221   1221       INC   HL               ;POINT FIRST DATA BYTE
0723  f1            1222   1222 FADD6 POP   AF               ;GET DIFFER
0724  4f            1223   1223       LD    C,A              ;SAVE IT
0725  06 03         1224   1224 FADD7 LD    B,3              ;LOOP CTR (INNER)
0727  16 00         1225   1225       LD    D,0              ;INIT CARRY OVER TO ZERO
0729  e5            1226   1226       PUSH  HL               ;SAVE ADDR
072a  cd e4 09      1227   1227       CALL  FSHFT            ;GO SHIFT
072d  e1            1228   1228       POP   HL               ;GET ADDR
072e  0d            1229   1229       DEC   C                ;DECR CTR
072f  c2 25 07      1230   1230       JP    NZ,FADD7         ;LOOP
0732  =             1231   1231 FADD9 EQU   $
0732  11 2a 10      1232   1232       LD    DE,FACC          ;POINT SIGN OF ADDUEND
0735  21 2e 10      1233   1233       LD    HL,FTEMP         ;AND SIGN OF ADDER
0738  1a            1234   1234       LD    A,(DE)           ;GET SIGN OF ADDUEND
0739  ae            1235   1235       XOR   (HL)             ;COMPARE THE TWO SIGNS
073a  fa 62 07      1236   1236       JP    M,FADD1          ;BRIF SIGNS DIFFER
073d  11 2d 10      1237   1237       LD    DE,FACC+3        ;POINT LOW END
0740  21 31 10      1238   1238       LD    HL,FTEMP+3       ;DITTO
0743  06 03         1239   1239       LD    B,3              ;THREE BYTES
0745  cd d8 09      1240   1240       CALL  FADDT            ;GO ADD TWO TOGETHER
0748  d0            1241   1241       RET   NC               ;RETURN IF NO CARRY
0749  21 2a 10      1242   1242 FADX1 LD    HL,FACC          ;GET ADDR OF ACC
074c  7e            1243   1243       LD    A,(HL)           ;LOAD THE EXPON
074d  e6 80         1244   1244       AND   80H              ;ISOLATE SIGN
074f  47            1245   1245       LD    B,A              ;SAVE SIGN
0750  7e            1246   1246       LD    A,(HL)           ;GET EXPON
0751  cd ac 09      1247   1247       CALL  FEXP             ;GO GET EXPONENT
0754  3c            1248   1248       INC   A                ;ADD ONE
0755  e6 7f         1249   1249       AND   7FH              ;ISOLATE
0757  b0            1250   1250       OR    B                ;PUT BACK SIGN
0758  77            1251   1251       LD    (HL),A           ;PUT IT DOWN
0759  23            1252   1252       INC   HL               ;POINT DATA
075a  16 10         1253   1253       LD    D,10H            ;(THE CARRY)
075c  06 03         1254   1254       LD    B,3              ;CTR
075e  cd e4 09      1255   1255       CALL  FSHFT            ;GO SHIFT IT
0761  c9            1256   1256       RET                    ;RETURN
0762  =             1257   1257 FADD1 EQU   $
0762  21 32 10      1258   1258       LD    HL,FTEMP+4       ;POINT TEMP2 AREA
0765  06 04         1259   1259       LD    B,4              ;PREPARE TO SAVE ACC
0767  cd 60 0e      1260   1260       CALL  COPYD            ;GO COPY
076a  11 2d 10      1261   1261 FADX2 LD    DE,FACC+3        ;POINT LOW ACC
076d  21 31 10      1262   1262       LD    HL,FTEMP+3          ;AND LOW TEMP
0770  06 03         1263   1263       LD    B,3              ;CTR
0772  cd b4 09      1264   1264       CALL  FSUBT            ;GO SUBTRACT THE TWO
0775  d2 90 07      1265   1265       JP    NC,FNORM         ;BRIF NO BORROW
0778  11 2a 10      1266   1266       LD    DE,FACC          ;POINT ACC
077b  21 2e 10      1267   1267       LD    HL,FTEMP         ;POINT TEMP
077e  06 08         1268   1268       LD    B,8              ;CTR
0780  cd 57 0e      1269   1269       CALL  COPYH            ;GO COPY
0783  11 2a 10      1270   1270       LD    DE,FACC          ;POINT
0786  21 2e 10      1271   1271       LD    HL,FTEMP         ;TEMP
0789  7e            1272   1272       LD    A,(HL)           ;GET ORIG ACC EXPONENT
078a  ee 80         1273   1273       XOR   80H              ;REVERSE SIGN
078c  12            1274   1274       LD    (DE),A           ;PUT TO NEW ACC
078d  c3 6a 07      1275   1275       JP    FADX2            ;GO SUBTRACT AGAIN
                    1276   1276 *HEADING IMSAI 8080 4K BASIC
0790  =             1277   1277 FNORM EQU   $
                    1278   1278 ;
                    1279   1279 ;
                    1280   1280 ;NORMALIZE THE FLOATING ACCUMULATOR
                    1281   1281 ;THAT IS, THE FIRST DIGIT MUST BE SIGNIFICANT
                    1282   1282 ;
                    1283   1283 ;
0790  21 2b 10      1284   1284       LD    HL,FACC+1        ;POINT TO FIRST BYTE
0793  7e            1285   1285       LD    A,(HL)           ;LOAD IT
0794  e6 f0         1286   1286       AND   0F0H             ;ISOLATE
0796  c0            1287   1287       RET   NZ               ;RETURN IF ALREADY NORMALIZED
0797  7e            1288   1288       LD    A,(HL)           ;GET THE BYTE
0798  23            1289   1289       INC   HL               ;POINT NEXT
0799  b6            1290   1290       OR    (HL)             ;OR THE NEXT BYTE
079a  23            1291   1291       INC   HL               ;POINT LAST
079b  b6            1292   1292       OR    (HL)             ;OR THAT BYTE (ACC HAS LOGICAL S
079c  c2 a5 07      1293   1293       JP    NZ,FNOR1         ;BRIF NOT ZERO
079f  21 2a 10      1294   1294       LD    HL,FACC          ;ELSE POINT FLOAT ACC
07a2  36 00         1295   1295       LD    (HL),0           ;CLEAR THE EXPONENT
07a4  c9            1296   1296       RET                    ;RETURN
07a5  21 2d 10      1297   1297 FNOR1 LD    HL,FACC+3        ;POINT LST BYTE
07a8  06 03         1298   1298       LD    B,3              ;3 BYTE LOOP
07aa  16 00         1299   1299       LD    D,0              ;INIT CARRY OVER
07ac  7e            1300   1300 FNOR2 LD    A,(HL)           ;GET A BYTE
07ad  4f            1301   1301       LD    C,A              ;SAVE IT
07ae  e7            1302   1302       RST   RST4             ;SHIFT LEFT 4 BITS
07af  b2            1303   1303       OR    D                ;PLUS PREV SHIFT OUT
07b0  77            1304   1304       LD    (HL),A           ;PUT BACK
07b1  79            1305   1305       LD    A,C              ;GET SAVED BYTE
07b2  cd f6 0e      1306   1306       CALL  RIGHT            ;SHIFT RIGHT 4 BITS
07b5  57            1307   1307       LD    D,A              ;SAVE FOR NEXT TIME
07b6  2b            1308   1308       DEC   HL               ;POINT NEXT BYTE
07b7  05            1309   1309       DEC   B                ;DECR CTR
07b8  c2 ac 07      1310   1310       JP    NZ,FNOR2         ;LOOP
07bb  7e            1311   1311       LD    A,(HL)           ;GET EXPONENT
07bc  e6 80         1312   1312       AND   80H              ;ISOLATE SIGN
07be  47            1313   1313       LD    B,A              ;SAVE
07bf  7e            1314   1314       LD    A,(HL)           ;GET AGAIN
07c0  cd ac 09      1315   1315       CALL  FEXP             ;GO GET EXPONENT
07c3  3d            1316   1316       DEC   A                ;MINUS ONE
07c4  e6 7f         1317   1317       AND   7FH              ;TURN OFF HIGH BIT
07c6  b0            1318   1318       OR    B                ;PLUS SAVED SIGN
07c7  77            1319   1319       LD    (HL),A           ;PUT BACK
07c8  c3 90 07      1320   1320       JP    FNORM            ;GO NORMALIZE
                    1321   1321 *HEADING IMSAI 8080 4K BASIC
07cb  =             1322   1322 FSUB  EQU   $
                    1323   1323 ;
                    1324   1324 ;
                    1325   1325 ;FLOATING POINT SUBTRACT THE NUMBER AT (HL) FROM THE FACC
                    1326   1326 ;
                    1327   1327 ;
07cb  23            1328   1328       INC   HL               ;POINT FIRST DATA BYTE OF SUBTRA
07cc  7e            1329   1329       LD    A,(HL)           ;LOAD IT
07cd  b7            1330   1330       OR    A                ;TEST
07ce  c8            1331   1331       RET   Z                ;RETURN IF ZERO
07cf  2b            1332   1332       DEC   HL               ;POINT BACK
07d0  11 2e 10      1333   1333       LD    DE,FTEMP         ;GET TEMPORARY STORAGE AREA
07d3  06 04         1334   1334       LD    B,4              ;FOUR BYTES
07d5  cd 57 0e      1335   1335       CALL  COPYH            ;GO COPY
07d8  21 2e 10      1336   1336       LD    HL,FTEMP         ;POINT NEW AREA
07db  7e            1337   1337       LD    A,(HL)           ;GET EXPONENT
07dc  ee 80         1338   1338       XOR   80H              ;REVERSE SIGN
07de  77            1339   1339       LD    (HL),A           ;REPLACE
07df  c3 d2 06      1340   1340       JP    FADD             ;GO ADD THE TWO
                    1341   1341 *HEADING IMSAI 8080 4K BASIC
07e2  =             1342   1342 FMUL  EQU   $
                    1343   1343 ;
                    1344   1344 ;
                    1345   1345 ;FLOATING POINT MULTIPLY THE NUMBER AT (HL) TO THE FACC
                    1346   1346 ;
                    1347   1347 ;
07e2  cd 9e 09      1348   1348       CALL  FTEST            ;TEST FACC
07e5  c8            1349   1349       RET   Z                ;RETURN IF ZERO
07e6  23            1350   1350       INC   HL               ;POINT 1ST DIGIT OF MULTIPLIER
07e7  7e            1351   1351       LD    A,(HL)           ;LOAD IT
07e8  2b            1352   1352       DEC   HL               ;RESTORE
07e9  b7            1353   1353       OR    A                ;TEST IF ZERO
07ea  ca 28 00      1354   1354       JP    Z,RST5           ;GO LOAD TO FACC IF IT IS
07ed  11 2a 10      1355   1355       LD    DE,FACC          ;POINT EXP OF FACC
07f0  1a            1356   1356       LD    A,(DE)           ;LOAD EXPONENT
07f1  b7            1357   1357       OR    A                ;TEST IF 10 TO 0
07f2  c2 08 08      1358   1358       JP    NZ,FMUL1         ;BRIF NOT
07f5  13            1359   1359       INC   DE               ;POINT NEXT
07f6  1a            1360   1360       LD    A,(DE)           ;LOAD IT
07f7  fe 10         1361   1361       CP    10H              ;TEST IF 1
07f9  c2 08 08      1362   1362       JP    NZ,FMUL1         ;BRIF NOT
07fc  13            1363   1363       INC   DE               ;POINT NEXT
07fd  1a            1364   1364       LD    A,(DE)           ;LOAD IT
07fe  b7            1365   1365       OR    A                ;TEST IF ZERO
07ff  c2 08 08      1366   1366       JP    NZ,FMUL1         ;BRIF NOT
0802  13            1367   1367       INC   DE               ;POINT NEXT
0803  1a            1368   1368       LD    A,(DE)           ;LOAD IT
0804  b7            1369   1369       OR    A                ;TEST IF ZERO
0805  ca 28 00      1370   1370       JP    Z,RST5           ;GO LOAD IF FACC = 1.00000
0808  11 2a 10      1371   1371 FMUL1 LD    DE,FACC          ;POINT EXPONENT
080b  1a            1372   1372       LD    A,(DE)           ;LOAD IT
080c  cd ac 09      1373   1373       CALL  FEXP             ;GO GET EXPONENT
080f  47            1374   1374       LD    B,A              ;SAVE IN B
0810  7e            1375   1375       LD    A,(HL)           ;GET EXPONENT OF MULTIPLIER
0811  cd ac 09      1376   1376       CALL  FEXP             ;GO GET EXPONENT
0814  37            1377   1377       SCF                    ;TURN ON CY
0815  88            1378   1378       ADC   A,B              ;ADD EXPONENTS TOGETHER
0816  cd 8f 09      1379   1379       CALL  FOVUN            ;GO SEE IF OVERFLOW/UNDERFLOW
0819  e6 7f         1380   1380       AND   7FH              ;TURN OFF SIGN
081b  47            1381   1381       LD    B,A              ;SAVE
081c  1a            1382   1382       LD    A,(DE)           ;GET SIGN OF FACC
081d  ae            1383   1383       XOR   (HL)             ;PRODUCT SIGN IS NEG IF TWO SIGN
081e  e6 80         1384   1384       AND   80H              ;MASK
0820  b0            1385   1385       OR    B                ;PUT SIGN AND EXPONENT TOGETHER
0821  12            1386   1386       LD    (DE),A           ;PUT IN FACC
0822  e5            1387   1387       PUSH  HL               ;SAVE HL
0823  21 2e 10      1388   1388       LD    HL,FTEMP         ;POINT DIGIT 7 OF RESULT
0826  06 06         1389   1389       LD    B,6              ;LOOP CTR
0828  cd 4f 0e      1390   1390       CALL  ZEROM            ;GO ZERO 6 BYTES
082b  11 2b 10      1391   1391       LD    DE,FACC+1        ;POINT 1ST DIGIT OF ACC
082e  06 03         1392   1392       LD    B,3              ;LOOP CTR
0830  1a            1393   1393 FMUL5 LD    A,(DE)           ;GET AN ACC DIGIT PAIR
0831  77            1394   1394       LD    (HL),A           ;PUT TO TEMP STORAGE
0832  af            1395   1395       XOR   A                ;ZERO A
0833  12            1396   1396       LD    (DE),A           ;CLEAR ACC
0834  13            1397   1397       INC   DE               ;POINT NEXT
0835  23            1398   1398       INC   HL               ;DITTO
0836  05            1399   1399       DEC   B                ;DECR CTR
0837  c2 30 08      1400   1400       JP    NZ,FMUL5         ;LOOP
083a  0e 06         1401   1401       LD    C,6              ;OUTER LOOP CTR
083c  e1            1402   1402       POP   HL               ;GET ADDR OF MULTIPLIER
083d  ff            1403   1403       RST   RST7             ;GO BUMP HL
083e  03            1404   1404       DEFB  3                ;BY THREE
083f  79            1405   1405 FMUL6 LD    A,C              ;GET CTR
0840  1f            1406   1406       RRA                    ;TEST IF EVEN/ODD
0841  7e            1407   1407       LD    A,(HL)           ;GET MULTIPLIER DIGIT PAIR
0842  da 4a 08      1408   1408       JP    C,FMUL7          ;BRIF LEFT NEEDED
0845  e6 0f         1409   1409       AND   0FH              ;MASK
0847  c3 4d 08      1410   1410       JP    FMUL8            ;GO AROUND
084a  cd f6 0e      1411   1411 FMUL7 CALL  RIGHT            ;SHIFT RIGHT 4 BITS
084d  47            1412   1412 FMUL8 LD    B,A              ;SAVE DIGIT
084e  e5            1413   1413       PUSH  HL               ;SAVE ADDRESS
084f  c5            1414   1414       PUSH  BC               ;SAVE COUNTERS
0850  48            1415   1415       LD    C,B              ;SWAP B/C
0851  b7            1416   1416       OR    A                ;TEST MULTIPLIER
0852  ca 64 08      1417   1417       JP    Z,FMUX1          ;BRIF ZERO
0855  11 30 10      1418   1418 FMUL9 LD    DE,FTEMP+2       ;POINT PRODUCT
0858  21 36 10      1419   1419       LD    HL,FTEMP+8       ;POINT MULTIPLICAND
085b  06 06         1420   1420       LD    B,6              ;6 DIGITS PARTICIPATE
085d  cd d8 09      1421   1421       CALL  FADDT            ;GO ADD
0860  0d            1422   1422       DEC   C                ;DECR OUTER LOOP CTR
0861  c2 55 08      1423   1423       JP    NZ,FMUL9         ;LOOP
0864  16 00         1424   1424 FMUX1 LD    D,0              ;INIT SHIFT DIGIT
0866  06 06         1425   1425       LD    B,6              ;LOOP CTR
0868  21 36 10      1426   1426       LD    HL,FTEMP+8       ;POINT MULTIPLICAND
086b  cd f4 09      1427   1427       CALL  FSHFX            ;GO SHIFT
086e  c1            1428   1428       POP   BC               ;RESTORE CTRS
086f  e1            1429   1429       POP   HL               ;ANDADDRESS
0870  0d            1430   1430       DEC   C                ;DECR CTR
0871  ca 7d 08      1431   1431       JP    Z,FMUX2          ;GO AROUND IF ZERO
0874  79            1432   1432       LD    A,C              ;LOAD THE CTR
0875  1f            1433   1433       RRA                    ;TEST EVEN/ODD
0876  da 3f 08      1434   1434       JP    C,FMUL6          ;LOOP IF ODD
0879  2b            1435   1435       DEC   HL               ;ELSE, POINT NEXT
087a  c3 3f 08      1436   1436       JP    FMUL6            ;LOOP
087d  21 2b 10      1437   1437 FMUX2 LD    HL,FACC+1        ;POINT MSD OF PRODUCT
0880  7e            1438   1438       LD    A,(HL)           ;GET MSD PAIR
0881  e6 f0         1439   1439       AND   0F0H             ;ISOLATE LEFT HALF
0883  c2 b1 08      1440   1440       JP    NZ,FMUX3         ;BRIF NORMALIZED
0886  06 05         1441   1441       LD    B,5              ;CTR
0888  54            1442   1442       LD    D,H              ;COPY HL
0889  5d            1443   1443       LD    E,L              ;TO DE
088a  7e            1444   1444 FMUX4 LD    A,(HL)           ;GET A PAIR OF DIGITS
088b  e7            1445   1445       RST   RST4             ;SHIFT RIGHT TO LEFT
088c  4f            1446   1446       LD    C,A              ;SAVE DIGIT
088d  23            1447   1447       INC   HL               ;POINT NEXT PAIR
088e  7e            1448   1448       LD    A,(HL)           ;GET NEXT PAIR
088f  cd f6 0e      1449   1449       CALL  RIGHT            ;SHIFT LEFT TO RIGHT
0892  b1            1450   1450       OR    C                ;COMBINE
0893  12            1451   1451       LD    (DE),A           ;PUT DOWN
0894  13            1452   1452       INC   DE               ;POINT NEXT OUTPUT PAIR
0895  05            1453   1453       DEC   B                ;DECR CTR
0896  c2 8a 08      1454   1454       JP    NZ,FMUX4         ;LOOP
0899  7e            1455   1455       LD    A,(HL)           ;GET LAST PAIR
089a  e7            1456   1456       RST   RST4             ;SHIFT LEFT
089b  12            1457   1457       LD    (DE),A           ;PUT DOWN
089c  3a 2a 10      1458   1458       LD    A,(FACC)         ;GET EXPON & SIGN
089f  4f            1459   1459       LD    C,A              ;SAVE
08a0  e6 80         1460   1460       AND   80H              ;ISOLATE SIGN
08a2  47            1461   1461       LD    B,A              ;SAVE SIGN
08a3  79            1462   1462       LD    A,C              ;GET EXPON & SIGN
08a4  cd ac 09      1463   1463       CALL  FEXP             ;GO GET EXPON
08a7  3d            1464   1464       DEC   A                ;SUBTRACT ONE
08a8  e6 7f         1465   1465       AND   7FH              ;STRIP 8TH BIT
08aa  b0            1466   1466       OR    B                ;MERGE IN SIGN BIT
08ab  32 2a 10      1467   1467       LD    (FACC),A         ;PUT DOWN
08ae  c3 7d 08      1468   1468       JP    FMUX2            ;CONTINUE
08b1  3a 2e 10      1469   1469 FMUX3 LD    A,(FTEMP)        ;GET 1ST DIGIT PAIR FOLLOWING FA
08b4  c6 50         1470   1470       ADD   A,50H            ;ADD 5
08b6  27            1471   1471       DAA                    ;ADJUST
08b7  d2 90 07      1472   1472       JP    NC,FNORM         ;BRIF 4 OR LESS
08ba  21 2d 10      1473   1473 FROUN LD    HL,FACC+3        ;ELSE, POINT LSD OF FACC
08bd  06 03         1474   1474       LD    B,3              ;LOOP CTR
08bf  37            1475   1475       SCF                    ;TURN ON CY INDICATOR
08c0  7e            1476   1476 FMUX5 LD    A,(HL)           ;GET A DIGIT PAIR
08c1  ce 00         1477   1477       ADC   A,0              ;ADD THE CARRY
08c3  27            1478   1478       DAA                    ;ADJUST
08c4  77            1479   1479       LD    (HL),A           ;PUT BACK
08c5  2b            1480   1480       DEC   HL               ;POINT NEXT
08c6  05            1481   1481       DEC   B                ;DECR CTR
08c7  c2 c0 08      1482   1482       JP    NZ,FMUX5         ;LOOP
08ca  da 49 07      1483   1483       JP    C,FADX1          ;BRIF CARRY INTO 7 DIGITS
08cd  c3 90 07      1484   1484       JP    FNORM            ;GO NORMALIZE
                    1485   1485 *HEADING IMSAI 8080 4K BASIC
08d0  =             1486   1486 FDIV  EQU   $
                    1487   1487 ;
                    1488   1488 ;
                    1489   1489 ;FLOATING POINT DIVIDE THE NUMBER AT (HL) INTO FACC
                    1490   1490 ;
                    1491   1491 ;
08d0  cd 9e 09      1492   1492       CALL  FTEST            ;TEST IF FACC ZERO
08d3  c8            1493   1493       RET   Z                ;RETURN IF ZERO
08d4  23            1494   1494       INC   HL               ;POINT 1ST DIGIT OF DIVISOR
08d5  7e            1495   1495       LD    A,(HL)           ;LOAD IT
08d6  2b            1496   1496       DEC   HL               ;POINT BACK
08d7  b7            1497   1497       OR    A                ;TEST IF ZERO
08d8  ca 71 0e      1498   1498       JP    Z,OVERR          ;DIVISION BY ZERO = ERROR
08db  7e            1499   1499       LD    A,(HL)           ;LOAD EXPONENT OF DIVISOR
08dc  cd ac 09      1500   1500       CALL  FEXP             ;GO GET EXPON
08df  47            1501   1501       LD    B,A              ;SAVE IT
08e0  11 2a 10      1502   1502       LD    DE,FACC          ;POINT EXPONENT OF DIVIDEND
08e3  1a            1503   1503       LD    A,(DE)           ;LOAD IT
08e4  cd ac 09      1504   1504       CALL  FEXP             ;GO GET EXPON
08e7  90            1505   1505       SUB   B                ;SUBTRACT THE TWO EXPONENTS
08e8  cd 8f 09      1506   1506       CALL  FOVUN            ;GO SAE IF OVERFLOW/UNDERFLOW
08eb  e6 7f         1507   1507       AND   7FH              ;TRUNCATE TO 7 BITS
08ed  47            1508   1508       LD    B,A              ;SAVE IT
08ee  1a            1509   1509       LD    A,(DE)           ;GET EXPONENT
08ef  ae            1510   1510       XOR   (HL)             ;IF SIGNS ARE EQUAL, RESULT IS P
08f0  e6 80         1511   1511       AND   80H              ;MASK OFF UNUSED BITS
08f2  b0            1512   1512       OR    B                ;CREATE SIGN OF QUOTIENT
08f3  12            1513   1513       LD    (DE),A           ;PUT TO FACC
08f4  e5            1514   1514       PUSH  HL               ;SAVE ADDR
08f5  13            1515   1515       INC   DE               ;POINT MSD OF DIVIDEND
08f6  21 2e 10      1516   1516       LD    HL,FTEMP         ;POINT TEMPORARY STORAGE
08f9  36 00         1517   1517       LD    (HL),0           ;CLEAR HIGH ORDER POSITION
08fb  23            1518   1518       INC   HL               ;POINT NEXT
08fc  06 03         1519   1519       LD    B,3              ;LOOP CTR
08fe  1a            1520   1520 FDIV3 LD    A,(DE)           ;GET BYTE FROM FACC
08ff  77            1521   1521       LD    (HL),A           ;PUT TO FTEMP
0900  af            1522   1522       XOR   A                ;CLEAR A
0901  12            1523   1523       LD    (DE),A           ;ZERO FACC
0902  23            1524   1524       INC   HL               ;POINT NEXT
0903  13            1525   1525       INC   DE               ;DITTO
0904  05            1526   1526       DEC   B                ;DECR CTR
0905  c2 fe 08      1527   1527       JP    NZ,FDIV3         ;LOOP
0908  32 39 10      1528   1528       LD    (DIVSW),A        ;RESET SWITCH
090b  77            1529   1529       LD    (HL),A           ;CLEAR HIGH PAIR OF DIVISOR
090c  d1            1530   1530       POP   DE               ;GET ADDR
090d  06 03         1531   1531       LD    B,3              ;LOOP CTR
090f  13            1532   1532       INC   DE               ;POINT MSD OF DIVISOR
0910  23            1533   1533       INC   HL               ;AND OF DIVIDEND
0911  cd 60 0e      1534   1534       CALL  COPYD            ;GO MOVE IT
0914  0e 06         1535   1535       LD    C,6              ;OUTER LOOP CTR
0916  06 ff         1536   1536 FDIV5 LD    B,-1             ;INIT CTR
0918  11 31 10      1537   1537 FDIV7 LD    DE,FTEMP+3       ;POINT DIVIDEND
091b  21 35 10      1538   1538       LD    HL,FTEMP+7       ;POINT DIVISOR
091e  c5            1539   1539       PUSH  BC               ;SAVE BC
091f  06 04         1540   1540       LD    B,4              ;LOOP CTR
0921  cd b4 09      1541   1541       CALL  FSUBT            ;GO SUBTRACT THE TWO
0924  c1            1542   1542       POP   BC               ;GET COUNTERS
0925  04            1543   1543       INC   B                ;COUNT ONE MORE
0926  d2 18 09      1544   1544       JP    NC,FDIV7         ;LOOP IF NOT TOO FAR
0929  3a 39 10      1545   1545       LD    A,(DIVSW)        ;GET SWITCH
092c  b7            1546   1546       OR    A                ;TEST IT
092d  c2 86 09      1547   1547       JP    NZ,FDIV1         ;BRIF SET
0930  c5            1548   1548       PUSH  BC               ;SAVE BC
0931  0e 03         1549   1549       LD    C,3              ;THREE BYTE LOOP
0933  21 2d 10      1550   1550       LD    HL,FACC+3        ;POINT LSD OF QUOTIENT
0936  7e            1551   1551 FDIX1 LD    A,(HL)           ;GET DIGIT PAIR
0937  57            1552   1552       LD    D,A              ;SAVE IT
0938  e7            1553   1553       RST   RST4             ;SHIFT LEFT
0939  b0            1554   1554       OR    B                ;MERGE WITH PREV
093a  77            1555   1555       LD    (HL),A           ;PUT BACK
093b  7a            1556   1556       LD    A,D              ;GET SAVED PAIR
093c  cd f6 0e      1557   1557       CALL  RIGHT            ;SHIFT RIGHT
093f  47            1558   1558       LD    B,A              ;SAVE IT
0940  2b            1559   1559       DEC   HL               ;POINT NEXT
0941  0d            1560   1560       DEC   C                ;DECR CTR
0942  c2 36 09      1561   1561       JP    NZ,FDIX1         ;LOOP
0945  c1            1562   1562       POP   BC               ;GET CTRS
0946  11 31 10      1563   1563       LD    DE,FTEMP+3       ;POINT PREV
0949  21 35 10      1564   1564       LD    HL,FTEMP+7       ;POINT DIVISOR
094c  06 04         1565   1565       LD    B,4              ;LOOP CTR
094e  cd d8 09      1566   1566       CALL  FADDT            ;GO ADD
0951  06 04         1567   1567       LD    B,4              ;INNER CTR
0953  21 31 10      1568   1568       LD    HL,FTEMP+3       ;POINT LSD OF DIVIDEND
0956  16 00         1569   1569       LD    D,0              ;SAVE DIGIT
0958  cd f4 09      1570   1570       CALL  FSHFX            ;GO SHIFT
095b  0d            1571   1571       DEC   C                ;DECR OUTER CTR
095c  c2 16 09      1572   1572       JP    NZ,FDIV5         ;LOOP IF NOT ZERO
095f  3a 2b 10      1573   1573       LD    A,(FACC+1)       ;GET MSD OF QUOTIENT
0962  e6 f0         1574   1574       AND   0F0H             ;ISOLATE LEFT HALF
0964  c2 7e 09      1575   1575       JP    NZ,FDIX2         ;BRIF NORMALIZED
0967  3a 2a 10      1576   1576       LD    A,(FACC)         ;GET EXPON & SIGN
096a  47            1577   1577       LD    B,A              ;SAVE
096b  e6 80         1578   1578       AND   80H              ;ISOLATE SIGN
096d  4f            1579   1579       LD    C,A              ;SAVE
096e  78            1580   1580       LD    A,B              ;GET EXPON & SIGN
096f  cd ac 09      1581   1581       CALL  FEXP             ;GO GET EXPONENT
0972  3d            1582   1582       DEC   A                ;SUBTRACT ONE
0973  e6 7f         1583   1583       AND   7FH              ;TRUNCATE 8TH BIT
0975  b1            1584   1584       OR    C                ;MERGE SIGN BIT
0976  32 2a 10      1585   1585       LD    (FACC),A         ;PUT DOWN
0979  0e 01         1586   1586       LD    C,1              ;NEW LOOP CTR
097b  c3 16 09      1587   1587       JP    FDIV5            ;ONE MORE TIME
097e  3e 01         1588   1588 FDIX2 LD    A,1              ;GET A ONE
0980  32 39 10      1589   1589       LD    (DIVSW),A        ;SET SWITCH
0983  c3 16 09      1590   1590       JP    FDIV5            ;GO ONE MORE DIGIT
0986  78            1591   1591 FDIV1 LD    A,B              ;GET THE EXTRA QUOTIENT DIGIT
0987  fe 05         1592   1592       CP    5                ;COMPARE TO 5
0989  da 90 07      1593   1593       JP    C,FNORM          ;BRIF LESS
098c  c3 ba 08      1594   1594       JP    FROUN            ;ELSE, GO ROUND IT
098f  =             1595   1595 FOVUN EQU   $                ;TEST IF EXPONENT OVERFLOW/UNDER
098f  f2 98 09      1596   1596       JP    P,FOVUX          ;BRIF POSITIVE
0992  fe c1         1597   1597       CP    0C1H             ;TEST FOR UNDERFLOW
0994  d0            1598   1598       RET   NC               ;RETIFNOT UNDERFLOW
0995  c3 71 0e      1599   1599       JP    OVERR            ;ELSE, ERROR
0998  fe 40         1600   1600 FOVUX CP    40H              ;TEST IF OVERFLOW
099a  d8            1601   1601       RET   C                ;RETIF LESS
099b  c3 71 0e      1602   1602       JP    OVERR            ;ELSE, OVER/UNDEFLOW
                    1603   1603 *HEADING IMSAI 8080 4K BASIC
099e  =             1604   1604 FTEST EQU   $
                    1605   1605 ;
                    1606   1606 ;TEST THE SIGN OF THE NUMBER IN THE FACC
                    1607   1607 ;RETURN WITH S & Z ZET TO SIGN
                    1608   1608 ;
099e  3a 2b 10      1609   1609       LD    A,(FACC+1)       ;GET MSD
09a1  b7            1610   1610       OR    A                ;TEST IT
09a2  c8            1611   1611       RET   Z                ;RETURN IF ZERO
09a3  3a 2a 10      1612   1612       LD    A,(FACC)         ;GET SIGN & EXPON BYTE
09a6  f6 7f         1613   1613       OR    7FH              ;TEST SIGN BIT ONLY
09a8  3a 2a 10      1614   1614       LD    A,(FACC)         ;RE-LOAD EXPON BYTE
09ab  c9            1615   1615       RET                    ;THEN RETURN
                    1616   1616 *HEADING IMSAI 8080 4K BASIC
09ac  =             1617   1617 FEXP  EQU   $
                    1618   1618 ;
                    1619   1619 ;EXPAND EXPONENT INTO 8 BINARY BITS
                    1620   1620 ;
09ac  17            1621   1621       RLA                    ;DROP MANTISSA SIGN
09ad  b7            1622   1622       OR    A                ;TEST SIGN OF EXPON
09ae  f2 b2 09      1623   1623       JP    P,FEXP1          ;BRIF POSITIVE
09b1  37            1624   1624       SCF                    ;ELSE, TURN ON CY
09b2  1f            1625   1625 FEXP1 RRA                    ;SHIFT BACK
09b3  c9            1626   1626       RET                    ;RETURN
                    1627   1627 *HEADING IMSAI 8080 4K BASIC
09b4  =             1628   1628 FSUBT EQU   $
                    1629   1629 ;
                    1630   1630 ;DECIMAL SUBTRACT THE TWO 6 DIGIT NUMBERS (DE) & (HL)
                    1631   1631 ;
09b4  af            1632   1632       XOR   A                ;CLEAR STATUS
09b5  c5            1633   1633 FSUX1 PUSH  BC               ;SAVE CTR
09b6  1a            1634   1634       LD    A,(DE)           ;GET ACC DIGIT PAIR
09b7  9e            1635   1635       SBC   A,(HL)             ;SUBTRACT PAIR FROM SUBTRAHEND
09b8  f5            1636   1636       PUSH  AF               ;SAVE A, FLAGS
09b9  c1            1637   1637       POP   BC               ;GET A, FLAGS IN BC
09ba  79            1638   1638       LD    A,C              ;GET FLAGS
09bb  e6 10         1639   1639       AND   10H              ;TEST AC STATUS
09bd  c2 c4 09      1640   1640       JP    NZ,FSUX2         ;BRIF SET
09c0  78            1641   1641       LD    A,B              ;GET DIFFERENCE
09c1  d6 06         1642   1642       SUB   06H              ;ADJUST RIGHT SIDE
09c3  47            1643   1643       LD    B,A              ;SAVE
09c4  79            1644   1644 FSUX2 LD    A,C              ;GET FLAGS
09c5  1f            1645   1645       RRA                    ;TEST CY
09c6  d2 cd 09      1646   1646       JP    NC,FSUX3         ;BRIF NOT SET
09c9  78            1647   1647       LD    A,B              ;GET DIFF
09ca  d6 60         1648   1648       SUB   60H              ;ADJUST LEFT SIDE
09cc  47            1649   1649       LD    B,A              ;SAVE
09cd  c5            1650   1650 FSUX3 PUSH  BC               ;RESAVE A, FLAGS
09ce  f1            1651   1651       POP   AF               ;RE-LOAD DIFFERENCE, FLAGS
09cf  12            1652   1652       LD    (DE),A           ;PUT TO ACC
09d0  c1            1653   1653       POP   BC               ;GET BC
09d1  1b            1654   1654       DEC   DE               ;POINT PRIOR
09d2  2b            1655   1655       DEC   HL               ;DITTO
09d3  05            1656   1656       DEC   B                ;DECR CTR
09d4  c2 b5 09      1657   1657       JP    NZ,FSUX1         ;LOOP
09d7  c9            1658   1658       RET                    ;RETURN
                    1659   1659 *HEADING IMSAI 8080 4K BASIC
09d8  =             1660   1660 FADDT EQU   $
                    1661   1661 ;
                    1662   1662 ;ADD TWO DECIMAL NUMBERS (DE) & (HL)
                    1663   1663 ;
09d8  af            1664   1664       XOR   A                ;CLEAR STATUS
09d9  1a            1665   1665 FADXT LD    A,(DE)           ;GET PAIR
09da  8e            1666   1666       ADC   A,(HL)           ;ADD OTHER PAIR
09db  27            1667   1667       DAA                    ;ADJUST
09dc  12            1668   1668       LD    (DE),A           ;PUT DOWN
09dd  1b            1669   1669       DEC   DE               ;POINT NEXT
09de  2b            1670   1670       DEC   HL               ;DITTO
09df  05            1671   1671       DEC   B                ;DECR LOOP CTR
09e0  c2 d9 09      1672   1672       JP    NZ,FADXT         ;LOOP
09e3  c9            1673   1673       RET                    ;RETURN
                    1674   1674 *HEADING IMSAI 8080 4K BASIC
09e4  =             1675   1675 FSHFT EQU   $
                    1676   1676 ;
                    1677   1677 ;INCREMENTING SHIFT RIGHT
                    1678   1678 ;
09e4  7e            1679   1679       LD    A,(HL)           ;GET A BYTE
09e5  5f            1680   1680       LD    E,A              ;SAVE IT
09e6  cd f6 0e      1681   1681       CALL  RIGHT            ;SHIFT RIGHT
09e9  b2            1682   1682       OR    D                ;PLUS PREV
09ea  77            1683   1683       LD    (HL),A           ;STORE
09eb  7b            1684   1684       LD    A,E              ;GET PREV
09ec  e7            1685   1685       RST   RST4             ;SHIFT LEFT
09ed  57            1686   1686       LD    D,A              ;SAVE FOR NEXT
09ee  23            1687   1687       INC   HL               ;POINT NEXT
09ef  05            1688   1688       DEC   B                ;DECR CTR
09f0  c2 e4 09      1689   1689       JP    NZ,FSHFT         ;LOOP
09f3  c9            1690   1690       RET                    ;RETURN
                    1691   1691 *HEADING IMSAI 8080 4K BASIC
09f4  =             1692   1692 FSHFX EQU   $
                    1693   1693 ;
                    1694   1694 ;DECREMENTING SHIFT RIGHT
                    1695   1695 ;
09f4  7e            1696   1696       LD    A,(HL)           ;GET A BYTE
09f5  cd f6 0e      1697   1697       CALL  RIGHT            ;SHIFT RIGHT
09f8  5f            1698   1698       LD    E,A              ;SAVE IT
09f9  7e            1699   1699       LD    A,(HL)           ;RELOAD
09fa  e7            1700   1700       RST   RST4             ;SHIFT LEFT
09fb  b2            1701   1701       OR    D                ;MERGE
09fc  77            1702   1702       LD    (HL),A           ;REPLACE
09fd  53            1703   1703       LD    D,E              ;UPDATE SAVED
09fe  2b            1704   1704       DEC   HL               ;POINT NEXT
09ff  05            1705   1705       DEC   B                ;DECR CTR
0a00  c2 f4 09      1706   1706       JP    NZ,FSHFX         ;LOOP
0a03  c9            1707   1707       RET                    ;RETURN
                    1708   1708 ;
                    1709   1709 ;
                    1710   1710 *HEADING IMSAI 8080 4K BASIC
0a04  =             1711   1711 ABS   EQU   $
                    1712   1712 ;
                    1713   1713 ;
                    1714   1714 ;RETURN THE ABSOLUTE VALUE OF THE FLOATING ACCUMULATOR
                    1715   1715 ;
                    1716   1716 ;
0a04  3a 2a 10      1717   1717       LD    A,(FACC)         ;GET EXPONENT
0a07  e6 7f         1718   1718       AND   7FH              ;STRIP NEGATIVE SIGN
0a09  32 2a 10      1719   1719       LD    (FACC),A         ;REPLACE
0a0c  c9            1720   1720       RET                    ;RETURN
                    1721   1721 *HEADING IMSAI 8080 4K BASIC
0a0d  =             1722   1722 SGN   EQU   $
                    1723   1723 ;
                    1724   1724 ;
                    1725   1725 ;RETURNS THE SIGN OF THE FLOATING ACCUMULATOR
                    1726   1726 ;THAT IS:
                    1727   1727 ; 1 IF FACC > 0
                    1728   1728 ; 0 IF FACC = 0
                    1729   1729 ;-1 IF FACC < 0
                    1730   1730 ;
0a0d  cd 9e 09      1731   1731       CALL FTEST             ;GO TEST FACC
0a10  c8            1732   1732       RET   Z                ;RETURN IF ZERO
0a11  e6 80         1733   1733       AND   80H              ;ISOLATE IT
0a13  f5            1734   1734       PUSH  AF               ;SAVE IT
0a14  21 ef 0f      1735   1735       LD    HL,ONE           ;GET ADDRESS OF CONSTANT 1
0a17  ef            1736   1736       RST   RST5             ;GO LOAD IT
0a18  f1            1737   1737       POP   AF               ;RESTORE SIGN
0a19  32 2a 10      1738   1738       LD    (FACC),A         ;SET THE SIGN & EXPONENT
0a1c  c9            1739   1739       RET                    ;RETURN
                    1740   1740 *HEADING IMSAI 8080 4K BASIC
0a1d  =             1741   1741 INT   EQU   $
                    1742   1742 ;
                    1743   1743 ;
                    1744   1744 ;RETURNS THE GREATEST INTEGER NOT LARGER THAN THE ABSOLUTE VALUE
                    1745   1745 ;
                    1746   1746 ;
0a1d  21 2a 10      1747   1747       LD    HL,FACC          ;POINT FLOAT ACC
0a20  7e            1748   1748       LD    A,(HL)           ;GET EXPONENT
0a21  e6 40         1749   1749       AND   40H              ;GET SIGN OF CHARACTERISTIC
0a23  ca 2b 0a      1750   1750       JP    Z,INT2           ;BRIF GE ZERO
0a26  06 04         1751   1751       LD    B,4              ;FOUR BYTE LOOP
0a28  c3 4f 0e      1752   1752       JP    ZEROM            ;ZERO FACC AND RETURN
0a2b  7e            1753   1753 INT2  LD    A,(HL)           ;GET EXPONENT
0a2c  e6 3f         1754   1754       AND   3FH              ;ISOLATE CHARACTERISTIC
0a2e  fe 05         1755   1755       CP    5                ;TEST FOR FIVE OR LARGER
0a30  f0            1756   1756       RET   P                ;RETURN IF >= 5
0a31  47            1757   1757       LD    B,A              ;SAVE EXPONENT
0a32  3e 05         1758   1758       LD    A,5              ;GET CONSTANT
0a34  90            1759   1759       SUB   B                ;MINUS EXPONENT = LOOP CTR
0a35  47            1760   1760       LD    B,A              ;SAVE IT
0a36  21 2d 10      1761   1761       LD    HL,FACC+3        ;POINT LSD
0a39  7e            1762   1762 INT3  LD    A,(HL)           ;LOAD A BYTE
0a3a  e6 f0         1763   1763       AND   0F0H             ;DROP RIGHT HALF
0a3c  77            1764   1764       LD    (HL),A           ;PUT BACK
0a3d  05            1765   1765       DEC   B                ;DECR CTR
0a3e  c8            1766   1766       RET   Z                ;RETURN IF ZERO
0a3f  36 00         1767   1767       LD    (HL),0           ;ZERO LEFT HALF
0a41  2b            1768   1768       DEC   HL               ;POINT NEXT
0a42  05            1769   1769       DEC   B                ;DECR CTR
0a43  c2 39 0a      1770   1770       JP    NZ,INT3          ;LOOP
0a46  c9            1771   1771       RET                    ;CONTINUE EVALUATION
                    1772   1772 *HEADING IMSAI 8080 4K BASIC
0a47  =             1773   1773 SQR   EQU   $
                    1774   1774 ;
                    1775   1775 ;
                    1776   1776 ;COMPUTE THE SQUARE ROOT OF THE FACC
                    1777   1777 ;USES NEWTON'S THIRD ORDER ITERATION
                    1778   1778 ;
                    1779   1779 ;
0a47  cd 9e 09      1780   1780       CALL  FTEST            ;GO GET SIGN OF FACC
0a4a  fa 71 0e      1781   1781       JP    M,OVERR          ;BRIF SQUARE ROOT OF NEGATIVE
0a4d  c8            1782   1782       RET   Z                ;RETURN IF SQUARE ROOT OF ZERO
0a4e  21 42 10      1783   1783       LD    HL,ORIGS         ;POINT TO TEMP AREA
0a51  f7            1784   1784       RST   RST6             ;SAVE ORIGINAL NUMBER
0a52  21 ef 0f      1785   1785       LD    HL,ONE           ;POINT CONSTANT
0a55  cd d2 06      1786   1786       CALL  FADD             ;ADD ONE
0a58  21 f3 0f      1787   1787       LD    HL,TWO           ;POINT CONSTANT
0a5b  cd d0 08      1788   1788       CALL  FDIV             ;DIVIDE BY TWO
                    1789   1789 ;
                    1790   1790 ;FIRST APPROXIMATION = (X+1)/2
                    1791   1791 ;
0a5e  21 46 10      1792   1792 SQRLP LD    HL,TSTSQ         ;GET ADDR OF TEST
0a61  f7            1793   1793       RST   RST6             ;SAVE IT
0a62  21 46 10      1794   1794       LD    HL,TSTSQ         ;POINT PREV ITERATION
0a65  cd e2 07      1795   1795       CALL  FMUL             ;SQUARE IT
0a68  21 4a 10      1796   1796       LD    HL,TST2S         ;POINT SAVE AREA
0a6b  f7            1797   1797       RST   RST6             ;SAVE IT
0a6c  21 42 10      1798   1798       LD    HL,ORIGS         ;GET ORIGINAL NUMBER
0a6f  cd cb 07      1799   1799       CALL  FSUB             ;SUBTRACT FROM PREV**2
0a72  cd 9e 09      1800   1800       CALL  FTEST            ;GET SIGN OF DIFFERENCE
0a75  fa c2 0a      1801   1801       JP    M,SQRGO          ;BRIF PREV**2 < ORIGINAL
0a78  ca c2 0a      1802   1802       JP    Z,SQRGO          ;BRIF PREV**2 = ORIGINAL
0a7b  21 4a 10      1803   1803       LD    HL,TST2S         ;GET PREV**2
0a7e  ef            1804   1804       RST   RST5             ;GO LOAD IT
0a7f  21 f7 0f      1805   1805       LD    HL,THREE         ;POINT CONSTANT OF 3
0a82  cd e2 07      1806   1806       CALL  FMUL             ;MULTIPLY WITH PREV**2
0a85  21 42 10      1807   1807       LD    HL,ORIGS         ;GET ORIGINAL NUMBER
0a88  cd d2 06      1808   1808       CALL  FADD             ;GO ADD
0a8b  21 4e 10      1809   1809       LD    HL,SQRX          ;POINT TEMP AREA
0a8e  f7            1810   1810       RST   RST6             ;SAVE DIVISOR
0a8f  21 f7 0f      1811   1811       LD    HL,THREE         ;POINT CONSTANT OF 3
0a92  ef            1812   1812       RST   RST5             ;GO LOAD IT
0a93  21 42 10      1813   1813       LD    HL,ORIGS         ;GET ORIGINAL NUMBER
0a96  cd e2 07      1814   1814       CALL  FMUL             ;MULTIPLY BY THREE
0a99  21 4a 10      1815   1815       LD    HL,TST2S         ;GET SQUARE OF PREV ITERATION
0a9c  cd d2 06      1816   1816       CALL  FADD             ;GO ADD IT
0a9f  21 46 10      1817   1817       LD    HL,TSTSQ         ;GET PREV ITERATION
0aa2  cd e2 07      1818   1818       CALL  FMUL             ;GO MULTIPLY
0aa5  21 4e 10      1819   1819       LD    HL,SQRX          ;POINT DIVISOR
0aa8  cd d0 08      1820   1820       CALL  FDIV             ;GO DIVIDE
0aab  21 4e 10      1821   1821       LD    HL,SQRX          ;POINT TEMP AREA
0aae  f7            1822   1822       RST   RST6             ;SAVE IT
0aaf  21 46 10      1823   1823       LD    HL,TSTSQ         ;GET PREV ESTIMATE
0ab2  cd cb 07      1824   1824       CALL  FSUB             ;GO COMPARE THEM
0ab5  21 4e 10      1825   1825       LD    HL,SQRX          ;POINT THIS ANSWER
0ab8  cd 9e 09      1826   1826       CALL  FTEST            ;GET SIGN OF DIFFERENCE
0abb  ca c5 0a      1827   1827       JP    Z,SQRGX          ;BRIF SAME GUESS
0abe  ef            1828   1828       RST   RST5             ;ELSE, LOAD THIS GUESS
                    1829   1829 ;NEXT ITERATION = PREV*(3*X+PREV**2)/(3*PREV**2+X)
0abf  c3 5e 0a      1830   1830       JP    SQRLP            ;LOOP
0ac2  21 46 10      1831   1831 SQRGO LD    HL,TSTSQ         ;POINT SQUARE ROOT
0ac5  ef            1832   1832 SQRGX RST   RST5             ;GO LOAD ACC
0ac6  c9            1833   1833       RET                    ;THEN RETURN
                    1834   1834 *HEADING IMSAI 8080 4K BASIC
0ac7  =             1835   1835 NEG   EQU   $
                    1836   1836 ;
                    1837   1837 ;
                    1838   1838 ;REVERSES THE SIGN OF THE FLOATING ACC
                    1839   1839 ;
                    1840   1840 ;
0ac7  cd 9e 09      1841   1841       CALL  FTEST            ;GET SIGN OF FACC
0aca  c8            1842   1842       RET   Z                ;RETURN IF ZERO
0acb  ee 80         1843   1843       XOR   80H              ;REVERSE SIGN
0acd  32 2a 10      1844   1844       LD    (FACC),A         ;RESTORE EXPONENT
0ad0  c9            1845   1845       RET                    ;CONTINUE EVALUATION
                    1846   1846 *HEADING IMSAI 8080 4K BASIC
0ad1  =             1847   1847 RND   EQU   $
                    1848   1848 ;
                    1849   1849 ;
                    1850   1850 ;PSEUDO RANDOM NUMBER GENERATOR
                    1851   1851 ;
                    1852   1852 ;
0ad1  21 64 10      1853   1853       LD    HL,RNDNU         ;POINT PREV RND
0ad4  ef            1854   1854       RST   RST5             ;LOAD TO FACC
0ad5  21 fb 0f      1855   1855       LD    HL,RNDX          ;POINT MULTIPLIER
0ad8  cd e2 07      1856   1856       CALL  FMUL             ;GO MULTIPLY
0adb  21 2a 10      1857   1857       LD    HL,FACC          ;POINT RESULT
0ade  36 7f         1858   1858       LD    (HL),7FH         ;DEFAULT . XXXXXX
0ae0  23            1859   1859       INC   HL               ;POINT MSD
0ae1  46            1860   1860       LD    B,(HL)           ;LOAD IT
0ae2  23            1861   1861       INC   HL               ;POINT MSD+2
0ae3  4e            1862   1862       LD    C,(HL)           ;LOAD IT
0ae4  70            1863   1863       LD    (HL),B           ;SWAP BYTES
0ae5  2b            1864   1864       DEC   HL               ;POINT BACK MSD
0ae6  71            1865   1865       LD    (HL),C           ;MOV MSD+2
0ae7  cd 90 07      1866   1866       CALL  FNORM            ;GO NORMALIZE
0aea  21 64 10      1867   1867       LD    HL,RNDNU         ;POINT NEW RND NUMBER
0aed  f7            1868   1868       RST   RST6             ;GO STORE IT
0aee  c9            1869   1869       RET                    ;RETURN
                    1870   1870 *HEADING IMSAI 8080 4K BASIC
0aef  =             1871   1871 EXPR  EQU   $
                    1872   1872 ;
                    1873   1873 ;
                    1874   1874 ;EVALUATE EXPRESSION ROUTINE
                    1875   1875 ;LEAVE RESULT IN FACC
                    1876   1876 ;RETURN WHEN EXPRESSION ENDS (TYPICALLY AT END OF LINE)
                    1877   1877 ;
                    1878   1878 ;
0aef  af            1879   1879       XOR   A                ;CLEAR REG A
0af0  32 54 10      1880   1880       LD    (PARCT),A        ;SET PAREN CTR
0af3  32 55 10      1881   1881       LD    (SPCTR),A        ;SET STACK CTR
0af6  eb            1882   1882       EX    DE,HL            ;SAVE HL IN DE
0af7  2a 1a 11      1883   1883       LD    HL,(PROGE)       ;POINT END OF PROGRAM AREA
0afa  22 52 10      1884   1884       LD    (EXPRS),HL       ;SAVE IT
0afd  eb            1885   1885       EX    DE,HL            ;RESTORE HL
                    1886   1886 ;
0afe  =             1887   1887 LOOKD EQU   $                ;LOOK FOR CONSTANT, VARIABLE, OR
0afe  cd ed 0e      1888   1888       CALL  NUMER            ;GO TEST IF NUMERIC
0b01  c2 17 0b      1889   1889       JP    NZ,LDALP         ;BRIF NOT
0b04  cd 44 05      1890   1890 LDNUM CALL  FIN              ;GO CONVERT NUMERIC (PUT TO FACC
0b07  44            1891   1891 LDF   LD    B,H              ;COPY HL TO BC
0b08  4d            1892   1892       LD    C,L              ;SAME
0b09  2a 52 10      1893   1893       LD    HL,(EXPRS)       ;GET ADDR OF EXPR AREA
0b0c  cd c4 0e      1894   1894       CALL  GTEMP            ;GO STORE THE FACC IN TEMP AREA
0b0f  22 52 10      1895   1895       LD    (EXPRS),HL       ;SAVE UPDATED ADDRESS
0b12  60            1896   1896       LD    H,B              ;RESTORE H
0b13  69            1897   1897       LD    L,C              ;RESTORE L
0b14  c3 d2 0b      1898   1898       JP    LOOKO            ;GO GET AN OPERATION CODE
0b17  fe 2e         1899   1899 LDALP CP    '.'              ;SEE IF LEADING DECIMAL POINT
0b19  ca 04 0b      1900   1900       JP    Z,LDNUM          ;BRIF IS
0b1c  cd e4 0e      1901   1901       CALL  ALPHA            ;GO SEE IF ALPHA
0b1f  c2 aa 0b      1902   1902       JP    NZ,LDDTN         ;BRIF NOT
0b22  46            1903   1903       LD    B,(HL)           ;SAVE 1ST CHAR
0b23  23            1904   1904       INC   HL               ;POINT NEXT
0b24  0e 20         1905   1905       LD    C,' '            ;DEFAULT FOR 1 CHAR VAR
0b26  cd ed 0e      1906   1906       CALL  NUMER            ;GO SEE IF 2ND IS NUMERIC
0b29  c2 41 0b      1907   1907       JP    NZ,LDFN          ;BRIF NOT
0b2c  23            1908   1908       INC   HL               ;POINT NEXT
0b2d  4f            1909   1909       LD    C,A              ;SAVE THE CHAR
0b2e  e5            1910   1910 LDVR1 PUSH  HL               ;SAVE HL
0b2f  50            1911   1911       LD    D,B              ;COPY BC
0b30  59            1912   1912       LD    E,C              ;TO DE
0b31  cd fd 0e      1913   1913       CALL  SEARC            ;GO GET VAR ADDR IN DE
0b34  2a 52 10      1914   1914       LD    HL,(EXPRS)       ;GET EXPR ADDR
0b37  cd dc 0e      1915   1915       CALL  SADR             ;GO STORE ADDRESS
0b3a  22 52 10      1916   1916       LD    (EXPRS),HL       ;SAVE ADDRESS
0b3d  e1            1917   1917       POP   HL               ;RESTORE HL
0b3e  c3 d2 0b      1918   1918       JP    LOOKO            ;GO LOOK FOR OPCODE
0b41  cd e4 0e      1919   1919 LDFN  CALL  ALPHA            ;GO SEE IF FUNCTION
0b44  c2 2e 0b      1920   1920       JP    NZ,LDVR1         ;BRIF IT'S NOT
0b47  2b            1921   1921 LDFN1 DEC   HL               ;POINT BACK TO 1ST
0b48  7e            1922   1922       LD    A,(HL)           ;GET THAT CHAR
0b49  fe 20         1923   1923       CP    ' '              ;TEST IF SPACE
0b4b  ca 47 0b      1924   1924       JP    Z,LDFN1          ;LOOP IF IS
0b4e  e5            1925   1925       PUSH  HL               ;SAVE HL
0b4f  11 6b 0f      1926   1926       LD    DE,RNDLI         ;POINT LITERAL
0b52  d7            1927   1927       RST   RST2             ;GO COMPARE
0b53  ca 8e 0b      1928   1928       JP    Z,LDRND          ;BRIF RND
0b56  e1            1929   1929       POP   HL               ;GET HL
0b57  e5            1930   1930       PUSH  HL               ;RESAVE IT
0b58  11 73 0f      1931   1931       LD    DE,SQRLI         ;POINT LITERAL
0b5b  d7            1932   1932       RST   RST2             ;GO COMPARE
0b5c  01 47 0a      1933   1933       LD    BC,SQR           ;GET ADDR OF ROUTINE
0b5f  ca 97 0b      1934   1934       JP    Z,LDFNC          ;BRIF IS
0b62  e1            1935   1935       POP   HL               ;GET HL
0b63  e5            1936   1936       PUSH  HL               ;RESAVE
0b64  11 b3 0f      1937   1937       LD    DE,INTLI         ;POINT
0b67  d7            1938   1938       RST   RST2             ;GO COMPARE
0b68  01 1d 0a      1939   1939       LD    BC,INT           ;ROUTINE ADDR
0b6b  ca 97 0b      1940   1940       JP    Z,LDFNC          ;BRIF EQUAL
0b6e  e1            1941   1941       POP   HL               ;GET HL
0b6f  e5            1942   1942       PUSH  HL               ;SAVE IT
0b70  11 6f 0f      1943   1943       LD    DE,ABSLI         ;LITERAL
0b73  d7            1944   1944       RST   RST2             ;COMPARE
0b74  01 04 0a      1945   1945       LD    BC,ABS           ;ROUTINE
0b77  ca 97 0b      1946   1946       JP    Z,LDFNC          ;BRIF EQUAL
0b7a  e1            1947   1947       POP   HL               ;GET HL
0b7b  e5            1948   1948       PUSH  HL               ;SAVE IT
0b7c  11 77 0f      1949   1949       LD    DE,SGNLI         ;LITERAL
0b7f  d7            1950   1950       RST   RST2             ;GO COMPARE
0b80  01 0d 0a      1951   1951       LD    BC,SGN           ;ROUTINE
0b83  ca 97 0b      1952   1952       JP    Z,LDFNC          ;BRIF EQUAL
0b86  e1            1953   1953       POP   HL               ;GET HL
0b87  46            1954   1954       LD    B,(HL)           ;GET 1ST CHAR
0b88  0e 20         1955   1955       LD    C,' '            ;SPACE 2ND CHAR
0b8a  23            1956   1956       INC   HL               ;POINT NEXT
0b8b  c3 2e 0b      1957   1957       JP    LDVR1            ;BRIF VARIABLE
0b8e  e5            1958   1958 LDRND PUSH  HL               ;SAVE HL
0b8f  cd d1 0a      1959   1959       CALL  RND              ;GO GET RANDOM NUMBER
0b92  e1            1960   1960       POP   HL               ;RESTORE HL
0b93  d1            1961   1961       POP   DE               ;RESTORE STACK POINTER
0b94  c3 07 0b      1962   1962       JP    LDF              ;ACT AS IF CONSTANT
0b97  d1            1963   1963 LDFNC POP   DE               ;POP THE STACK
0b98  eb            1964   1964       EX    DE,HL            ;FLIP/FLOP
0b99  2a 52 10      1965   1965       LD    HL,(EXPRS)       ;GET ADDR
0b9c  23            1966   1966       INC   HL               ;POINT NEXT
0b9d  70            1967   1967       LD    (HL),B           ;HIGH ADDR
0b9e  23            1968   1968       INC   HL               ;POINT NEXT
0b9f  71            1969   1969       LD    (HL),C           ;LOW ADDR
0ba0  23            1970   1970       INC   HL               ;POINT NEXT
0ba1  36 01         1971   1971       LD    (HL),1           ;CODE
0ba3  22 52 10      1972   1972       LD    (EXPRS),HL       ;SAVE ADDR
0ba6  eb            1973   1973       EX    DE,HL            ;RESTORE HL
0ba7  c3 fe 0a      1974   1974       JP    LOOKD            ;NEXT MUST BE DATA TOO
0baa  fe 2d         1975   1975 LDDTN CP    '-'              ;TEST IF UNARY MINUS
0bac  c2 b7 0b      1976   1976       JP    NZ,LDDTP         ;BRIF NOT
0baf  01 c7 0a      1977   1977       LD    BC,NEG           ;SET UP CALL
0bb2  23            1978   1978       INC   HL               ;POINT NEXT
0bb3  e5            1979   1979       PUSH  HL               ;SAVE HL
0bb4  c3 97 0b      1980   1980       JP    LDFNC            ;GO AS IF FUNCTION
0bb7  fe 28         1981   1981 LDDTP CP    '('              ;TEST IF OPEN PAREN
0bb9  c2 79 0e      1982   1982       JP    NZ,SNERR         ;BRIF NOT CONSTANT, FUNCTION, OR
0bbc  3a 54 10      1983   1983       LD    A,(PARCT)        ;GET OPEN COUNT
0bbf  3c            1984   1984       INC   A                ;ADD ONE
0bc0  32 54 10      1985   1985       LD    (PARCT),A        ;STORE IT
0bc3  eb            1986   1986       EX    DE,HL            ;SAVE HL
0bc4  2a 52 10      1987   1987       LD    HL,(EXPRS)       ;GET ADDR
0bc7  23            1988   1988       INC   HL               ;POINT NEXT
0bc8  36 28         1989   1989       LD    (HL),'('         ;PUT CODE
0bca  22 52 10      1990   1990       LD    (EXPRS),HL       ;SAVE ADDR
0bcd  eb            1991   1991       EX    DE,HL            ;RESTORE HL
0bce  23            1992   1992       INC   HL               ;POINT NEXT
0bcf  c3 fe 0a      1993   1993       JP    LOOKD            ;NEXT HAS TO BE DATA TOO
0bd2  cf            1994   1994 LOOKO RST   RST1             ;SKIP BLANKS
0bd3  fe 2b         1995   1995       CP    '+'              ;TEST IF PLUS
0bd5  ca f9 0b      1996   1996       JP    Z,OP1            ;BRIF IS
0bd8  fe 2d         1997   1997       CP    '-'              ;TEST IF MINUS
0bda  ca f9 0b      1998   1998       JP    Z,OP1            ;BRIF IS
0bdd  fe 2a         1999   1999       CP    '*'              ;TEST IF MULTIPLY
0bdf  ca 2c 0c      2000   2000       JP    Z,OP2            ;BRIF IS
0be2  fe 2f         2001   2001       CP    '/'              ;TEST IF DIVIDE
0be4  ca 2c 0c      2002   2002       JP    Z,OP2            ;BRIF IS
0be7  fe 29         2003   2003       CP    ')'              ;TEST IF CLOSE PAREN
0be9  ca 41 0c      2004   2004       JP    Z,OP3            ;BRIF IS
                    2005   2005 ;ELSE MUST BE END OF EXPRESSION
0bec  3a 54 10      2006   2006       LD    A,(PARCT)        ;GET OPEN PAREN COUNT
0bef  b7            2007   2007       OR    A                ;TEST IT
0bf0  c2 79 0e      2008   2008       JP    NZ,SNERR         ;BRIF # OF ('S NOT = # OF )'S
0bf3  22 5b 10      2009   2009       LD    (ADDR3),HL       ;SAVE ADDR OF STMT
0bf6  c3 4f 0c      2010   2010       JP    EVAL             ;GO EVALUATE
0bf9  e5            2011   2011 OP1   PUSH  HL               ;SAVE HL
0bfa  4e            2012   2012       LD    C,(HL)           ;SAVE OPERATION
0bfb  06 00         2013   2013       LD    B,0              ;INIT CTR
0bfd  2a 52 10      2014   2014       LD    HL,(EXPRS)       ;GET END POINTER
0c00  04            2015   2015 OP1L1 INC   B                ;COUNT ONE MORE
0c01  7e            2016   2016       LD    A,(HL)           ;LOAD TYPE CODE
0c02  fe 28         2017   2017       CP    '('              ;TEST IF OPEN PAREN
0c04  ca 1c 0c      2018   2018       JP    Z,INSOP          ;BRIF IS
0c07  b7            2019   2019       OR    A                ;TEST IF END BUFF
0c08  ca 1c 0c      2020   2020       JP    Z,INSOP          ;BRIF IS
0c0b  b7            2021   2021       OR    A                ;TEST IF DATA
0c0c  ca 14 0c      2022   2022       JP    Z,OP1L2          ;BRIF IS
0c0f  fe 01         2023   2023       CP    1                ;TEST IF FUNCT
0c11  c2 18 0c      2024   2024       JP    NZ,OP1L3         ;BRIF NOT EQUAL
0c14  2b            2025   2025 OP1L2 DEC   HL               ;POINT NEXT
0c15  2b            2026   2026       DEC   HL               ;DITTO
0c16  04            2027   2027       INC   B                ;COUNT
0c17  04            2028   2028       INC   B                ;TWO BYTES
0c18  2b            2029   2029 OP1L3 DEC   HL               ;POINT NEXT OPCODE
0c19  c3 00 0c      2030   2030       JP    OP1L1            ;LOOP
0c1c  23            2031   2031 INSOP INC   HL               ;POINT FIRST CHAR
0c1d  7e            2032   2032       LD    A,(HL)           ;PICK UP OLD VALUE
0c1e  71            2033   2033       LD    (HL),C           ;PUT PREV
0c1f  4f            2034   2034       LD    C,A              ;ROTATE
0c20  05            2035   2035       DEC   B                ;DECR COUNT
0c21  c2 1c 0c      2036   2036       JP    NZ,INSOP         ;LOOP
0c24  22 52 10      2037   2037       LD    (EXPRS),HL       ;SAVE ADDR
0c27  e1            2038   2038       POP   HL               ;GET STMT POINTER
0c28  23            2039   2039       INC   HL               ;POINT NEXT
0c29  c3 fe 0a      2040   2040       JP    LOOKD            ;NEXT IS DATA
0c2c  e5            2041   2041 OP2   PUSH  HL               ;SAV HL
0c2d  4e            2042   2042       LD    C,(HL)           ;SAVE OPCODE
0c2e  06 01         2043   2043       LD    B,1              ;INIT CTR
0c30  2a 52 10      2044   2044       LD    HL,(EXPRS)       ;GET CURRENT END
0c33  ff            2045   2045 OP2A  RST   RST7             ;GO BUMP HL
0c34  fd            2046   2046       DEFB  -3               ;BY NEG THREE
0c35  04            2047   2047       INC   B                ;ADD
0c36  04            2048   2048       INC   B                ;THREE
0c37  04            2049   2049       INC   B                ;TO B
0c38  7e            2050   2050       LD    A,(HL)           ;GET TYPE CODE
0c39  fe 01         2051   2051       CP    1                ;SEE IF FUNCTION
0c3b  ca 33 0c      2052   2052       JP    Z,OP2A           ;BRIF IS
0c3e  c3 1c 0c      2053   2053       JP    INSOP            ;GO INSERT OPCODE
0c41  3a 54 10      2054   2054 OP3   LD    A,(PARCT)        ;GET OPEN PAREN COUNT
0c44  3d            2055   2055       DEC   A                ;SUBTRACT ONE
0c45  32 54 10      2056   2056       LD    (PARCT),A        ;SAVE IT
0c48  fa 79 0e      2057   2057       JP    M,SNERR          ;BRIF TOO MANY )'S
0c4b  23            2058   2058       INC   HL               ;POINT NEXT SOURCE
0c4c  22 5b 10      2059   2059       LD    (ADDR3),HL       ;SAVE ADDR
0c4f  2a 52 10      2060   2060 EVAL  LD    HL,(EXPRS)       ;GET END OF EXPR
0c52  01 00 00      2061   2061 EV0   LD    BC,0             ;INIT BC TO ZERO
0c55  04            2062   2062 EV1   INC   B                ;COUNT EACH BYTE
0c56  7e            2063   2063       LD    A,(HL)           ;GET CODE IN REG A
0c57  2b            2064   2064       DEC   HL               ;POINT NEXT
0c58  fe e3         2065   2065       CP    0E3H             ;TEST IT
0c5a  c2 65 0c      2066   2066       JP    NZ,EV2           ;BRIF NOT DATA
0c5d  2b            2067   2067       DEC   HL               ;POINT NEXT
0c5e  2b            2068   2068       DEC   HL               ;DITTO
0c5f  04            2069   2069       INC   B                ;BUMP CTR
0c60  04            2070   2070       INC   B                ;BY TWO
0c61  0c            2071   2071       INC   C                ;COUNT THE TERM
0c62  c3 55 0c      2072   2072       JP    EV1              ;LOOP
0c65  fe 01         2073   2073 EV2   CP    1                ;TEST IF FUNCTION
0c67  c2 b0 0c      2074   2074       JP    NZ,EV5           ;BRIF NOT
0c6a  23            2075   2075       INC   HL               ;RESET TO TYPE CODE
0c6b  23            2076   2076       INC   HL               ;POINT BACK PREV DATA
0c6c  56            2077   2077       LD    D,(HL)           ;MOVE HIGH TO D
0c6d  23            2078   2078       INC   HL               ;POINT ONE MORE
0c6e  5e            2079   2079       LD    E,(HL)           ;MOV LOW
0c6f  c5            2080   2080       PUSH  BC               ;SAVE CTRS
0c70  e5            2081   2081       PUSH  HL               ;SAVE LOCATION
0c71  eb            2082   2082       EX    DE,HL            ;FLIP/FLOP
0c72  ef            2083   2083       RST   RST5             ;GO LOAD THE VARIABLE
0c73  e1            2084   2084       POP   HL               ;RESTORE LOCATION
0c74  ff            2085   2085       RST   RST7             ;GO BUMP HL
0c75  fd            2086   2086       DEFB  -3
0c76  5e            2087   2087       LD    E,(HL)           ;LOW BYTE
0c77  2b            2088   2088       DEC   HL               ;POINT BACK
0c78  56            2089   2089       LD    D,(HL)           ;HIGH BYTE
0c79  e5            2090   2090       PUSH  HL               ;SAVE LOCATION
0c7a  21 80 0c      2091   2091       LD    HL,EV3           ;GET RETURN ADDRESS
0c7d  e5            2092   2092       PUSH  HL               ;SAVE ON STACK
0c7e  eb            2093   2093       EX    DE,HL            ;PUT TO HL
0c7f  e9            2094   2094       JP    (HL)             ;GO EXECUTE THE FUNCTION
0c80  =             2095   2095 EV3   EQU   $                ;FUNCTIONS RETURN HERE
0c80  d1            2096   2096       POP   DE               ;GET LOCATION
0c81  c1            2097   2097       POP   BC               ;GET COUNTERS
0c82  21 00 00      2098   2098       LD    HL,0             ;LOAD ZERO TO HL
0c85  e5            2099   2099       PUSH  HL               ;GET BLOCK OF
0c86  e5            2100   2100       PUSH  HL               ;4 BYTES
0c87  3a 55 10      2101   2101       LD    A,(SPCTR)        ;GET TEMP CTR
0c8a  3c            2102   2102       INC   A                ;COUNT ONE
0c8b  32 55 10      2103   2103       LD    (SPCTR),A        ;SAVE IT
0c8e  39            2104   2104       ADD   HL,SP            ;GET STACK ADDR
0c8f  c5            2105   2105       PUSH  BC               ;SAVE CTRS
0c90  d5            2106   2106       PUSH  DE               ;SAVE LOCATION
0c91  e5            2107   2107       PUSH  HL               ;SAVE ADDR
0c92  f7            2108   2108       RST   RST6             ;GO STORE THE VARIABLE
0c93  d1            2109   2109       POP   DE               ;RESTORE ADDR
0c94  e1            2110   2110       POP   HL               ;RESTORE LOCATION
0c95  c1            2111   2111       POP   BC               ;RESTORE COUNTERS
0c96  72            2112   2112       LD    (HL),D           ;PUT HIGH ADDR BYTE
0c97  23            2113   2113       INC   HL               ;POINT NEXT
0c98  73            2114   2114       LD    (HL),E           ;PUT LOW ADDR BYTE
0c99  23            2115   2115       INC   HL               ;POINT NEXT
0c9a  36 e3         2116   2116       LD    (HL),0E3H        ;SET CODE = DATA
0c9c  54            2117   2117       LD    D,H              ;COPY
0c9d  5d            2118   2118       LD    E,L              ;HL TO DE
0c9e  05            2119   2119       DEC   B                ;SUB 1 FROM BYTE COUNT
0c9f  13            2120   2120       INC   DE               ;POINT
0ca0  13            2121   2121       INC   DE               ;TO
0ca1  13            2122   2122       INC   DE               ;CORRECT
0ca2  cd bb 0e      2123   2123       CALL  SQUIS            ;GO COMPRESS STACK
0ca5  2a 52 10      2124   2124       LD    HL,(EXPRS)       ;GET ADDR
0ca8  ff            2125   2125       RST   RST7             ;GO DECR HL
0ca9  fd            2126   2126       DEFB  -3               ;BY THREE
0caa  22 52 10      2127   2127       LD    (EXPRS),HL       ;SAVE UPDATED ADDR
0cad  c3 4f 0c      2128   2128       JP    EVAL             ;START AT BEGINNING
0cb0  fe 28         2129   2129 EV5   CP    '('              ;TEST IF OPEN PAREN
0cb2  c2 cf 0c      2130   2130       JP    NZ,EV6           ;BRIF NOT
0cb5  79            2131   2131       LD    A,C              ;GET TERM CT
0cb6  fe 01         2132   2132       CP    1                ;TEST IF ONE
0cb8  c2 75 0e      2133   2133       JP    NZ,STERR         ;ERROR IF ONE TERM NOT REMAIN
0cbb  54            2134   2134       LD    D,H              ;COPY HL
0cbc  5d            2135   2135       LD    E,L              ;TO DE
0cbd  13            2136   2136       INC   DE               ;POINT SENDING
0cbe  05            2137   2137       DEC   B                ;SUBT ONE FROM COUNT
0cbf  cd bb 0e      2138   2138       CALL  SQUIS            ;GO COMPRESS IT
0cc2  2a 52 10      2139   2139       LD    HL,(EXPRS)       ;GET POINTER
0cc5  2b            2140   2140       DEC   HL               ;LESS ONE
0cc6  22 52 10      2141   2141       LD    (EXPRS),HL       ;UPDATE IT
0cc9  2a 5b 10      2142   2142       LD    HL,(ADDR3)       ;RESTORE STMT POINTERS
0ccc  c3 d2 0b      2143   2143       JP    LOOKO            ;CONTINUE
0ccf  b7            2144   2144 EV6   OR    A                ;TEST IF END OF EXPRESSION
0cd0  c2 ef 0c      2145   2145       JP    NZ,EV9           ;BRIF NOT
0cd3  79            2146   2146       LD    A,C              ;GET TERM COUNT
0cd4  fe 01         2147   2147       CP    1                ;TEST IF ONE
0cd6  c2 75 0e      2148   2148       JP    NZ,STERR         ;ERROR IF NOT ONE
0cd9  23            2149   2149       INC   HL               ;POINT HIGH ADDR
0cda  23            2150   2150       INC   HL               ;SAME
0cdb  56            2151   2151       LD    D,(HL)           ;HIGH TO D
0cdc  23            2152   2152       INC   HL               ;POINT LOW
0cdd  5e            2153   2153       LD    E,(HL)           ;LOW TO E
0cde  eb            2154   2154       EX    DE,HL            ;PUT DATA ADDRESS IN HL
0cdf  ef            2155   2155       RST   RST5             ;GO LOAD IT
0ce0  2a 5b 10      2156   2156       LD    HL,(ADDR3)       ;RESTORE STMT POINTER
0ce3  3a 55 10      2157   2157       LD    A,(SPCTR)        ;GET STACK WORD (4BYTE) COUNTER
0ce6  b7            2158   2158       OR    A                ;TEST IT
0ce7  c8            2159   2159       RET   Z                ;RETURN IF ZERO
0ce8  d1            2160   2160 EV7   POP   DE               ;RETURN 2 BYTES
0ce9  d1            2161   2161       POP   DE               ;RETURN 2 MORE
0cea  3d            2162   2162       DEC   A                ;DECR CTR
0ceb  c2 e8 0c      2163   2163       JP    NZ,EV7           ;LOOP
0cee  c9            2164   2164       RET                    ;RETURN TO STMT PROCESSOR
0cef  fe 2b         2165   2165 EV9   CP    '+'              ;TEST IF PLUS
0cf1  11 21 0d      2166   2166       LD    DE,FADDJ         ;ADDR
0cf4  ca 0f 0d      2167   2167       JP    Z,EV10           ;BRIF IS
0cf7  fe 2d         2168   2168       CP    '-'              ;TEST IF MINUS
0cf9  11 28 0d      2169   2169       LD    DE,FSUBJ         ;ADDR
0cfc  ca 0f 0d      2170   2170       JP    Z,EV10           ;BRIF IS
0cff  fe 2a         2171   2171       CP    '*'              ;TEST IF MUL
0d01  11 2f 0d      2172   2172       LD    DE,FMULJ         ;ADDR
0d04  ca 0f 0d      2173   2173       JP    Z,EV10           ;BRIF IS
0d07  fe 2f         2174   2174       CP    '/'              ;TEST IF DIV
0d09  11 36 0d      2175   2175       LD    DE,FDIVJ         ;ADDR
0d0c  c2 75 0e      2176   2176       JP    NZ,STERR         ;ERROR IF NOT
0d0f  23            2177   2177 EV10  INC   HL               ;POINT TO
0d10  23            2178   2178       INC   HL               ;1ST DATA
0d11  c5            2179   2179       PUSH  BC               ;SAVE CTRS
0d12  d5            2180   2180       PUSH  DE               ;SAVE ROUTINE ADDR
0d13  56            2181   2181       LD    D,(HL)           ;HIGH TO D
0d14  23            2182   2182       INC   HL               ;POINT NEXT
0d15  5e            2183   2183       LD    E,(HL)           ;LOW TO E
0d16  e5            2184   2184       PUSH  HL               ;SAVE POINTER
0d17  eb            2185   2185       EX    DE,HL            ;ADDR TO HL
0d18  ef            2186   2186       RST   RST5             ;GO LOAD IT
0d19  e1            2187   2187       POP   HL               ;RESTORE HL
0d1a  23            2188   2188       INC   HL               ;POINT 2ND DATA
0d1b  23            2189   2189       INC   HL               ;SAME
0d1c  56            2190   2190       LD    D,(HL)           ;HIGH TO D
0d1d  23            2191   2191       INC   HL               ;POINT NEXT
0d1e  5e            2192   2192       LD    E,(HL)           ;LOW TO E
0d1f  e3            2193   2193       EX    (SP),HL          ;POP ADDR FROM STACK, PUSH HL ON
0d20  e9            2194   2194       JP    (HL)             ;JUMP TO ROUTINE
0d21  eb            2195   2195 FADDJ EX    DE,HL            ;GET HL
0d22  cd d2 06      2196   2196       CALL  FADD             ;GO ADD
0d25  c3 3a 0d      2197   2197       JP    EV11             ;CONTINUE
0d28  eb            2198   2198 FSUBJ EX    DE,HL            ;GET HL
0d29  cd cb 07      2199   2199       CALL  FSUB             ;GO SUBTRACT
0d2c  c3 3a 0d      2200   2200       JP    EV11             ;CONTINUE
0d2f  eb            2201   2201 FMULJ EX    DE,HL            ;GET HL
0d30  cd e2 07      2202   2202       CALL  FMUL             ;GO MULTIPLY
0d33  c3 3a 0d      2203   2203       JP    EV11             ;CONTINUE
0d36  eb            2204   2204 FDIVJ EX    DE,HL            ;GET HL
0d37  cd d0 08      2205   2205       CALL  FDIV             ;GO DIVIDE
0d3a  e1            2206   2206 EV11  POP   HL               ;GET HL
0d3b  c1            2207   2207       POP   BC               ;GET CTRS
0d3c  ff            2208   2208       RST   RST7             ;GO DECR HL
0d3d  fa            2209   2209       DEFB  -6
0d3e  cd c4 0e      2210   2210       CALL  GTEMP            ;GO SAVE FACC
0d41  54            2211   2211       LD    D,H              ;COPY HL
0d42  5d            2212   2212       LD    E,L              ;TO DE
0d43  13            2213   2213       INC   DE               ;POSITION
0d44  13            2214   2214       INC   DE               ;TO
0d45  13            2215   2215       INC   DE               ;FOUR
0d46  13            2216   2216       INC   DE               ;BYTES OFFSET
0d47  78            2217   2217       LD    A,B              ;GET CTR
0d48  d6 03         2218   2218       SUB   3                ;MINUS THREE
0d4a  47            2219   2219       LD    B,A              ;SAVE
0d4b  cd bb 0e      2220   2220       CALL  SQUIS            ;GO COMPRESS
0d4e  2a 52 10      2221   2221       LD    HL,(EXPRS)       ;GET ADDR
0d51  ff            2222   2222       RST   RST7             ;GO DECR HL
0d52  fc            2223   2223       DEFB  -4               ;BY FOUR
0d53  22 52 10      2224   2224       LD    (EXPRS),HL       ;RESTORE
0d56  c3 4f 0c      2225   2225       JP    EVAL             ;CONTINUE
                    2226   2226 ;
                    2227   2227 ;
                    2228   2228 *HEADING IMSAI 8080 4K BASIC
0d59  =             2229   2229 TERMI EQU   $
                    2230   2230 ;
                    2231   2231 ;READ A LINE FROM THE TTY
                    2232   2232 ;FIRST PROMPT WITH THE CHAR IN THE A REG
                    2233   2233 ;TERMINATE THE LINE WITH A X'00'
                    2234   2234 ;IGNORE EMPTY LINES
                    2235   2235 ;CONTROL C WILL CANCEL THE LINE
                    2236   2236 ;RUBOUT WILL DELETE THE LAST CHAR INPUT
                    2237   2237 ;
                    2238   2238 ;
0d59  32 cf 10      2239   2239       LD    (PROMP),A        ;SAVE THE PROMPT CHAR
0d5c  3e ff         2240   2240       LD    A,0FFH           ;GET BEGIN MARKER
0d5e  32 01 10      2241   2241       LD    (IOBUF-1),A      ;PUT IT
0d61  21 02 10      2242   2242 REIN  LD    HL,IOBUF         ;POINT TO INPUT BUFFER
0d64  3a cf 10      2243   2243       LD    A,(PROMP)        ;GET THE PROMPT AGAIN
0d67  b7            2244   2244       OR    A                ;TEST IT
0d68  ca 73 0d      2245   2245       JP    Z,TREAD          ;BRIF NULL
0d6b  cd a5 0d      2246   2246       CALL  TESTO            ;GO WRITE IT
0d6e  3e 20         2247   2247       LD    A,' '            ;GET A SPACE
0d70  cd a5 0d      2248   2248       CALL  TESTO            ;WRITE SPACE
0d73  =             2249   2249 TREAD EQU   $
0d73  cd 9d 0d      2250   2250       CALL  TESTI            ;GO WAIT FOR READY
0d76  cd 32 0e      2251   2251       CALL  GETCH            ;GO GET THE CHARACTER
0d79  77            2252   2252       LD    (HL),A           ;PUT IN BUFFER
0d7a  7e            2253   2253       LD    A,(HL)           ;RELOAD THE CHAR
0d7b  fe 0a         2254   2254       CP    0AH              ;TEST IF LINE FEED
0d7d  ca 73 0d      2255   2255       JP    Z,TREAD          ;IGNORE IF IT IS
0d80  cd a5 0d      2256   2256       CALL  TESTO            ;ECHO THE CHARACTER
0d83  fe 0d         2257   2257       CP    0DH              ;TEST IF CR
0d85  c2 d5 0d      2258   2258       JP    NZ,NOTCR         ;BRIF NOT
0d88  cd b9 0d      2259   2259       CALL  CRLF             ;GO WRITE CRLF
0d8b  36 00         2260   2260 CR1   LD    (HL),0           ;MARK END WITH ALL HIGH
0d8d  2b            2261   2261       DEC   HL               ;POINT PRIOR
0d8e  7e            2262   2262       LD    A,(HL)           ;LOAD IT
0d8f  fe 20         2263   2263       CP    ' '              ;TEST IF SPACE
0d91  ca 8b 0d      2264   2264       JP    Z,CR1            ;BRIF SPACE
0d94  fe ff         2265   2265       CP    0FFH             ;TEST IF AT BEGINNING
0d96  ca 61 0d      2266   2266       JP    Z,REIN           ;BRIF IS (NULL LINE)
0d99  21 02 10      2267   2267       LD    HL,IOBUF         ;POINT TO START
0d9c  c9            2268   2268       RET                    ;ELSE, RETURN
0d9d  =             2269   2269 TESTI EQU   $
                    2270   2270 ;     IN    A,(TTY-1)        ;GET TERM STATUS
                    2271   2271 ;     AND   40H              ;MASK FOR RXRDY
0d9d  db 03         2272   2272       IN    A,(TTY+1)        ;**UM**
0d9f  e6 02         2273   2273       AND   2                ;**UM**
0da1  ca 9d 0d      2274   2274       JP    Z,TESTI          ;LOOP TILL READY
0da4  c9            2275   2275       RET                    ;RETURN
0da5  =             2276   2276 TESTO EQU   $
0da5  f5            2277   2277       PUSH  AF               ;SAVE CHAR TO OUTPUT
0da6  3a 61 10      2278   2278       LD    A,(OUTSW)        ;GET OUTPUT SWITCH
0da9  b7            2279   2279       OR    A                ;TEST IF OFF
0daa  c2 b7 0d      2280   2280       JP    NZ,TOUT2         ;BRIF NOT
                    2281   2281 ;TOUT1 IN    A,(TTY-1)        ;GET STATUS
                    2282   2282 ;     RLA                    ;SHIFT LEFT (TEST TXRDY)
0dad  db 03         2283   2283 TOUT1 IN    A,(TTY+1)        ;**UM**
0daf  1f            2284   2284       RRA                    ;**UM**
0db0  d2 ad 0d      2285   2285       JP    NC,TOUT1         ;LOOP TILL READY
0db3  f1            2286   2286       POP   AF               ;GET CHAR TO OUTPUT
0db4  d3 02         2287   2287       OUT   (TTY),A          ;WRITE IT
0db6  c9            2288   2288       RET                    ;RETURN
0db7  f1            2289   2289 TOUT2 POP   AF               ;RESTORE CHAR
0db8  c9            2290   2290       RET                    ;RETURN
0db9  af            2291   2291 CRLF  XOR   A                ;CLEAR REG A
0dba  32 63 10      2292   2292       LD    (COLUM),A        ;RESET COLUM POINTER
0dbd  3e 0d         2293   2293       LD    A,0DH            ;GET CR
0dbf  cd a5 0d      2294   2294       CALL  TESTO            ;WRITE IT
0dc2  3e 0a         2295   2295       LD    A,0AH            ;LF
0dc4  cd a5 0d      2296   2296       CALL  TESTO            ;WRITE IT
0dc7  c5            2297   2297       PUSH  BC               ;SAVE BC
0dc8  06 02         2298   2298       LD    B,2              ;DELAY COUNT
0dca  3e ff         2299   2299 DELAY LD    A,0FFH           ;GET RUBOUT
0dcc  cd a5 0d      2300   2300       CALL  TESTO            ;WRITE IT
0dcf  05            2301   2301       DEC   B                ;DECR LOOP CTR
0dd0  c2 ca 0d      2302   2302       JP    NZ,DELAY         ;LOOP
0dd3  c1            2303   2303       POP   BC               ;RESTORE BC
0dd4  c9            2304   2304       RET                    ;RETURN
0dd5  fe 7f         2305   2305 NOTCR CP    7FH              ;TEST IF RUBOUT
0dd7  c2 f0 0d      2306   2306       JP    NZ,NOTBS         ;BRIF NOT
0dda  2b            2307   2307       DEC   HL               ;POINT PRIOR
0ddb  7e            2308   2308       LD    A,(HL)           ;LOAD PREV CHAR
0ddc  fe ff         2309   2309       CP    0FFH             ;TEST IF AT BEGIN
0dde  ca f0 0d      2310   2310       JP    Z,NOTBS          ;BRIF IS
0de1  3e 3a         2311   2311       LD    A,':'            ;BACKSLASH
0de3  cd a5 0d      2312   2312       CALL  TESTO            ;WRITE IT
0de6  7e            2313   2313       LD    A,(HL)           ;LOAD THE CHAR
0de7  cd a5 0d      2314   2314       CALL  TESTO            ;WRITE IT
0dea  2b            2315   2315       DEC   HL               ;POINT PRIOR
0deb  3e 3a         2316   2316       LD    A,':'            ;BACKSLASH
0ded  cd a5 0d      2317   2317       CALL  TESTO            ;WRITE IT
0df0  23            2318   2318 NOTBS INC   HL               ;POINT NEXT BUFFER POSIT
0df1  c3 73 0d      2319   2319       JP    TREAD            ;LOOP FOR NEXT
                    2320   2320 ;
                    2321   2321 ;
0df4  =             2322   2322 TERMO EQU   $
                    2323   2323 ;
                    2324   2324 ;TTY PRINT ROUTINE
                    2325   2325 ;
                    2326   2326 ;OUTPUT STRING OF CHARS STARTING AT IOBUFF THRU END (00 OR
                    2327   2327 ;FOLLOWING IMBEDDED CHARACTERS ARE INTERPRETED AS CONTROLS:
                    2328   2328 ;X'00' END OF BUFFER, TYPE CR/LF AND RETURN
                    2329   2329 ;X'FE' END OF BUFFER, RETURN (NO CR/LF)
                    2330   2330 ;X'FD' TYPE CR/LF, CONTINUE
                    2331   2331 ;
                    2332   2332 ;
0df4  21 02 10      2333   2333       LD    HL,IOBUF         ;GET ADDR OF BUFFER
0df7  7e            2334   2334 OUT1  LD    A,(HL)           ;LOAD A BYTE
0df8  fe fe         2335   2335       CP    0FEH             ;SEE IF END OF LINE (NO CR/LF)
0dfa  c8            2336   2336       RET   Z                ;RETURN IF EQUAL
0dfb  fe fd         2337   2337       CP    0FDH             ;SEE IF EMBEDDED CR/LF
0dfd  c2 06 0e      2338   2338       JP    NZ,OUT2          ;BRIF NOT
0e00  cd b9 0d      2339   2339       CALL  CRLF             ;LINE FEED
0e03  c3 15 0e      2340   2340       JP    OUT4             ;CONTINUE
0e06  b7            2341   2341 OUT2  OR    A                ;TEST IF END OF OUTPUT
0e07  ca b9 0d      2342   2342       JP    Z,CRLF           ;BRIF IS
0e0a  7e            2343   2343       LD    A,(HL)           ;LOAD THE BYTE
0e0b  cd a5 0d      2344   2344       CALL  TESTO            ;TYPE IT
0e0e  3a 63 10      2345   2345       LD    A,(COLUM)        ;GET COLUM POINTER
0e11  3c            2346   2346       INC   A                ;ADD ONE
0e12  32 63 10      2347   2347       LD    (COLUM),A        ;RESTORE IT
0e15  23            2348   2348 OUT4  INC   HL               ;POINT NEXT
0e16  c3 f7 0d      2349   2349       JP    OUT1             ;LOOP
                    2350   2350 ;
                    2351   2351 ;
                    2352   2352 ;
0e19  =             2353   2353 LINEO EQU   $
                    2354   2354 ;
                    2355   2355 ;UNPACK LINE NUMBER FROM (HL) TO (DE)
                    2356   2356 ;
                    2357   2357 ;
0e19  cd 1c 0e      2358   2358       CALL  LOUT             ;GO FORMAT 2 BYTES
0e1c  =             2359   2359 LOUT  EQU   $
0e1c  7e            2360   2360       LD    A,(HL)           ;GET BYTE
0e1d  cd f6 0e      2361   2361       CALL  RIGHT            ;GO SHIFT TO RIGHT
0e20  f6 30         2362   2362       OR    30H              ;ZONE
0e22  12            2363   2363       LD    (DE),A           ;PUT TO BUFFER
0e23  13            2364   2364       INC   DE               ;POINT NEXT
0e24  7e            2365   2365       LD    A,(HL)           ;LOAD BYTE
0e25  e6 0f         2366   2366       AND   0FH              ;MASK
0e27  f6 30         2367   2367       OR    30H              ;ZONE
0e29  12            2368   2368       LD    (DE),A           ;PUT TO BUFFER
0e2a  13            2369   2369       INC   DE               ;POINT NEXT
0e2b  23            2370   2370       INC   HL               ;AND NEXT LINE BYTE
0e2c  c9            2371   2371       RET                    ;RETURN
                    2372   2372 ;
                    2373   2373 ;
0e2d  =             2374   2374 TSTCH EQU   $
                    2375   2375 ;
                    2376   2376 ;TEST IF INPUT CHAR ON KEYBOARD
                    2377   2377 ;IF THERE IS, THEN READ IT
                    2378   2378 ;TERMINATE IF CONTROL-C
                    2379   2379 ;TOGGLE OUTPUT SW IF CONTROL-O
                    2380   2380 ;
                    2381   2381 ;     IN    A,(TTY-1)        ;GET STATUS
                    2382   2382 ;     AND   40H              ;MASK FOR RXRDY
0e2d  db 03         2383   2383       IN    A,(TTY+1)        ;**UM**
0e2f  e6 02         2384   2384       AND   2                ;**UM**
0e31  c8            2385   2385       RET   Z                ;RETURN IF NOT
0e32  db 02         2386   2386 GETCH IN    A,(TTY)          ;ELSE, READ THE CHAR
0e34  e6 7f         2387   2387       AND   7FH              ;TURN OFF PARITY
0e36  fe 0f         2388   2388       CP    0FH              ;TEST IF CONTROL-O
0e38  ca 44 0e      2389   2389       JP    Z,CONTO          ;BRIF IS
0e3b  fe 03         2390   2390       CP    03H              ;TEST IF CONTROL-C
0e3d  c0            2391   2391       RET   NZ               ;RETURN IF NOT
0e3e  cd b9 0d      2392   2392       CALL  CRLF             ;PRINT CR/LF
0e41  c3 8d 00      2393   2393       JP    READY            ;QUIT WHAT YOU WERE DOING
0e44  3a 61 10      2394   2394 CONTO LD    A,(OUTSW)        ;GET SWITCH
0e47  ee 01         2395   2395       XOR   01H              ;TOGGLE
0e49  32 61 10      2396   2396       LD    (OUTSW),A        ;RESTORE
0e4c  3e 0a         2397   2397       LD    A,0AH            ;GET A LF
0e4e  c9            2398   2398       RET                    ;RETURN
                    2399   2399 ;
                    2400   2400 ;
0e4f  =             2401   2401 ZEROM EQU   $
                    2402   2402 ;
                    2403   2403 ;MOVE STRING OF ZEROS TO (HL)+...  CNT IN B
                    2404   2404 ;
0e4f  36 00         2405   2405       LD    (HL),0           ;MOVE ONE ZERO
0e51  23            2406   2406       INC   HL               ;POINT NEXT
0e52  05            2407   2407       DEC   B                ;DECR CTR
0e53  c2 4f 0e      2408   2408       JP    NZ,ZEROM         ;LOOP
0e56  c9            2409   2409       RET                    ;RETURN
                    2410   2410 ;
                    2411   2411 ;
0e57  =             2412   2412 COPYH EQU   $
                    2413   2413 ;
                    2414   2414 ;COPY STRING FROM (HL) TO (DE)
                    2415   2415 ;COUNT IN B
                    2416   2416 ;
0e57  7e            2417   2417       LD    A,(HL)           ;GET A CHAR
0e58  12            2418   2418       LD    (DE),A           ;PUT IT DOWN
0e59  23            2419   2419       INC   HL               ;POINT NEXT
0e5a  13            2420   2420       INC   DE               ;DITTO
0e5b  05            2421   2421       DEC   B                ;DECR CTR
0e5c  c2 57 0e      2422   2422       JP    NZ,COPYH         ;LOOP
0e5f  c9            2423   2423       RET                    ;RETURN
                    2424   2424 ;
                    2425   2425 ;
0e60  =             2426   2426 COPYD EQU   $
                    2427   2427 ;
                    2428   2428 ;COPY STRING FROM (DE) TO (HL)
                    2429   2429 ;COUNT IN B
                    2430   2430 ;
0e60  eb            2431   2431       EX    DE,HL            ;FLIP DE/HL
0e61  cd 57 0e      2432   2432       CALL  COPYH            ;GO COPY
0e64  eb            2433   2433       EX    DE,HL            ;THEN FLIP BACK
0e65  c9            2434   2434       RET                    ;RETURN
                    2435   2435 ;
                    2436   2436 ;
0e66  =             2437   2437 COMP2 EQU   $
                    2438   2438 ;
                    2439   2439 ;CONTINUE COMP SUBROUTINE (RST RST2)
                    2440   2440 ;
0e66  be            2441   2441       CP    (HL)             ;COMPARE THE CHAR
0e67  c0            2442   2442       RET   NZ               ;RETURN IF NOT EQUAL
0e68  13            2443   2443       INC   DE               ;POINT NEXT
0e69  23            2444   2444       INC   HL               ;DITTO
0e6a  c3 10 00      2445   2445       JP    RST2             ;LOOP
                    2446   2446 ;
                    2447   2447 ;
0e6d  01 4c 55      2448   2448 ULERR LD    BC,'UL'          ;UNDEFINED LINE NUMBER
0e70  df            2449   2449       RST   RST3
0e71  01 56 4f      2450   2450 OVERR LD    BC,'OV'          ;DIV BY ZERO/OVERFLOW/UNDERFLOW
0e74  df            2451   2451       RST   RST3
0e75  01 54 53      2452   2452 STERR LD    BC,'ST'          ;ERROR IN EXPRESSION STACK
0e78  df            2453   2453       RST   RST3
0e79  01 4e 53      2454   2454 SNERR LD    BC,'SN'          ;SYNTAX ERROR
0e7c  df            2455   2455       RST   RST3
0e7d  01 54 52      2456   2456 RTERR LD    BC,'RT'          ;RETURN & NO GOSUB
0e80  df            2457   2457       RST   RST3
0e81  01 41 44      2458   2458 DAERR LD    BC,'DA'          ;OUT OF DATA
0e84  df            2459   2459       RST   RST3
0e85  01 4f 46      2460   2460 FOERR LD    BC,'FO'          ;MORE THAN 8 NESTED FOR/NEXT OR
0e88  df            2461   2461       RST   RST3
0e89  01 58 4e      2462   2462 NXERR LD    BC,'NX'          ;FOR & NO NEXT / NEXT & NO FOR
0e8c  df            2463   2463       RST   RST3
                    2464   2464 ;
                    2465   2465 ;
                    2466   2466 ;
                    2467   2467 ;
0e8d  =             2468   2468 PACK  EQU   $
                    2469   2469 ;
                    2470   2470 ;PACK LINE NUMBER FROM (HL) TO BC
                    2471   2471 ;
                    2472   2472 ;
0e8d  cf            2473   2473       RST   RST1             ;SKIP LEADING SPACES
0e8e  01 00 00      2474   2474       LD    BC,0             ;CLEAR B AND C
0e91  3e 04         2475   2475       LD    A,4              ;INIT DIGIT COUNTER
0e93  32 56 10      2476   2476       LD    (PRSW),A         ;SAVE A
0e96  7e            2477   2477 PK1   LD    A,(HL)           ;GET CHAR
0e97  cd ee 0e      2478   2478       CALL  NUMXR            ;TEST FOR NUMERIC
0e9a  c0            2479   2479       RET   NZ               ;RETURN IF NOT NUMERIC
0e9b  e6 0f         2480   2480       AND   0FH              ;STRIP OFF ZONE
0e9d  57            2481   2481       LD    D,A              ;SAVE IT
0e9e  3a 56 10      2482   2482       LD    A,(PRSW)         ;GET COUNT
0ea1  3d            2483   2483       DEC   A                ;SUBTRACT ONE
0ea2  fa 79 0e      2484   2484       JP    M,SNERR          ;BRIF MORE THAN 4 DIGITS
0ea5  32 56 10      2485   2485       LD    (PRSW),A         ;SAVE CTR
0ea8  1e 04         2486   2486       LD    E,4              ;4 BIT SHIFT LOOP
0eaa  79            2487   2487 PK3   LD    A,C              ;GET LOW BYTE
0eab  17            2488   2488       RLA                    ;ROTATE LEFT 1 BIT
0eac  4f            2489   2489       LD    C,A              ;REPLACE
0ead  78            2490   2490       LD    A,B              ;GET HIGH BYTE
0eae  17            2491   2491       RLA                    ;ROTATE LEFT 1 BIT
0eaf  47            2492   2492       LD    B,A              ;REPLACE
0eb0  1d            2493   2493       DEC   E                ;DECR CTR
0eb1  c2 aa 0e      2494   2494       JP    NZ,PK3           ;LOOP
0eb4  79            2495   2495       LD    A,C              ;GET LOW
0eb5  b2            2496   2496       OR    D                ;PUT DIGIT IN RIGHT HALF OF BYTE
0eb6  4f            2497   2497       LD    C,A              ;REPLACE
0eb7  23            2498   2498       INC   HL               ;POINT NEXT BYTE
0eb8  c3 96 0e      2499   2499       JP    PK1              ;LOOP
                    2500   2500 ;
                    2501   2501 ;
                    2502   2502 ;
0ebb  =             2503   2503 SQUIS EQU   $
                    2504   2504 ;
                    2505   2505 ;COMPRESS THE EXPR STACK
                    2506   2506 ;TO ADDR IN HL
                    2507   2507 ;FROM ADDR IN DE
                    2508   2508 ;COUNT IN B
                    2509   2509 ;
0ebb  13            2510   2510 SQUI2 INC   DE               ;POINT NEXT SEND
0ebc  23            2511   2511       INC   HL               ;POINT NEXT RECEIVE
0ebd  1a            2512   2512       LD    A,(DE)           ;GET A CHAR
0ebe  77            2513   2513       LD    (HL),A           ;PUT IT DOWN
0ebf  05            2514   2514       DEC   B                ;DECR CTR
0ec0  c2 bb 0e      2515   2515       JP    NZ,SQUI2         ;LOOP
0ec3  c9            2516   2516       RET                    ;RETURN
                    2517   2517 ;
                    2518   2518 ;
0ec4  =             2519   2519 GTEMP EQU   $
                    2520   2520 ;
                    2521   2521 ;GETS FOUR BYTE TEMPORARY STORAGE AREA,
                    2522   2522 ;STORES THE FACC THERE,
                    2523   2523 ;PUTS ADDR OF AREA IN EXPR STACK (HL)
                    2524   2524 ;
0ec4  eb            2525   2525       EX    DE,HL            ;SAVE HL IN DE
0ec5  e3            2526   2526       EX    (SP),HL          ;EXCHANGE 0 AND RET ADDR
0ec6  e5            2527   2527       PUSH  HL               ;PUT NEW RET ADDR
0ec7  e5            2528   2528       PUSH  HL               ;DO IT AGAIN
0ec8  21 00 00      2529   2529       LD    HL,0             ;ZERO HL
0ecb  39            2530   2530       ADD   HL,SP            ;GET SP ADDR IN HL
0ecc  23            2531   2531       INC   HL               ;PLUS ONE
0ecd  23            2532   2532       INC   HL               ;PLUS ONE MORE (POINT TO NEW ARE
0ece  c5            2533   2533       PUSH  BC               ;SAVE CTRS
0ecf  d5            2534   2534       PUSH  DE               ;SAVE EXPR ADDR
0ed0  e5            2535   2535       PUSH  HL               ;SAVE TEMP ADDR
0ed1  3a 55 10      2536   2536       LD    A,(SPCTR)        ;GET WORD COUNTER
0ed4  3c            2537   2537       INC   A                ;INCR IT
0ed5  32 55 10      2538   2538       LD    (SPCTR),A        ;RESTORE IT
0ed8  f7            2539   2539       RST   RST6             ;GO STORE FACC
0ed9  d1            2540   2540       POP   DE               ;RESTORE TEMP ADDR
0eda  e1            2541   2541       POP   HL               ;RESTORE EXPR ADDR
0edb  c1            2542   2542       POP   BC               ;RESTORE CTRS
0edc  23            2543   2543 SADR  INC   HL               ;POINT NEXT BYTE
0edd  72            2544   2544       LD    (HL),D           ;HIGH BYTE TO EXPR STACK
0ede  23            2545   2545       INC   HL               ;POINT NEXT
0edf  73            2546   2546       LD    (HL),E           ;LOW BYTE TO EXPR STACK
0ee0  23            2547   2547       INC   HL               ;POINT NEXT
0ee1  36 e3         2548   2548       LD    (HL),0E3H        ;CODE = DATA
0ee3  c9            2549   2549       RET                    ;RETURN
                    2550   2550 ;
                    2551   2551 ;
0ee4  =             2552   2552 ALPHA EQU   $
                    2553   2553 ;
                    2554   2554 ;TESTS THE CHAR AT (HL)
                    2555   2555 ;RETURNS WITH Z SET IF CHAR IS ALPHA (A-Z)
                    2556   2556 ;RETURNS WITH Z OFF IF NOT ALPHA
                    2557   2557 ;CHAR IS LEFT IN REG A
                    2558   2558 ;
0ee4  cf            2559   2559       RST   RST1             ;SKIP LEADING SPACES
0ee5  fe 41         2560   2560       CP    'A'              ;TEST IF A OR HIGHER
0ee7  d8            2561   2561       RET   C                ;RETURN IF NOT ALPHA (Z IS OFF)
0ee8  fe 5b         2562   2562       CP    'Z'+1            ;TEST IF Z OR LESS
0eea  d0            2563   2563       RET   NC               ;RETURN IF NOT < Z (Z OFF)
0eeb  bf            2564   2564       CP    A                ;TURN ON Z
0eec  c9            2565   2565       RET                    ;RETURN
                    2566   2566 ;
                    2567   2567 ;
0eed  =             2568   2568 NUMER EQU   $
                    2569   2569 ;
                    2570   2570 ;TESTS THE CHAR AT (HL)
                    2571   2571 ;RETURNS WITH Z SET IF NUMERIC (0-9)
                    2572   2572 ;ELSE, Z IS OFF
                    2573   2573 ;CHAR IS LEFT IN THE A REG
                    2574   2574 ;
0eed  cf            2575   2575       RST   RST1             ;SKIP LEADING SPACES
0eee  fe 30         2576   2576 NUMXR CP    '0'              ;TEST IF ZERO OR GREATER
0ef0  d8            2577   2577       RET   C                ;RETURN IF LESS THAN ZERO
0ef1  fe 3a         2578   2578       CP    '9'+1            ;TEST IF 9 OR LESS
0ef3  d0            2579   2579       RET   NC               ;RETURN IF NOT NUMERIC
0ef4  bf            2580   2580       CP    A                ;SET Z
0ef5  c9            2581   2581       RET                    ;RETURN
                    2582   2582 ;
                    2583   2583 ;
0ef6  =             2584   2584 RIGHT EQU   $
                    2585   2585 ;
                    2586   2586 ;SHIFT THE LEFTMOST 4 BITS OF REG A RIGHT FOUR BITS
                    2587   2587 ;
0ef6  e6 f0         2588   2588       AND   0F0H             ;ISOLATE LEFT
0ef8  1f            2589   2589       RRA                    ;SHIFT ONCE
0ef9  1f            2590   2590       RRA                    ;AGAIN
0efa  1f            2591   2591       RRA                    ;AGAIN
0efb  1f            2592   2592       RRA                    ;ONE LAST TIME
0efc  c9            2593   2593       RET                    ;RETURN
                    2594   2594 ;
                    2595   2595 ;
0efd  =             2596   2596 SEARC EQU   $
                    2597   2597 ;
                    2598   2598 ;SEARCES FOR THE VARIABLE IN DE
                    2599   2599 ;RETURNS WITH ADDR OF DATA AREA FOR VARIABLE
                    2600   2600 ;
0efd  e5            2601   2601       PUSH  HL               ;SAVE HL
0efe  2a 18 11      2602   2602       LD    HL,(DATAB)       ;GET ADDR OF DATA POOL
0f01  01 fa ff      2603   2603       LD    BC,-6            ;LENGTH OF EACH ENTRY
0f04  7e            2604   2604 SCH1  LD    A,(HL)           ;GET THE BYTE
0f05  b7            2605   2605       OR    A                ;TEST IF END
0f06  ca 1d 0f      2606   2606       JP    Z,SCH3           ;BRIF END
0f09  ba            2607   2607       CP    D                ;COMPARE 1ST CHAR
0f0a  c2 19 0f      2608   2608       JP    NZ,SCH2          ;BRIF NOT EQUAL
0f0d  2b            2609   2609       DEC   HL               ;POINT NEXT
0f0e  7e            2610   2610       LD    A,(HL)           ;LOAD 2ND DIGIT
0f0f  23            2611   2611       INC   HL               ;POINT BACK
0f10  bb            2612   2612       CP    E                ;COMPARE 2ND CHAR
0f11  c2 19 0f      2613   2613       JP    NZ,SCH2          ;BRIF NOT EQUAL
0f14  09            2614   2614       ADD   HL,BC            ;POINT NEXT ENTRY
0f15  23            2615   2615       INC   HL               ;PLUS ONE
0f16  eb            2616   2616       EX    DE,HL            ;FLIP/FLOP
0f17  e1            2617   2617       POP   HL               ;RESTORE HL
0f18  c9            2618   2618       RET                    ;RETURN
0f19  09            2619   2619 SCH2  ADD   HL,BC            ;MINUS SIX
0f1a  c3 04 0f      2620   2620       JP    SCH1             ;LOOP
0f1d  72            2621   2621 SCH3  LD    (HL),D           ;PUT 1ST CHAR
0f1e  2b            2622   2622       DEC   HL               ;POINT NEXT
0f1f  73            2623   2623       LD    (HL),E           ;PUT 2ND CHAR
0f20  06 04         2624   2624       LD    B,4              ;LOOP CTR
0f22  2b            2625   2625 SCH4  DEC   HL               ;POINT NEXT
0f23  36 00         2626   2626       LD    (HL),0           ;ZERO THE VALUE
0f25  05            2627   2627       DEC   B                ;DECR CTR
0f26  c2 22 0f      2628   2628       JP    NZ,SCH4          ;LOOP
0f29  2b            2629   2629       DEC   HL               ;POINT NEXT
0f2a  70            2630   2630       LD    (HL),B           ;MOVE ZERO TO NEW END
0f2b  23            2631   2631       INC   HL               ;POINT ADDR OF VARIABLE
0f2c  eb            2632   2632       EX    DE,HL            ;PUT LOCATION TO DE
0f2d  e1            2633   2633       POP   HL               ;RESTORE HL
0f2e  c9            2634   2634       RET                    ;RETURN
                    2635   2635 ;
                    2636   2636 ;
0f2f  =             2637   2637 VAR   EQU   $
                    2638   2638 ;
                    2639   2639 ;
                    2640   2640 ;TEST (HL) FOR A VARIABLE NAME
                    2641   2641 ;PUTS THE NAME IN DE IF FOUND
                    2642   2642 ;
0f2f  cd e4 0e      2643   2643       CALL  ALPHA            ;TEST IF ALPHA
0f32  c2 79 0e      2644   2644       JP    NZ,SNERR         ;BRIF NOT ALPHA
0f35  57            2645   2645       LD    D,A              ;FIRST CHAR
0f36  1e 20         2646   2646       LD    E,' '            ;DEFAULT
0f38  23            2647   2647       INC   HL               ;POINT NEXT
0f39  cd ed 0e      2648   2648       CALL  NUMER            ;TEST IF NUMERIC
0f3c  c0            2649   2649       RET   NZ               ;RETURN IF NOT NUMERIC
0f3d  5f            2650   2650       LD    E,A              ;SAVE 2ND CHAR
0f3e  23            2651   2651       INC   HL               ;POINT NEXT
0f3f  cf            2652   2652       RST   RST1             ;SKIP SPACES
0f40  c9            2653   2653       RET                    ;THEN RETURN
                    2654   2654 ;
                    2655   2655 ;
0f41  =             2656   2656 ERROR EQU   $
                    2657   2657 ;
                    2658   2658 ;CONTINUE ERROR ROUTINE (RST RST3)
                    2659   2659 ;
0f41  71            2660   2660       LD    (HL),C           ;PUT 2ND CHAR
0f42  23            2661   2661       INC   HL               ;POINT NEXT
0f43  36 fe         2662   2662       LD    (HL),0FEH        ;MARK END
0f45  cd f4 0d      2663   2663       CALL  TERMO            ;GO PRINT IT
0f48  21 e7 0f      2664   2664       LD    HL,ERRXR         ;POINT MESG
0f4b  cd f7 0d      2665   2665       CALL  OUT1             ;GO PRINT IT
0f4e  11 02 10      2666   2666       LD    DE,IOBUF         ;POINT BUFFER
0f51  2a 6a 10      2667   2667       LD    HL,(LINE)        ;GET ADDR OF LINE NUMBER
0f54  cd 19 0e      2668   2668       CALL  LINEO            ;UNPACK LINE NUMBER
0f57  af            2669   2669       XOR   A                ;GET END CODE
0f58  12            2670   2670       LD    (DE),A           ;PUT TO BUFFER
0f59  cd f4 0d      2671   2671       CALL  TERMO            ;PRINT IT
0f5c  c3 8d 00      2672   2672       JP    GETCM            ;GO GET NEXT COMMAND
                    2673   2673 *HEADING IMSAI 8080 4K BASIC
0f5f  4c 49 53      2674   2674 LISTL DEFM  'LIS'
0f62  00            2675   2675       DEFB  0
0f63  4e 45 57      2676   2676 NEWLI DEFM  'NEW'
0f66  00            2677   2677       DEFB  0
0f67  52 55 4e      2678   2678 RUNLI DEFM  'RUN'
0f6a  00            2679   2679       DEFB  0
0f6b  52 4e 44      2680   2680 RNDLI DEFM  'RND'
0f6e  00            2681   2681       DEFB  0
0f6f  41 42 53      2682   2682 ABSLI DEFM  'ABS'
0f72  00            2683   2683       DEFB  0
0f73  53 51 52      2684   2684 SQRLI DEFM  'SQR'
0f76  00            2685   2685       DEFB  0
0f77  53 47 4e      2686   2686 SGNLI DEFM  'SGN'
0f7a  00            2687   2687       DEFB  0
0f7b  =             2688   2688 JMPTB EQU   $
0f7b  49 46         2689   2689 IFLIT DEFM  'IF'
0f7d  00            2690   2690       DEFB  0
0f7e  a4 03         2691   2691       DEFW  IF
0f80  52 45 41 44   2692   2692 READL DEFM  'READ'
0f84  00            2693   2693       DEFB  0
0f85  eb 04         2694   2694       DEFW  READ
0f87  44 41 54 41   2695   2695 DATAL DEFM  'DATA'
0f8b  00            2696   2696       DEFB  0
0f8c  86 01         2697   2697       DEFW  RUN
0f8e  46 4f 52      2698   2698 FORLI DEFM  'FOR'
0f91  00            2699   2699       DEFB  0
0f92  ba 02         2700   2700       DEFW  FOR
0f94  4e 45 58 54   2701   2701 NEXTL DEFM  'NEXT'
0f98  00            2702   2702       DEFB  0
0f99  2f 04         2703   2703       DEFW  NEXT
0f9b  47 4f 53 55   2704   2704 GOSUX DEFM  'GOSUB'
0f9f  42            2704   2705
0fa0  00            2705   2706       DEFB  0
0fa1  f3 01         2706   2707       DEFW  GOSUB
0fa3  52 45 54      2707   2708 RETLI DEFM  'RET'
0fa6  00            2708   2709       DEFB  0
0fa7  26 02         2709   2710       DEFW  RETUR
0fa9  49 4e 50 55   2710   2711 INPUX DEFM  'INPUT'
0fad  54            2710   2712
0fae  00            2711   2713       DEFB  0
0faf  b2 04         2712   2714       DEFW  INPUT
0fb1  50 52         2713   2715 PRINX DEFM  'PR'
0fb3  49 4e 54      2714   2716 INTLI DEFM  'INT'
0fb6  00            2715   2717       DEFB  0
0fb7  33 02         2716   2718       DEFW  PRINT
0fb9  3f            2717   2719       DEFM  '?'
0fba  00            2718   2720       DEFB  0
0fbb  33 02         2719   2721       DEFW  PRINT
0fbd  47 4f         2720   2722 GOTOL DEFM  'GO'
0fbf  54 4f         2721   2723 TOLIT DEFM  'TO'
0fc1  00            2722   2724       DEFB  0
0fc2  fc 01         2723   2725       DEFW  GOTO
0fc4  4c 45 54      2724   2726 LETLI DEFM  'LET'
0fc7  00            2725   2727       DEFB  0
0fc8  1a 04         2726   2728       DEFW  LET
0fca  53 54 4f      2727   2729 STOPL DEFM  'STO'
0fcd  00            2728   2730       DEFB  0
0fce  8d 00         2729   2731       DEFW  READY
0fd0  45 4e 44      2730   2732 ENDLI DEFM  'END'
0fd3  00            2731   2733       DEFB  0
0fd4  86 01         2732   2734       DEFW  RUN
0fd6  52 45 4d      2733   2735 REMLI DEFM  'REM'
0fd9  00            2734   2736       DEFB  0
0fda  86 01         2735   2737       DEFW  RUN
0fdc  00            2736   2738       DEFB  0                ;END OF TABLE
0fdd  53 54 45 50   2737   2739 STEPL DEFM  'STEP'
0fe1  00            2738   2740       DEFB  0
0fe2  54 48 45 4e   2739   2741 THENL DEFM  'THEN'
0fe6  00            2740   2742       DEFB  0
0fe7  20 45 52 52   2741   2743 ERRXR DEFM  ' ERR @ '
0feb  20 40 20      2741   2744
0fee  fe            2742   2745       DEFB  0FEH
0fef  00 10         2743   2746 ONE   DEFW  1000H            ;CONSTANT ONE
0ff1  00 00         2744   2747       DEFW  0
0ff3  00 20         2745   2748 TWO   DEFW  2000H            ;CONSTANT TWO
0ff5  00 00         2746   2749       DEFW  0
0ff7  00 30         2747   2750 THREE DEFW  3000H            ;CONSTANT THREE
0ff9  00 00         2748   2751       DEFW  0
0ffb  7f 83         2749   2752 RNDX  DEFW  837FH            ;RANDOMIZER
0ffd  74 19         2750   2753       DEFW  1974H
0fff  =             2751   2754 ROMEN EQU   $                ;END OF READ-ONLY-MEMORY
                    2752   2755 *HEADING IMSAI 8080 4K BASIC
                    2753   2756       ORG   1000H            ;RAM AREA
1000  =             2754   2757 RAM   EQU   $                ;ALIGN RAM ON 4K BOUNDARY
                    2755   2758 ;TTY   EQU   1                ;DEVICE ADDRESS FOR TERMINAL
0002  =             2756   2759 TTY   EQU   2                ;**UM**
1000                2757   2760 NULLI DEFS  2
1002                2758   2761 IOBUF DEFS  40               ;INPUT/OUTPUT BUFFER
102a                2759   2762 FACC  DEFS  4
102e                2760   2763 FTEMP DEFS  10
1038                2761   2764 REL   DEFS  1                ;HOLDS THE RELATION IN AN IF STMT
1039                2762   2765 DIVSW DEFS  1                ;0=NORMAL DIVIDE, 1=DIVIDE FOR R
103a                2763   2766 TVAR1 DEFS  4                ;TEMP STORAGE
103e                2764   2767 TVAR2 DEFS  4                ;DITTO
1042                2765   2768 ORIGS DEFS  4                ;HOLDS ORIG NUMBER FOR SQR
1046                2766   2769 TSTSQ DEFS  4                ;HOLDS TRIAL SQUARE ROOT
104a                2767   2770 TST2S DEFS  4                ;HOLDS TRIAL SQUARE ROOT ** 2
104e                2768   2771 SQRX  DEFS  4                ;TEMP STORAGE FOR SQUARE ROOT
1052                2769   2772 EXPRS DEFS  2                ;HOLDS ADDR OF EXPR
1054                2770   2773 PARCT DEFS  1
1055                2771   2774 SPCTR DEFS  1
1056                2772   2775 PRSW  DEFS  1
1057                2773   2776 ADDR1 DEFS  2                ;HOLDS TEMP ADDRESS
1059                2774   2777 ADDR2 DEFS  2                ;HOLDS TEMP ADDRESS
105b                2775   2778 ADDR3 DEFS  2                ;HOLDS STMT ADDRESS DURING EXPR
105d                2776   2779 STMT  DEFS  2                ;HOLDS ADDR OF CURRENT STATEMENT
105f                2777   2780 INDX  DEFS  2                ;HOLDS VARIABLE NAME OF FOR/NEXT
1061                2778   2781 OUTSW DEFS  1                ;OUTPUT SUPPRESS IF ON
1062                2779   2782 RUNSW DEFS  1                ;0=RUN MODE, 1=IMMEDIATE MODE
1063                2780   2783 COLUM DEFS  1                ;CURRENT TTY COLUM
1064                2781   2784 RNDNU DEFS  4
1068                2782   2785 DASTM DEFS  2                ;HOLDS LINE ADDRESS OF CURRENT D
106a                2783   2786 LINE  DEFS  2                ;HOLD ADDR OF PREV LINE NUM
106c                2784   2787 STACK DEFS  2                ;HOLDS ADDR OF START OF RETURN
106e                2785   2788 FORNE DEFS  97
10cf                2786   2789 PROMP DEFS  1                ;HOLDS PROMPT CHARACTER
10d0                2787   2790 IMMED DEFS  70               ;IMMEDIATE COMMAND STORAGE AREA
1116                2788   2791 DATAP DEFS  2                ;ADDR OF CURRENT DATA STMT
1118                2789   2792 DATAB DEFS  2                ;ADDRESS OF DATA POOL
111a                2790   2793 PROGE DEFS  2                ;ADDR OF PROG POOL END
111c                2791   2794       DEFS  1                ;THIS HAS LOW VALUE AT RUN TIME
111d  =             2792   2795 BEGPR EQU   $                ;PROGRAM AREA STARTS HERE
                    2793   2796 ;
                    2794   2797 ;
111d                2795   2798       END   BASIC

Symbol table

ABS   0a04    ABSLI 0f6f    ADDR1 1057    ADDR2 1059*   ADDR3 105b
ALPHA 0ee4    BASIC 0000    BEGPR 111d    COLUM 1063    COMP2 0e66
CONTI 0049    CONTO 0e44    CONTX 01a3*   COPYD 0e60    COPYH 0e57
CR1   0d8b    CRLF  0db9    DAERR 0e81    DASTM 1068    DATAB 1118
DATAL 0f87    DATAN 04fc    DATAP 1116    DATOK 0526    DELAY 0dca
DIVSW 1039    EDIT1 00a8    EDIT2 00b9    EDIT3 00d9    EDIT4 00e5
EDIT5 00f2    EDIT6 0107    EDIT7 0113    EDITX 00ed    ENDLI 0fd0*
ERROR 0f41    ERRXR 0fe7    EV0   0c52*   EV1   0c55    EV10  0d0f
EV11  0d3a    EV2   0c65    EV3   0c80    EV5   0cb0    EV6   0ccf
EV7   0ce8    EV9   0cef    EVAL  0c4f    EXEC  0123    EXPR  0aef
EXPRS 1052    FACC  102a    FADD  06d2    FADD1 0762    FADD3 06f3
FADD4 06fe    FADD6 0723    FADD7 0725    FADD9 0732    FADDJ 0d21
FADDT 09d8    FADX1 0749    FADX2 076a    FADXT 09d9    FDIV  08d0
FDIV1 0986    FDIV3 08fe    FDIV5 0916    FDIV7 0918    FDIVJ 0d36
FDIX1 0936    FDIX2 097e    FEXP  09ac    FEXP1 09b2    FIN   0544
FIN12 05b6    FIN13 05b7    FIN14 05bc    FIN15 05d8    FIN16 05ef
FIN17 05f0    FIN18 05f4    FIN19 05f7    FIN2  055d    FIN20 0605
FIN3  055f    FIN4  0564    FIN5  0577    FIN6  0581    FIN7  058c
FIN8  058e    FIN9  059e    FINDL 0052    FMUL  07e2    FMUL1 0808
FMUL5 0830    FMUL6 083f    FMUL7 084a    FMUL8 084d    FMUL9 0855
FMULJ 0d2f    FMUX1 0864    FMUX2 087d    FMUX3 08b1    FMUX4 088a
FMUX5 08c0    FNOR1 07a5    FNOR2 07ac    FNORM 0790    FOERR 0e85
FOR   02ba    FOREQ 0347    FORLI 0f8e*   FORLP 0334    FORN1 039c
FORNE 106e    FORNO 0340    FORPO 031e    FORST 02f9*   FORTA 0324
FORXE 0312*   FOUT  0607    FOUT1 0614    FOUT2 0625    FOUT3 062e
FOUT4 0651    FOUT5 0655    FOUT6 066e    FOUT7 0672    FOUT8 0675
FOUT9 068d    FOVUN 098f    FOVUX 0998    FOX1  0698    FOX2  06ac
FOX3  0699    FOX4  06a5    FOX5  06ba    FOX6  06c4    FROUN 08ba
FSHFT 09e4    FSHFX 09f4    FSUB  07cb    FSUBJ 0d28    FSUBT 09b4
FSUX1 09b5    FSUX2 09c4    FSUX3 09cd    FTEMP 102e    FTEST 099e
GENRN 0083    GETCH 0e32    GETCM 008d    GOSUB 01f3    GOSUX 0f9b*
GOTO  01fc    GOTO1 0202    GOTO2 021e    GOTOL 0fbd*   GTEMP 0ec4
IF    03a4    IFEQ  03b9    IFGT  03c1    IFLIT 0f7b*   IFLT  03cb
IFNOT 03f1    IFNTX 03ff    IFREL 03b0    IMED  0159    IMMD  01a2
IMMED 10d0    IN1   04bc    IN2   04d7    INDX  105f    INPUT 04b2
INPUX 0fa9*   INSOP 0c1c    INT   0a1d    INT2  0a2b    INT3  0a39
INTLI 0fb3    IOBUF 1002    JMPTB 0f7b    LDALP 0b17    LDDTN 0baa
LDDTP 0bb7    LDF   0b07    LDFN  0b41    LDFN1 0b47    LDFNC 0b97
LDNUM 0b04    LDRND 0b8e    LDVR1 0b2e    LET   041a    LETLI 0fc4*
LINE  106a    LINEO 0e19    LIST  01d3    LISTL 0f5f    LISTX 01d6
LNEXT 036e    LOOKD 0afe    LOOKO 0bd2    LOUT  0e1c    MEMEN 005f
NEG   0ac7    NEWLI 0f63    NEXT  042f    NEXTL 0f94    NEXTS 0190
NEXTZ 04ab    NOJMP 01c1    NOSTP 02fc    NOTBS 0df0    NOTCO 0537
NOTCR 0dd5    NOTDO 019c*   NOTDT 051c    NOTSC 013c    NULLI 1000
NUMER 0eed    NUMXR 0eee    NXEQ  0456    NXERR 0e89    NXLP  0442
NXNE  044d    NXTNE 048f    NXTPO 0488*   NXTZR 0493    ONE   0fef
OP1   0bf9    OP1L1 0c00    OP1L2 0c14    OP1L3 0c18    OP2   0c2c
OP2A  0c33    OP3   0c41    ORIGS 1042    OUT1  0df7    OUT2  0e06
OUT4  0e15    OUTSW 1061    OVERR 0e71    PACK  0e8d    PARCT 1054
PK1   0e96    PK3   0eaa    PR1   0237    PR2   0240    PR3   0246*
PR4   0257    PR5   0261    PR6   0266    PR7   0287    PR8   02ad
PRINT 0233    PRINX 0fb1*   PRNXT 024c    PROGE 111a    PROMP 10cf
PRSW  1056    RAM   1000    READ  04eb    READL 0f80*   READY 008d
REIN  0d61    REL   1038    REMLI 0fd6*   RETLI 0fa3*   RETUR 0226
RIGHT 0ef6    RND   0ad1    RNDLI 0f6b    RNDNU 1064    RNDX  0ffb
ROMEN 0fff*   RST1  0008    RST2  0010    RST3  0018    RST4  0020
RST5  0028    RST6  0030    RST7  0038    RST7A 0046    RTERR 0e7d
RUN   0186    RUNIT 016d    RUNLI 0f67    RUNSW 1062    SADR  0edc
SCH1  0f04    SCH2  0f19    SCH3  0f1d    SCH4  0f22    SEARC 0efd
SGN   0a0d    SGNLI 0f77    SNERR 0e79    SPCTR 1055    SQR   0a47
SQRGO 0ac2    SQRGX 0ac5    SQRLI 0f73    SQRLP 0a5e    SQRX  104e
SQUI2 0ebb    SQUIS 0ebb    STACK 106c    STEPL 0fdd    STERR 0e75
STMT  105d    STOPL 0fca*   TABEN 01cd    TABLO 01ac    TBEND 02b4
TBLP  0291    TBLP2 0298    TBON  029d    TBSPA 02a2    TERMI 0d59
TERMO 0df4    TESTI 0d9d    TESTO 0da5    THENL 0fe2    THREE 0ff7
TOLIT 0fbf    TOUT1 0dad    TOUT2 0db7    TREAD 0d73    TRUE  0410
TST2S 104a    TSTCH 0e2d    TSTSQ 1046    TTY   0002    TVAR1 103a
TVAR2 103e    TWO   0ff3    ULERR 0e6d    VAR   0f2f    ZEROM 0e4f
