;
;          INTELLEC/MDS MONITOR
;             VERSION 2.0
;
;          COPYRIGHT (C) 1974, 1975
;          INTEL CORPORATION
;          3065 BOWERS AVENUE
;          SANTA CLARA, CALIFORNIA 95051
;
; <LEGAL COMMAND> ::= <ASSIGN I/O COMMAND>
;                     <BNPF PUNCH COMMAND>
;                     <COMPARE COMMAND>
;                     <DISPLAY MEMORY COMMAND>
;                     <ENDFILE COMMAND>
;                     <FILL MEMORY COMMAND>
;                     <PROGRAM EXECUTE COMMAND>
;                     <HEXADECIMAL ARITHMETIC COMMAND>
;                     <LOAD BNPF COMMAND>
;                     <MOVE MEMORY COMMAND>
;                     <LEADER COMMAND>
;                     <PROGRAM COMMAND>
;                     <QUERY STATUS COMMAND>
;                     <READ HEXADECIMAL FILE COMMAND>
;                     <SUBSTITUTE MEMORY COMMAND>
;                     <TRANSFER COMMAND>
;                     <WRITE HEXADECIMAL RECORD COMMAND>
;                     <REGISTER MODIFY COMMAND>
;
; <ASSIGN I/O COMMAND> ::= A<LOGICAL DEVICE>=<PHYSICAL DEVICE>
;
; <BNPF PUNCH COMMAND> ::= B<NUMBER>,<NUMBER>
;
; <COMPARE COMMAND> ::= C<T/F><SOCKET><NUMBER>,<NUMBER>
;
; <DISPLAY MEMORY COMMAND> ::= D<NUMBER>,<NUMBER>
;
; <ENDFILE COMMAND> ::= E<NUMBER>
;
; <FILL MEMORY COMMAND> ::= F<NUMBER>,<NUMBER>,<NUMBER>
;
; <PROGRAM EXECUTE COMMAND> ::= G<NUMBER>,<NUMBER>,<NUMBER>
;
; <HEXADECIMAL ARITHMETIC COMMAND> ::= H<NUMBER>,<NUMBER>
;
; <LOAD BNPF COMMAND> ::= L<NUMBER>,<NUMBER>
;
; <MOVE MEMORY COMMAND> ::= M<NUMBER>,<NUMBER>,<NUMBER>
;
; <LEADER COMMAND> ::= N
;
; <PROGRAM COMMAND> ::= P<T/F><SOCKET><NUMBER>,<NUMBER>,<NUMBER>
;
; <QUERY STATUS COMMAND> ::= Q
;
; <READ HEXADECIMAL FILE COMMAND> ::= R<NUMBER>
;
; <SUBSTITUTE MEMORY COMMAND> ::= S<NUMBER>...
;
; <TRANSFER COMMAND> ::= T<T/F><SOCKET><NUMBER>,<NUMBER>
;
; <WRITE HEXADECIMAL RECORD COMMAND> ::= W<NUMBER>,<NUMBER>
;
; <REGISTER MODIFY COMMAND> ::= X<REGISTER IDENTIFIER><NUMBER>...
;
; <LOGICAL DEVICE> ::= CONSOLE!READER!LIST!PUNCH
;
; <PHYSICAL DEVICE> ::= CRT!TTY!PTR!PTP!BATCH!1!2
;
; <REGISTER IDENTIFIER> ::= A!B!C!D!E!F!H!I!L!M!P!S
;
; <SOCKET> ::= X!Y!Z
;
; <T/F> ::= T!F
;
; <NUMBER> ::=        <HEX DIGIT>
;             <NUMBER><HEX DIGIT>
;
; <HEX DIGIT> ::= 0!1!2!3!4!5!6!7!8!9!A!B!C!D!E!F
;
VER	EQU	20		; VERSION 2.0
	TITLE	' INTELLEC/MDS MONITOR, VERSION 2.0, 15 SEPTEMBER 1975 '
DATE	EQU	1509H		; CREATION DATE, 15 SEPTEMBER 1975
;
; NOTE:
;
; THE DATE SHOWN ABOVE IS ENCODED IN A TWO BYTE FIELD
; IN BOTH THE BOOTSTRAP PROM AND THE MONITOR ROM IN ORDER
; TO CONTROL NEW RELEASES OF THIS PROGRAM.
;
; IN THE BOOTSTRAP PROM, THE DATE CODE IS LOCATED AT
; ADDRESSES 4 AND 5.
;
; IN THE MONITOR ROM, THE DATE CODE IS LOCATED AT ADDRESSES
; 0F824H AND 0F825H.
;
; IF AND WHEN A NEW RELEASE IS ISSUED, PLEASE CHANGE THE
; DATE CODE.
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; INTELLEC/MDS SYSTEM CONSTANTS
;
; TTY AND CRT STATUS BITS
;
TRDY	EQU	00000001B	; TRANSMIT READY
RBR	EQU	00000010B	; RECEIVE BUFFER READY
TBE	EQU	00000100B	; TRANSMIT EMPTY
RPAR	EQU	00001000B	; RECEIVE PARITY ERROR
ROV	EQU	00010000B	; RECEIVE OVERRUN ERROR
RFR	EQU	00100000B	; RECEIVE FRAMING ERROR
DSR	EQU	10000000B	; DATA SET READY
;
; TTY AND CRT INITIALIZATION CONTROLS
;
R48@1	EQU	00000010B	; 4800 BAUD @ JUMPER 1
R96@1	EQU	00000001B	; 9600 BAUD @ JUMPER 1
R24@1	EQU	00000011B	; 2400 BAUD @ JUMPER 1
R6@2	EQU	00000010B	; 600 BAUD @ JUMPER 2
R12@2	EQU	00000001B	; 1200 BAUD @ JUMPER 2
R3@2	EQU	00000011B	; 300 BAUD @ JUMPER 2
R110	EQU	00000010B	; 110 BAUD @ JUMPER 3
CL7	EQU	00001000B	; CHARACTER LENGTH = 7
CL8	EQU	00001100B	; CHARACTER LENGTH = 8
CL6	EQU	00000100B	; CHARACTER LENGTH = 6
CL5	EQU	00000000B	; CHARACTER LENGTH = 5
ST1	EQU	01000000B	; 1 STOP BIT
ST15	EQU	10000000B	; 1.5 STOP BITS
ST2	EQU	11000000B	; 2 STOP BITS
PENB	EQU	00010000B	; PARITY ENABLE
PEVEN	EQU	00100000B	; EVEN PARITY
TXEN	EQU	00000001B	; TRANSMIT ENABLE
DTR	EQU	00000010B	; DATA TERMINAL READY
RXEN	EQU	00000100B	; RECEIVE ENABLE
CLERR	EQU	00010000B	; CLEAR ERROR
USRST	EQU	01000000B	; USART RESET
RTS	EQU	00100000B	; REQUEST TO SEND
;
; PTR, PTP, AND TTY READER CONTROLS
;
PTPREV	EQU	00010000B	; PUNCH REVERSE DIRECTION
PTPADV	EQU	00100000B	; PUNCH ADVANCE
PTRREV	EQU	00000100B	; READ REVERSE DIRECTION
PTRADV	EQU	00001000B	; READER ADVANCE
TTYADV	EQU	00000010B	; TTY ADVANCE
;
; LPT, PTR, AND PTP STATUS BITS
;
LPTRY	EQU	00000001B	; LPT READY
PTRDY	EQU	00000001B	; PTR READY WITH DATA
PTPRY	EQU	00000100B	; PTP READY FOR DATA
;
; TTY I/O CONSTANTS
;
TTI	EQU	0F4H		; TTY INPUT DATA PORT
TTO	EQU	0F4H		; TTY OUTPUT DATA PORT
TTS	EQU	0F5H		; TTY INPUT STATUS PORT
TTC	EQU	0F5H		; TTY OUTPUT CONTROL PORT
;
; CRT I/O CONSTANTS
;
CRTI	EQU	0F6H		; CRT INPUT DATA PORT
CRTS	EQU	0F7H		; CRT INPUT STATUS PORT
CRTO	EQU	0F6H		; CRT OUTPUT DATA PORT
CRTC	EQU	0F7H		; CRT OUTPUT COMMAND PORT
;
; PTR I/O CONSTANTS
;
PTRI	EQU	0F8H		; PTR INPUT DATA PORT
PTRS	EQU	0F9H		; PTR INPUT STATUS PORT
PTRC	EQU	0F9H		; PTR OUTPUT COMMAND PORT
;
; PTP I/O CONSTANTS
;
PTPO	EQU	0F8H		; PTP OUTPUT DATA PORT
PTPS	EQU	0F9H		; PTP INPUT STATUS PORT
PTPC	EQU	0F9H		; PTP OUTPUT COMMAND PORT
;
; LPT I/O CONSTANTS
;
LPTO	EQU	0FAH		; LPT OUTPUT DATA PORT
LPTS	EQU	0FBH		; LPT INPUT STATUS PORT
LPTC	EQU	0FBH		; LPT OUTPUT COMMAND PORT
;
; REAL TIME CLOCK CONSTANTS
; EACH TICK = 1.0 MS
;
RTC	EQU	0FFH		; REAL TIME CLOCK PORT
RTCS	EQU	00000001B	; REAL TIME CLOCK STATUS
BOOT	EQU	00000010B	; BOOTSTRAP MODE INDICATOR, 1 = ON
;
; PROGRAMMER I/O CONSTANTS
;
PHI	EQU	0F1H		; PROM COMMAND AND MSB ADDRESS BITS
PLO	EQU	0F2H		; PROM ADDRESS BITS (8 LSB)
PDATA	EQU	0F0H		; PROM DATA PORT
PSTAT	EQU	0F1H		; PROM STATUS PORT
PCOMP	EQU	00000010B	; PROGRAMMING COMPLETE
PGRDY	EQU	00000001B	; PROM READY
PSOCK	EQU	00100000B	; 16 PIN SOCKET SELECTED
PNIB	EQU	00010000B	; SELECT UPPER NIBBLE
;
; FDCC CONSTANTS
;
LOW	EQU	79H		; LOW(IOPB)
HI	EQU	7AH		; HIGH(IOPB)
DSTAT	EQU	78H		; DISK STATUS
TRK0	EQU	3000H		; FIRST ADDRESS OF DISK BOOTSTRAP
;
;	CONDITIONAL ASSEMBLY SWITCHES
;
FALSE	EQU	0
TRUE	EQU	NOT FALSE
DEBUG	EQU	FALSE
;
; GLOBAL CONSTANTS
;
TOUT	EQU	250		; 250 MS. COUNTER FOR READER TIMEOUT
CR	EQU	0DH		; ASCII VALUE OF CARRIAGE RETURN
LF	EQU	0AH		; ASCII VALUE OF LINE FEED
ETX	EQU	03H		; MONITOR BREAK CHARACTER (CONTROL C)
;
; I/O STATUS BYTE MASKS AND VALUES
;
CMSK	EQU	11111100B	; MASK FOR CONSOLE I/O
RMSK	EQU	11110011B	; MASK FOR READER INPUT
PMSK	EQU	11001111B	; MASK FOR PUNCH OUTPUT
LMSK	EQU	00111111B	; MASK FOR LIST OUTPUT
;
CTTY	EQU	00000000B	; CONSOLE I/O = TTY
CCRT	EQU	00000001B	; CONSOLE I/O = CRT
BATCH	EQU	00000010B	; BATCH MODE,
				; INPUT = READER, OUTPUT = LIST
CUSE	EQU	00000011B	; USER DEFINED CONSOLE I/O
RTTY	EQU	00000000B	; READER = TTY
RPTR	EQU	00000100B	; READER = PTR
RUSE1	EQU	00001000B	; USER DEFINED READER (1)
RUSE2	EQU	00001100B	; USER DEFINED READER (2)
PTTY	EQU	00000000B	; PUNCH = TTY
PPTP	EQU	00010000B	; PUNCH = PTP
PUSE1	EQU	00100000B	; USER DEFINED PUNCH (1)
PUSE2	EQU	00110000B	; USER DEFINED PUNCH (2)
LTTY	EQU	00000000B	; LIST = TTY
LCRT	EQU	01000000B	; LIST = CRT
LLPT	EQU	10000000B	; LIST = LPT
LUSE	EQU	11000000B	; USER DEFINED LIST
;
; INTERRUPT SYSTEM MASKS AND VALUES
;
INT0	EQU	00000001B	; MASK FOR INTERRUPT LEVEL 0
INT1	EQU	00000010B
INT2	EQU	00000100B
INT3	EQU	00001000B
INT4	EQU	00010000B
INT5	EQU	00100000B
INT6	EQU	01000000B
INT7	EQU	10000000B
;
MASK	EQU	0FCH		; MASK PORT
REVRT	EQU	0FDH		; INTERRUPT REVERT
LOCK	EQU	0FEH		; BUS OVERRIDE
ISTAT	EQU	0FAH		; INTERRUPT STATUS PORT
ICON	EQU	0F3H		; INTERRUPT CONTROL PORT
EOI	EQU	00100000B	; END OF INTERRUPT
;
; INTERRUPT STATUS AND CONTROL BITS
;
ITTYO	EQU	00000001B	; OUTPUT TTY
ITTYI	EQU	00000010B	; INPUT TTY
IPTP	EQU	00000100B	; PTP
IPTR	EQU	00001000B	; PTR
ICRTO	EQU	00010000B	; OUTPUT CRT
ICRTI	EQU	00100000B	; INPUT CRT
ILPT	EQU	01000000B	; LPT
MENB	EQU	10000000B	; ENABLE MONITOR INTERRUPTS
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; PAGE 0 DEDICATED RAM LOCATIONS, INITIALIZED BY SHADOW PROM CODE.
	ORG	0
RESET:	DS	3		; TRAP TO MONITOR RESTART
IOBYT:	DS	1		; I/O SYSTEM STATUS BYTE
MSK:				; PROM PROGRAMMING T/F FLAG
MEMTOP:	DS	2		; TOP OF RAM, ONLY H SAVED
INITIO:	DS	1		; INITIAL I/O CONFIGURATION
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
;	MACRO DEFINITIONS
;
FETCH	MACRO	VALUE		; FETCH AN ADDRESS IN THE STACK
	LXI	H,VALUE
	DAD	SP
	ENDM
;
GET	MACRO	VALUE		; COMPUTE RAM ADDRESS BASED ON STACK
	LHLD	MEMTOP
	MVI	L,VALUE AND 0FFH
	ENDM
;
WHILE	MACRO	CHAR		; SCAN INPUT WHILE EQUAL
	LOCAL	LOOP
LOOP:	CALL	TI
	CPI	CHAR
	JZ	LOOP
	ENDM
;
UNTIL	MACRO	CHAR		; SCAN INPUT UNTIL EQUAL
	LOCAL	LOOP
LOOP:	CALL	TI
	CPI	CHAR
	JNZ	LOOP
	ENDM
;
SIZE	MACRO			; FIND TOP OF MEMORY
	LOCAL	LOOP
	LXI	H,0		; INITIAL VALUE
LOOP:	INR	H
	MOV	A,M		; FETCH CONTENTS OF MEMORY
	CMA			; INVERT IT
	MOV	M,A		; ATTEMPT TO WRITE INTO MEMORY
	CMP	M		; IS LOCATION READ/WRITE?
	CMA			; INVERT AGAIN
	MOV	M,A		; WRITE DATA BACK
	JZ	LOOP		; YES, CONTINUE
	DCX	H		; LAST ADDRESS IN RAM
	SHLD	MEMTOP		; STORE TOP OF MEMORY
	ENDM
;
; CASE BRANCH MACRO
; INPUT PARAMETERS:
; REGISTER A - CASE INDEX, 0...N
; PARAMETER 1 - ADDRESS OF BRANCH TABLE
; PARAMETER 2 - LENGTH OF BRANCH TABLE
; USES REGISTERS A,D,E,H,L
;
CASE	MACRO	TABLE,RANGE
	LXI	H,TABLE
	CPI	RANGE		; TEST FOR OVERRUN
	JP	ERROR
	MOV	E,A		; MOVE INDEX TO DE
	MVI	D,0
	DAD	D		; ADD BASE + 2 * INDEX -> HL
	DAD	D
	MOV	A,M		; GET LSB OF BRANCH LOCATION
	INX	H
	MOV	H,M		; GET MSB OF BRANCH LOCATION
	MOV	L,A
	PCHL
	ENDM
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; SHADOW PROM CODE
;
SBASE	SET	0
	ORG	SBASE
;
; FUNCTIONS:
;
;	A.	INITIALIZE INTERRUPT SYSTEM.
;		1. PROGRAM INTERRUPT SUBSYSTEM (8259)
;		2. MASK ALL INTERRUPTS BUT TRAP LOGIC
;
	JMP	SH0		; BRANCH AROUND STATUS BYTE
INIT:	DB	0		; INITIALLY,
				; CONSOLE = TTY,
				; READER = TTY,
				; PUNCH = TTY,
				; LIST = TTY
	DW	DATE		; DATE STAMP FOR BOOTSTRAP PROM
SH0:	DI			; DISABLE INTERRUPT SYSTEM
	MVI	A,12H		; INITIALIZE COMMAND
	OUT	REVRT
	XRA	A
	XRA	A
	OUT	MASK
	MVI	A,NOT INT0
	OUT	MASK
	MVI	A,0
	OUT	ICON
;
;	B.	INITIALIZE RAM.
;		1. COMPUTE SIZE OF RAM MEMORY
;
	SIZE
;
;		2. SET UP DEDICATED MEMORY LOCATIONS
;			USER I/O ENTRY POINTS (TOP OF MEMORY)
;			EXIT TEMPLATE
;			USER REGISTERS
;			USER INTERRUPT MASK
;			USER STACK
;			MONITOR STACK
;
	LXI	B,TOS		; MOVE EXIT TEMPLATE TO RAM
	MOV	L,C
	SPHL			; SET STACK
SH1:	LDAX	B
	MOV	M,A
	INR	C		; MOVE BOTH POINTERS
	INR	L
	JNZ	SH1		; END ON PAGE BOUNDARY
	MVI	L,SLOC		; SET UP INITIAL VALUE FOR USER STACK
	MOV	M,H		; LOWER HALF OF STACK POINTER IS KNOWN
	DCR	M
				; MERELY SET UPPER HALF.
;
;			TRAP TO MONITOR (0-2)
;
	MVI	A,0C3H		; JMP RESTART
	STA	RESET
	LXI	H,RESTART	; SET UP RESTART 0 FOR BREAKPOINT
	SHLD	RESET+1		; LOGIC
;
;	C.	PROGRAM I/O DEVICES
;		1. USART FOR CRT
;		2. USART FOR TTY
;
	MVI	A,ST1 OR R24@1 OR CL8
	OUT	CRTC
	MVI	A,ST2 OR R110 OR CL8
	OUT	TTC
	MVI	A,TXEN OR DTR OR RXEN OR RTS
	OUT	CRTC
	OUT	TTC
;
;		3. HIGH SPEED READER
;		4. HIGH SPEED PUNCH
;		5. TTY READER
;
	XRA	A
	OUT	PTRC
;
;	D.	LOAD ISIS.T0 IF DISKETTE 0 IS READY
;
	IN	DSTAT		; SAMPLE FDCC STATUS
	RRC
	JNC	SH3
	MVI	A,IOPB
	OUT	LOW		; LOW(IOPB)
	XRA	A
	OUT	HI		; HIGH(IOPB), START DISK I/O
SH2:	IN	DSTAT		; WAIT FOR FDCC TO COMPLETE
	ANI	4
	JZ	SH2
;
;	E.	DETERMINE COLD START CONSOLE.
;
SH3:	LXI	H,IOBYT		; POINT TO I/O STATUS
	MOV	D,M		; FETCH INTO D
	IN	TTS
	ANI	RBR
	JZ	SH4		; NOT TTY
	IN	TTI		; GET CHARACTER FROM TTY
	JMP	SH5
SH4:	INR	D		; IOBYTE = CRT
	IN	CRTS
	ANI	RBR
	JZ	SH3		; NOT CRT
	IN	CRTI		; GET CHARACTER FROM CRT
SH5:	ANI	7FH
	CPI	' '
	JNZ	SH3
	MOV	M,D		; REPLACE MODIFIED I/O STATUS BYTE
	MVI	L,INITIO
	MOV	M,D		; SET INITIAL I/O CONFIGURATION
;
;	F.	IF DISK IS READY, TRANSFER TO ISIS.T0
;
	IN	DSTAT
	RRC
	JC	TRK0
;
;	G.	TYPE SIGN-ON FOR RAM MONITOR
;
	MVI	L,VERS		; ADDRESS OF MESSAGE
	MVI	B,LVER		; LENGTH OF MESSAGE
SH6:	MOV	C,M		; GET A CHARACTER
	MOV	A,D		; TEST CONSOLE SELECTION
	RRC
	CNC	TTYOUT		; PRINT ON TTY IF TTY IS CONSOLE
	MOV	A,D
	RRC
	CC	CRTOUT		; PRINT ON CRT IF CRT IS CONSOLE
	INX	H
	DCR	B
	JNZ	SH6
;
;	H.	BRANCH TO MONITOR
;
	JMP	BEGIN		; INTERRUPTS ARE DISABLED.
;
;	DISK I/O PARAMETER BLOCK
;
IOPB:	DB	80H		; IOCW, NO UPDATE BIT SET
	DB	04H		; I/O INSTRUCTION, READ DISK 0
	DB	26		; READ 26 SECTORS
	DB	0		; TRACK 0
	DB	1		; SECTOR 1
	DW	TRK0		; LOAD ADDRESS
;
;	MDS MONITOR SIGN-ON MESSAGE
;
VERS:	DB	CR,LF,'MDS MONITOR, V'
	DB	VER/10+'0','.',VER MOD 10+'0'
	DB	CR,LF
LVER	EQU	$-VERS		; LENGTH OF SIGN-ON MESSAGE
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; EXIT CODE TEMPLATE, TO BE EXECUTED IN RAM
; THIS CODE IS ORIGINATED SO AS TO BE ALIGNED
; AGAINST THE TOP OF A PAGE
;
	ORG	SBASE+0C8H
;
TOS:				; BASE OF MONITOR WORK STACK
USER	EQU	TOS-8		; BASE OF DEFAULT USER WORK STACK
ELOC:	DB	0EEH		; E REGISTER STORAGE
DLOC:	DB	0DDH		; D REGISTER
CLOC:	DB	0CCH		; C REGISTER
BLOC:	DB	0BBH		; B REGISTER
	DB	0		; UNUSED BYTE
ILOC:	DB	NOT INT0	; INTERRUPT MASK
FLOC:	DB	0FFH		; CPU FLAGS
ALOC:	DB	0AAH		; A REGISTER
	DB	USER		; LOW(SP)
SLOC:	DB	0		; HIGH(SP)
;
EXIT:				; MONITOR STACK ORIGIN
	DI			; DISABLE TO PROTECT THIS SEQUENCE
	POP	D		; RESTORE D,E
	POP	B		; RESTORE B,C
	POP	PSW		; RESTORE INTERRUPT MASK
	OUT	MASK
	POP	PSW		; RESTORE A AND FLAGS
	POP	H		; RESTORE ORIGINAL STACK VALUE
	SPHL
	LXI	H,1234H		; RESTORE H,L
LLOC	EQU	$-2
HLOC	EQU	$-1
	EI			; ENABLE INTERRUPTS
	JMP	6789H		; RETURN TO INTERRUPTED CODE
PLOC	EQU	$-1
TLOC:	DW	0		; TRAP 1 ADDRESS
	DB	0		; TRAP 1 VALUE
	DW	0		; TRAP 2 ADDRESS
	DB	0		; TRAP 2 VALUE
;
; EXTENSIBLE I/O ENTRY POINTS
;
XTBL:
CILOC:	JMP	0
COLOC:	JMP	0
R1LOC:	JMP	0
R2LOC:	JMP	0
P1LOC:	JMP	0
P2LOC:	JMP	0
L1LOC:	JMP	0
CSLOC:	JMP	0
ENDX	EQU	$		; THIS LABEL SHOULD BE AT 100H.
;
; END OF SHADOW PROM CODE
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
;SELECTION CODES FOR USER I/O ENTRY POINTS
;
UCI	EQU	(CILOC-XTBL)/3
UCO	EQU	(COLOC-XTBL)/3
UR1	EQU	(R1LOC-XTBL)/3
UR2	EQU	(R2LOC-XTBL)/3
UP1	EQU	(P1LOC-XTBL)/3
UP2	EQU	(P2LOC-XTBL)/3
UL1	EQU	(L1LOC-XTBL)/3
UCS	EQU	(CSLOC-XTBL)/3
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; COMPUTE BASE ADDRESS OF MONITOR PROPER
;
BASE	SET	0F800H		; BASE ADDRESS OF MONITOR
				; TOP 2K OF ADDRESS SPACE
	IF	DEBUG
BASE	SET	800H		; DEBUG IN RAM
	ENDIF
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; START OF MONITOR PROPER
;
	ORG	BASE
;
; BRANCH TABLE FOR I/O SYSTEM
;
BEGIN:	JMP	START		; RESET ENTRY POINT
	JMP	CI		; CONSOLE INPUT
	JMP	RI		; READER INPUT
	JMP	CO		; CONSOLE OUTPUT
	JMP	PO		; PUNCH OUTPUT
	JMP	LO		; LIST OUTPUT
	JMP	CSTS		; CONSOLE INPUT STATUS
	JMP	IOCHK		; I/O SYSTEM STATUS
	JMP	IOSET		; SET I/O CONFIGURATION
	JMP	MEMCK		; COMPUTE SIZE OF MEMORY
	JMP	IODEF		; DEFINE USER I/O ENTRY POINTS
	JMP	SPCL		; I/O CONTROL
	DW	DATE		; DATE STAMP FOR MONITOR ROM
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; ERROR EXIT.
;
; THIS ABNORMAL EXIT IS EXECUTED FOR ALL MONITOR ERROR CONDITIONS.
; THE STACK POINTER VALUE IS RECOMPUTED BECAUSE OF ITS UNKNOWN STATE
; AS A RESULT OF A COMMAND OR DATA ERROR.
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A -
;	B -		C - S
;	D -		E -
;	H - X		L - X
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP - S		PC -
;	STACK USAGE: 2 BYTES
;
ERROR:	GET	TOS
	SPHL
	CALL	COMC
	DB	'#'
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; MAIN COMMAND LOOP.
;
; THIS LOOP IS THE STARTING POINT OF ALL COMMAND SEQUENCES.
; IN THIS CODE INTERRUPTS ARE ENABLED AND A CARRIAGE RETURN
; AND LINE FEED ARE TYPED ALONG WITH THE PROMPT CHARACTER, '.'.
; WHEN A CHARACTER IS ENTERED FROM THE CONSOLE KEYBOARD, IT
; IS CHECKED FOR VALIDITY, THEN A BRANCH TO THE PROPER
; PROCESSING ROUTINE IS COMPUTED.
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A - X
;	B - X		C - S
;	D - S		E - S
;	H - X		L - X
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP - X		PC - X
;	STACK USAGE: 4 BYTES
;
START:	IN	RTC		; LOOP UNTIL BOOTSTRAP MODE IS DISABLED
	ANI	BOOT
	JNZ	START
	EI			; ENABLE INTERRUPTS
	CALL	CRLF		; TYPE <CR>,<LF>
	CALL	COMC		; OUTPUT A PERIOD
	DB	'.'
	CALL	TI		; GET A CHARACTER, ECHO IT.
	SUI	'A'		; TEST FOR A-X
	JM	START		; LT A, IGNORE
	MVI	C,2		; C IS SET UP FOR 2 PARAMETER COMMANDS
	LXI	D,START		; SET UP PSEUDO RETURN ADDRESS
	PUSH	D		; TO SIMULATE EFFECT OF CALL
	CASE	CTBL,LCT	; BRANCH TO PROCESSING ROUTINE
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; COMMAND BRANCH TABLE
;
; THIS TABLE CONTAINS THE ADDRESSES OF THE ENTRY POINTS OF
; ALL THE COMMAND PROCESSING ROUTINES.  NOTE THAT AN ENTRY TO 'ERROR'
; IS AN ERROR CONDITION, I.E., NO COMMAND CORRESPONDING TO THAT
; CHARACTER EXISTS.
;
CTBL:	DW	ASSIGN		;A - ASSIGN I/O UNITS
	DW	BNPF		;B - PUNCH BNPF
	DW	COMP		;C - COMPARE PROM WITH MEMORY
	DW	DISP		;D - DISPLAY RAM MEMORY
	DW	EOF		;E - ENDFILE A HEXADECIMAL FILE
	DW	FILL		;F - FILL MEMORY
	DW	GOTO		;G - GO TO MEMORY ADDRESS
	DW	HEXN		;H - HEXADECIMAL SUM AND DIFFERENCE
	DW	ERROR		;I -
	DW	ERROR		;J -
	DW	ERROR		;K -
	DW	LOAD		;L - LOAD BNPF TAPE
	DW	MOVE		;M - MOVE MEMORY
	DW	NULL		;N - PUNCH NULLS FOR LEADER
	DW	ERROR		;O -
	DW	PROG		;P - PROGRAM A PROM
	DW	QUERY		;Q - QUERY I/O SYSTEM STATUS
	DW	READ		;R - READ HEXADECIMAL FILE
	DW	SUBS		;S - SUBSTITUTE MEMORY
	DW	TRAN		;T - TRANSFER A PROM TO MEMORY
	DW	ERROR		;U -
	DW	ERROR		;V -
	DW	WRITE		;W - WRITE HEX TAPE
	DW	X		;X - EXAMINE AND MODIFY REGISTERS
LCT	EQU	($-CTBL)/2
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; PROCESS I/O DEVICE ASSIGNMENT COMMANDS.
;
; THIS ROUTINE MAPS SYMBOLIC DEVICE IDENTIFIERS TO BITS
; IN THE I/O STATUS BYTE (IOBYT) TO ALLOW FOR CONSOLE
; MODIFICATION OF SYSTEM I/O CONFIGURATION.
;
ASSIGN:	CALL	TI		; GET LOGICAL DEVICE CHARACTER
	LXI	H,LTBL		; ADDRESS OF MASTER TABLE
	MVI	C,4		; MAXIMUM OF 4 ENTRIES
AS0:	CMP	M		; TEST FOR IDENTIFYING CHARACTER
	INX	H
	JZ	AS1		; FOUND IT
	INX	H		; POINT TO NEXT ENTRY
	INX	H
	INX	H
	DCR	C		; DECREMENT LOOP COUNT
	JNZ	AS0		; TRY NEXT ENTRY
	JMP	ERROR		; NO MATCH, ERROR
AS1:	MOV	B,M		; GET SELECT BIT MASK
	INX	H
	MOV	E,M		; GET PHYSICAL DEVICE TABLE
	INX	H
	MOV	D,M
	XCHG
	UNTIL	'='
	WHILE	' '
	MVI	C,4		; SET TABLE LENGTH
AS2:				; INDEX THROUGH PHYSICAL UNIT TABLE
	CMP	M		; COMPARE DEVICE CHAR WITH LEGAL VALUES
	INX	H
	JZ	AS3		; RETURN WITH HL -> DEVICE SELECT BITS
	INX	H
	DCR	C
	JNZ	AS2		; CONTINUE LOOKUP
	JMP	ERROR		; ERROR RETURN
AS3:	UNTIL	CR
	LDA	IOBYT		; GET I/O STATUS
	ANA	B		; CLEAR FIELD
	ORA	M		; SET NEW STATUS
	STA	IOBYT		; RETURN TO MEMORY
	RET
;
; MASTER I/O DEVICE TABLE
; 4 BYTES/ENTRY
;
;    BYTE 0 = IDENTIFYING CHARACTER
;    BYTE 1 = LOGICAL DEVICE MASK
;    BYTE 2,3 = SUBORDINATE PHYSICAL DEVICE TABLE
;
LTBL:	DB	'C',CMSK
	DW	ACT
	DB	'R',RMSK
	DW	ART
	DB	'P',PMSK
	DW	APT
	DB	'L',LMSK
	DW	ALT
;
; I/O SYSTEM PHYSICAL DEVICE TABLES
; 2 BYTES/ENTRY
;
;   BYTE 0 = IDENTIFYING CHARACTER
;   BYTE 1 = DEVICE SELECT BIT PATTERN
;
ACT:	DB	'T',CTTY	; CONSOLE = TTY
	DB	'C',CCRT	; CONSOLE = CRT
	DB	'B',BATCH	; BATCH MODE CONSOLE = READ,LIST
	DB	'1',CUSE	; USER DEFINED CONSOLE DEVICE
ART:	DB	'T',RTTY	; READER = TTY
	DB	'P',RPTR	; READER = PTR
	DB	'1',RUSE1	; USER DEFINED READER DEVICE 1
	DB	'2',RUSE2	; USER DEFINED READER DEVICE 2
APT:	DB	'T',PTTY	; PUNCH = TTY
	DB	'P',PPTP	; PUNCH = PTP
	DB	'1',PUSE1	; USER DEFINED PUNCH DEVICE 1
	DB	'2',PUSE2	; USER DEFINED PUNCH DEVICE 2
ALT:	DB	'T',LTTY	; LIST = TTY
	DB	'C',LCRT	; LIST = CRT
	DB	'L',LLPT	; LIST = LPT
	DB	'1',LUSE	; USER DEFINED LIST DEVICE
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; PUNCH A BNPF TAPE.
;
; THIS ROUTINE EXPECTS TWO HEXADECIMAL PARAMETERS TO BE
; ENTERED FROM THE KEYBOARD AND INTERPRETS THEM AS
; THE BOUNDS OS A MEMORY AREA TO BE PUNCHED ON THE
; ASSIGNED PUNCH DEVICE IN BNPF FORMAT.  THE TAPE
; PRODUCED IS FORMATTED WITH 4 BNPF 8-BIT WORDS PER
; LINE.
;
BNPF:	CALL	EXPR		; GET TWO ADDRESSES
	CALL	CRLF
	CALL	LEAD
	POP	D		; GET HIGH ADDRESS
	POP	H		; GET LOW ADDRESS
BN0:	CALL	POC
	DB	'B'		; PUNCH A 'B'
	MVI	B,8		; 8 BIT COUNT
	MOV	A,M		; GET DATA
BN1:	RLC			; ROTATE TO SET CARRY
	PUSH	PSW		; SAVE INTERMEDIATE RESULT
	MVI	A,'N'/2		; COMPUTE EITHER 'P' OR 'N'
				; BASED ON THE FOLLOWING ALGORITHM:
	ACI	0		; CHAR = 'N'/2 + CARRY
	ADD	A		; CHAR = CHAR * 2
				; CHAR = 'N' IF CARRY = 0
	MOV	C,A		; CHAR = 'P' IF CARRY = 1
	CALL	PO
	POP	PSW
	DCR	B
	JNZ	BN1
	CALL	POC
	DB	'F'
	CALL	POC
	DB	' '
	CALL	HILO
	JC	NU0		; ALL DONE, PUNCH TRAILER AND RETURN
	MOV	A,L
	ANI	03H		; PUNCH CR, LF, ON MULTIPLE OF 4
	CZ	PEOL
	JMP	BN0
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; COMPARE PROM WITH MEMORY.
;
; THIS ROUTINE EXPECTS (1) AN OPTION CHARACTER (X,Y,Z)
; WHICH SPECIFIES WHICH SOCKET OPTION IS SELECTED, AND
; (2) TWO HEXADECIMAL PARAMETERS WHICH IT INTERPRETS
; AS THE RAM MEMORY AREA WHICH IS TO BE COMPARED TO THE
; CONTENTS OF THE PROM IN THE SELECTED PROGRAMMING SOCKET.
; ALL DIFFERENCES BETWEEN THE PROM AND THE MEMORY AREA
; WILL BE DISPLAYED ON THE CONSOLE IN THE FOLLOWING
; FORMAT:
;
; <MEM ADDRESS> <MEM CONTENTS> <CORRESPONDING PROM CONTENTS>
;
COMP:	CALL	SELECT		; SELECT SOCKET
	PUSH	B		; SAVE PROM ADDRESS AND COMMAND
	MVI	C,2
	CALL	EXPR		; GET MEMORY AREA
	POP	D		; HIGH ADDRESS
	POP	H		; LOW ADDRESS
	POP	B		; POP PROM ADDRESS
	PUSH	B		; SAVE BIT MASK
	MVI	C,0		; ZERO 8 LSB OF PROM ADDRESS
CM0:	MOV	A,B
	OUT	PHI		; OUTPUT COMMAND AND 4 MSB
	MOV	A,C
	OUT	PLO		; OUTPUT 8 LSB
	IN	PDATA		; READ PROM
	PUSH	H
	LXI	H,MSK		; FETCH T/F FLAG
	XRA	M
	POP	H
	XRA	M		; COMPARE PORT WITH MEMORY
	XTHL			; GET BIT MASK
	ANA	L
	XTHL
	JZ	CM1		; OK
	PUSH	B		; SAVE ADDRESS
	CALL	CRLF		; NEW LINE FOR ERROR DISPLAY
	CALL	LADR		; DISPLAY MEMORY ADDRESS
	CALL	BLK
	MOV	A,M		; DISPLAY MEMORY CONTENTS
	CALL	LBYTE
	CALL	BLK
	IN	PDATA
	CALL	LBYTE		; DISPLAY PROM CONTENTS
	IN	PSTAT
	ANI	PCOMP
	JZ	ERROR
	POP	B		; RESTORE PROM ADDRESS
CM1:	INX	B		; INCREMENT PROM ADDRESS
	CALL	HILO		; TEST FOR COMPLETION
	JNC	CM0
	POP	B		; FLUSH MASK OFF STACK
	RET
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; DISPLAY MEMORY IN HEX ON LIST DEVICE.
;
; THIS ROUTINE EXPECTS TWO HEXADECIMAL PARAMETERS SPECIFYING
; THE BOUNDS OF THE MEMORY AREA TO BE DISPLAYED ON THE
; LIST DEVICE.  THE MEMORY AREA IS DISPLAYED 16 BYTES
; PER LINE, WITH THE MEMORY ADDRESS OF THE FIRST BYTE
; PRINTED FOR REFERENCE.  ALL LINES ARE BLOCKED INTO INTEGRAL
; MULTIPLES OF 16 FOR CLARITY, SO THAT THE FIRST AND LAST
; LINES MAY BE LESS THAN 16 BYTES IN ORDER TO SYNCHRONIZE THE
; DISPLAY.
;
DISP:	CALL	EXPR		; GET TWO ADDRESSES
	POP	D		; GET HIGH ADDRESS
	POP	H		; GET LOW ADDRESS
DI0:	CALL	LCRLF		; PRINT CR,LF
	CALL	DADR		; PRINT MEMORY ADDRESS
DI1:	MVI	C,' '
	CALL	LOM		; PRINT SPACE
	MOV	A,M
	CALL	DBYTE		; PRINT DATA
	CALL	HILO		; TEST FOR COMPLETION
	JC	DI2		; RETURN TO MAIN LOOP
	MOV	A,L
	ANI	0FH		; PRINT CR,LF,ADDRESS ON MULTIPLE OF 16
	JNZ	DI1
	JMP	DI0
DI2:	CALL	LCRLF		; WRITE CR,LF
	MVI	C,0
	CALL	LOM		; WRITE A NULL TO TRIGGER CLOSE
	RET
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; END OF FILE COMMAND.
;
; THIS ROUTINE PRODUCES A TERMINATION RECORD WHICH PROPERLY
; COMPLETES A HEXADECIMAL FILE CREATED BY 'W' COMMANDS.  IF
; THE OPTIONAL HEXADECIMAL PARAMETER IS SPECIFIED, A START
; RECORD IS PRODUCED. A SUBSEQUENT 'R' COMMAND WILL LOAD
; THE FILE CREATED AND IF A START RECORD IS ENCOUNTERED,
; THE ENTRY POINT ADDRESS READ WILL REPLACE THE STORED
; VALUE OF THE PROGRAM COUNTER.
;
EOF:	DCR	C		; GET ONE PARAMETER
	CALL	EXPR
	CALL	POC
	DB	':'		; OUTPUT RECORD MARK
	XRA	A		; ZERO CHECKSUM
	MOV	D,A
	CALL	PBYTE		; OUTPUT RECORD LENGTH
	POP	H		; RETRIEVE PARAMETER
	CALL	PADR		; OUTPUT IT.
	MVI	A,1		; RECORD TYPE
	CALL	PBYTE		; OUTPUT IT.
	XRA	A
	SUB	D		; COMPUTE CHECKSUM
	CALL	PBYTE		; OUTPUT IT.
	JMP	NU0		; PUNCH TRAILER AND RETURN
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; FILL RAM MEMORY BLOCK WITH CONSTANT.
;
; THIS ROUTINE EXPECTS THREE HEXADECIMAL PARAMETERS, THE
; FIRST AND SECOND (16 BITS) ARE INTERPRETED AS THE BOUNDS
; OF A MEMORY AREA TO BE INITIALIZED TO A CONSTANT VALUE,
; THE THIRD PARAMETER (8 BITS) IS THAT VALUE.
;
FILL:	INR	C		; GET 3 PARAMETERS
	CALL	EXPR
	POP	B		; GET DATA IN C
	POP	D		; GET HIGH ADDRESS
	POP	H		; GET LOW ADDRESS
FI0:	MOV	M,C		; STORE CONSTANT IN MEMORY
	CALL	HILO		; TEST FOR COMPLETION
	JNC	FI0		; CONTINUE LOOPING
	RET
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; GO TO <ADDRESS>, OPTIONALLY SET BREAKPOINTS.
;
; THE G COMMAND IS USED FOR TRANSFERRING CONTROL FROM THE
; MONITOR TO A USER PROGRAM.  IT HAS SEVERAL MODES OF
; OPERATION.
;
; IF ONE HEXADECIMAL PARAMETER IS ENTERED, IT IS INTERPRETED
; AS THE ENTRY POINT OF THE USER PROGRAM AND A TRANSFER TO
; THAT LOCATION IS EXECUTED.
;
; IF ADDITIONAL (UP TO 2) PARAMETERS ARE ENTERED, THESE ARE
; CONSIDERED 'BREAKPOINTS', I.E., LOCATIONS WHERE
; CONTROL IS TO BE RETURNED TO THE MONITOR, IF THEY ARE
; ENCOUNTERED.
;
; IF THE FIRST PARAMETER IS NOT ENTERED, THE STORED VALUE
; OF THE USER'S PROGRAM COUNTER (REGISTER P) IS USED AS
; THE USER PROGRAM ENTRY POINT.
;
GOTO:	GET	EXIT		; POINT RETURN ADDRESS AT USER CODE
	XTHL			; REPLACE RETURN TO COMMAND LOOP
	CALL	PCHK		; GET A CHARACTER, SET Z,C
	JZ	GO0		; DON'T MODIFY PC
	CALL	PA0		; GET NEW PC VALUE
	XCHG			; DE = NEW PC
	GET	PLOC
	MOV	M,D		; STORE MODIFIED PC IN RAM
	DCX	H
	MOV	M,E
GO0:	JC	GO4		; NO TRAPS TO BE SET
	LXI	D,2		; SET COUNTER(S), D=0, E=2
GO1:	CALL	COMC		; ISSUE A PROMPT FOR A TRAP
	DB	'-'
	CALL	PARAM		; GET A TRAP
	PUSH	H		; STACK IT
	INR	D		; UP 1 COUNTER
	JC	GO2		; TERMINATE IF CR ENTERED
	DCR	E		; DOWN THE OTHER
	JNZ	GO1		; GET ONE MORE TRAP
GO2:	JNC	ERROR		; LAST TRAP NOT FOLLOWED BY CR
	GET	TLOC		; LOCATE TRAP AREA
GO3:	POP	B		; GET ONE TRAP
	MOV	M,C		; STORE TRAP ADDRESS IN TRAP AREA
	INX	H
	MOV	M,B
	INX	H
	LDAX	B		; FETCH OPCODE BYTE
	MOV	M,A		; PUT IN TRAP AREA
	INX	H
	MVI	A,0C7H		; SET TRAP OPCODE (RST 0)
	STAX	B
	DCR	D
	JNZ	GO3
GO4:	CALL	CRLF
	RET
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; COMPUTE HEXADECIMAL SUM AND DIFFERENCE.
;
; THIS ROUTINE EXPECTS TWO HEXADECIMAL PARAMETERS.
; IT COMPUTES THE SUM AND DIFFERENCE OF THE TWO VALUES
; AND DISPLAYS THEM ON THE CONSOLE DEVICE AS FOLLOWS:
;
; <P1+P2> <P1-P2>
;
HEXN:	CALL	EXPR		; GET TWO NUMBERS
	CALL	CRLF
	POP	D
	POP	H
	PUSH	H
	DAD	D		; COMPUTE HL+DE
	CALL	LADR		; DISPLAY SUM
	CALL	BLK		; TYPE A SPACE
	POP	H
	MOV	A,L		; COMPUTE HL-DE
	SUB	E
	MOV	L,A
	MOV	A,H
	SBB	D
	MOV	H,A
	CALL	LADR		; DISPLAY DIFFERENCE
	RET
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; LOAD A BNPF TAPE INTO RAM MEMORY.
;
; THIS ROUTINE EXPECTS TWO HEXADECIMAL PARAMETERS AND
; INTERPRETS THEM AS BOUNDS FOR A MEMORY AREA TO BE
; LOADED BY BNPF DATA TO BE READ FROM THE READER.
; IT IS ASSUMED THAT ENOUGH DATA IS AVAILABLE IN THE
; TAPE TO BE READ TO SATISFY THE MEMORY BOUNDS ENTERED.
; IF END OF TAPE IS ENCOUNTERED BEFORE THE MEMORY BOUNDS
; ARE SATISFIED, THIS ROUTINE WILL TERMINATE ON AN ERROR
; CONDITION (SEE RIX), BUT ALL DATA READ BEFORE THE END
; OF TAPE WAS ENCOUNTERED WILL BE LOADED.
;
LOAD:	CALL	EXPR		; GET TWO ADDRESSES
	POP	D		; GET HIGH ADDRESS
	POP	H		; GET LOW ADDRESS
LO0:	CALL	RIX		; READ TAPE
	CPI	'B'		; SCAN FOR 'B'
	JNZ	LO0
	MVI	M,1		; INITIALIZE MEMORY
LO1:	CALL	RIX		; GET DATA
	CPI	'N'		; CHECK FOR 'N'
	JZ	LO2		; FOUND IT, CARRY = 0
	ADI	-'P'
	JNZ	ERROR		; ERROR
				; CARRY IS SET
LO2:	MOV	A,M		; SHIFT IN DATA BIT
	RAL
	MOV	M,A
	JNC	LO1		; IF CARRY IS SET, 8 BITS READ
	CALL	RIX		; TEST FOR REQ'D 'F'
	CPI	'F'
	JNZ	ERROR
	CALL	HILO		; TEST FOR COMPLETION
	JNC	LO0		; KEEP GOING
	RET
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; MOVE A BLOCK OF MEMORY.
;
; THIS ROUTINE EXPECTS THREE HEXADECIMAL PARAMETERS FROM THE
; CONSOLE.  THE FIRST AND SECOND PARAMETERS ARE THE BOUNDS OF
; THE MEMORY AREA TO BE MOVED, THE THIRD PARAMETER IS THE
; STARTING ADDRESS OF THE DESTINATION AREA.
;
MOVE:	INR	C		; GET THREE ADDRESSES
	CALL	EXPR
	POP	B		; DESTINATION
	POP	D		; SOURCE END
	POP	H		; SOURCE BEGIN
MV0:	MOV	A,M		; GET A DATA BYTE
	STAX	B		; STORE AT DESTINATION
	INX	B		; MOVE DESTINATION POINTER
	CALL	HILO		; TEST FOR COMPLETION
	JNC	MV0
	RET
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; PUNCH LEADER OR TRAILER.
;
; THIS ROUTINE PUNCHES 60 NULL CHARACTERS ON THE DEVICE ASSIGNED
; AS THE PUNCH.  IT IS BRANCHED TO BY THE 'B' AND 'E' COMMANDS
; AS WELL AS BEING INVOKED BY THE 'N' COMMAND.
;
NULL:	CALL	TI		; REQUIRE CR
	CPI	CR
	JNZ	ERROR
NU0:	CALL	LEAD
	CALL	POC
	DB	0
	RET
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; DRIVER PROGRAM FOR INTELLEC 80 PROM PROGRAMMING PERIPHERAL.
;
; THIS ROUTINE EXPECTS (1) AN OPTION CHARACTER (X,Y,Z)
; WHICH SPECIFIES WHICH SOCKET OPTION IS SELECTED, (2) A
; TRUE/FALSE CHARACTER (T OR F) WHICH SPECIFIES IF A DATA
; INVERSION IS TO TAKE PLACE, AND (3) THREE HEXADECIMAL
; PARAMETERS, THE FIRST TWO OF WHICH ARE INTERPRETED AS THE
; MEMORY AREA TO BE USED AS THE PROGRAMMING SOURCE DATA,
; THE THIRD ADDRESS IS THE FIRST ADDRESS IN THE PROM. NO
; TIMING IS PERFORMED BY THIS ROUTINE, ALL PROM DEPENDENT
; TIMING IS HANDLED BY THE PERIPHERAL. UPON RECEIPT OF AN
; ERROR STATUS FROM THE DEVICE, THIS ROUTINE DISPLAYS THE
; ADDRESS WHICH FAILED TO PROGRAM AND TERMINATES WITH AN
; ERROR CONDITION.
;
PROG:	CALL	SELECT		; SELECT SOCKET
	PUSH	B		; SAVE PROM OPCODE
	MVI	C,3		; GET THREE PARAMETERS
	CALL	EXPR
	CALL	CRLF
	POP	B		; PROM ADDRESS
	POP	D		; HIGH ADDRESS
	POP	H		; LOW ADDRESS
	MVI	A,0FH
	ANA	B		; MASK 4 MSB OF B
	MOV	B,A
	POP	PSW		; OPCODE IS IN A
	ORA	B
	MOV	B,A		; BC CONTAINS PROM OPCODE AND ADDRESS
PR0:	MOV	A,B		; OUTPUT PROM ADDRESS AND OPCODE
	OUT	PHI
	MOV	A,C
	OUT	PLO
	INX	B		; INCREMENT PROM ADDRESS
	LDA	MSK		; FETCH T/F FLAG
	XRA	M		; XOR DATA FROM MEMORY
	OUT	PDATA		; OUTPUT PROM DATA
PR1:	IN	PSTAT
	ANI	PGRDY		; TEST FOR COMPLETION
	JNZ	PR1
	IN	PSTAT
	ANI	PCOMP
	JZ	PR2		; PROGRAMMING ERROR, ABORT
	CALL	HILO		; TEST FOR PROGRAMMING COMPLETION
	JNC	PR0
	RET			; RETURN TO COMMAND MODE
PR2:	CALL	LADR		; DISPLAY BAD ADDRESS
	JMP	ERROR
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; SYSTEM QUERY COMMAND.
;
; THIS COMMAND IS INVOKED BY TYPING THE LETTER Q. THIS
; COMMAND PRODUCES A LISTING OF LOGICAL I/O DEVICES AND
; THEIR CORRESPONDING PHYSICAL DEVICE ASSIGNMENTS. THE
; DATA DISPLAYED IS EQUIVALENT TO THE CURRENT VALUE OF IOBYT.
;
QUERY:	CALL	TI		; REQUIRE CR
	CPI	CR
	JNZ	ERROR
	MVI	B,4		; SET UP OUTER LOOP COUNTER.
	LXI	H,LTBL		; POINT HL AT LOGICAL DEVICE TABLE.
Q0:	CALL	CRLF		; START A NEW LINE.
	MOV	C,M		; DISPLAY LOGICAL DEVICE IDENTIFIER.
	CALL	COM
	CALL	COMC		; DISPLAY '='.
	DB	'='
	INX	H		; POINT AT MASK FOR LOGICAL DEVICE.
	MOV	A,M		; FETCH MASK.
	CMA			; INVERT IT
	MOV	C,A		; PUT IN C
	INX	H		; POINT AT PHYSICAL DEVICE TABLE
	MOV	E,M		; ADDRESS OF SUBORDINATE
	INX	H		; TABLE
	MOV	D,M
	INX	H
	XCHG			; HL <- PHYSICAL DEVICE TABLE
	LDA	IOBYT
	ANA	C		; PHYSICAL SELECTION
	PUSH	B		; SAVE OUTER LOOP COUNTER
	MVI	B,4		; SET UP INNER LOOP COUNTER
Q1:	MOV	C,M		; GET PHYSICAL DEVICE IDENTIFIER
	INX	H
	CMP	M		; TEST FOR EQUALITY
	JZ	Q2
	INX	H		; POINT AT NEXT ENTRY
	DCR	B		; DECREMENT INNER LOOP
	JNZ	Q1
Q2:	CALL	COM		; DISPLAY PHYSICAL DEVICE
	XCHG			; POINT AT MASTER TABLE
	POP	B
	DCR	B		; DECREMENT OUTER LOOP
	JNZ	Q0
	RET
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; READ ROUTINE.
;
; THIS ROUTINE READS A HEXADECIMAL FILE FROM THE ASSIGNED
; READER DEVICE AND LOADS IT INTO MEMORY.  ONE HEXADECIMAL
; PARAMETER IS EXPECTED.  THIS PARAMETER IS A BASE ADDRESS
; TO BE ADDED TO THE MEMORY ADDRESS OF EACH DATA BYTE ENCOUNTERED.
; IN THIS WAY, HEXADECIMAL FILES MAY BE LOADED INTO MEMORY
; IN AREAS OTHER THAN THAT FOR WHICH THEY WERE ASSEMBLED OR COMPILED.
; ALL RECORDS READ ARE CHECKSUMMED AND COMPARED AGAINST THE
; CHECKSUM IN THE RECORD. IF A CHECKSUM ERROR (OR TAPE READ ERROR)
; OCCURS, THE ROUTINE TAKES AN ERROR EXIT.  NORMAL LOADING IS
; TERMINATED WHEN AN EOF RECORD IS ENCOUNTERED. THE LOAD
; ADDRESS FIELD REPLACES THE USER'S STORED PC VALUE.
; A TRANSFER TO THE PROGRAM MAY THEN BE ACCOMPLISHED BY A 'G<CR>'.
;
READ:	DCR	C		; GET ONE ADDRESS
	CALL	EXPR
	CALL	CRLF
RED0:	CALL	RIX
	CPI	':'
	JNZ	RED0		; SCAN TO RECORD MARK
	XRA	A
	MOV	D,A		; CLEAR CHECKSUM
	CALL	BYTE
	JZ	RED3		; ZERO RECORD LENGTH, ALL DONE
	MOV	E,A		; E <- RECORD LENGTH
	CALL	BYTE		; GET MSB OF LOAD ADDRESS
	MOV	H,A
	CALL	BYTE		; GET LSB OF LOAD ADDRESS
	MOV	L,A
	CALL	BYTE		; GET RECORD TYPE
	MOV	C,E		; C <- RECORD LENGTH
	PUSH	H
	FETCH	-256		; COMPUTE BUFFER POINTER
RED1:	CALL	BYTE		; READ DATA
	MOV	M,A		; PUT IN BUFFER
	INX	H
	DCR	E
	JNZ	RED1		; LOOP UNTIL DONE
	CALL	BYTE		; READ CHECKSUM
	JNZ	ERROR		; CHECKSUM ERROR
	POP	D		; DE = LOAD ADDRESS
	XTHL			; HL = BIAS ADDRESS, TOS = BUFFER
	XCHG			; DE = BIAS ADDRESS, HL = LOAD ADDRESS
	DAD	D		; HL = BIAS + LA
	MVI	B,0
	DAD	B		; HL = BIAS + LA + RL
	XCHG			; DE = BIAS + LA + RL, HL = BIAS
	XTHL			; HL = BUFFER, TOS = BIAS
RED2:	DCX	H		; DECREMENT BUFFER POINTER
	MOV	A,M
	DCX	D		; DECREMENT MEMORY POINTER
	STAX	D		; PUT DATA IN DESIGNATED ADDRESS
	DCR	C		; UNTIL COUNT IS EXHAUSTED
	JNZ	RED2
	JMP	RED0		; GET ANOTHER RECORD

RED3:	GET	PLOC		; POINT HL AT PC UPPER
	CALL	BYTE		; GET MSB OF TRANSFER ADDRESS
	MOV	M,A
	DCX	H		; POINT HL AT PC LOWER
	CALL	BYTE
	MOV	M,A
	POP	H
	RET
;;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; SUBSTITUTE MEMORY CONTENTS ROUTINE.
;
; THIS ROUTINE EXPECTS ONE PARAMETER FROM THE CONSOLE, FOLLOWED
; BY A SPACE. THE PARAMETER IS INTERPRETED AS A MEMORY LOCATION
; AND THE ROUTINE WILL DISPLAY THE CONTENTS OF THAT LOCATION,
; FOLLOWED BY A DASH (-).  TO MODIFY MEMORY, TYPE IN THE NEW DATA
; FOLLOWED BY A SPACE OR A CARRIAGE RETURN. IF NO MODIFICATION
; OF THE LOCATION IS REQUIRED, TYPE ONLY A SPACE OR CARRIAGE RETURN.
; IF A SPACE WAS LAST TYPED, THE NEXT MEMORY LOCATION WILL BE DISPLAYED
; AND MODIFICATION OF IT IS ALLOWED. IF A CARRIAGE RETURN WAS ENTERED,
; THE COMMAND IS TERMINATED.
;
SUBS:	CALL	PARAM		; GET MEMORY ADDRESS
	RC			; CR ENTERED, RETURN TO COMMAND MODE
SU0:	MOV	A,M
	CALL	LBYTE		; DISPLAY DATA
	CALL	COMC
	DB	'-'
	CALL	PCHK
	RC			; CR ENTERED, RETURN TO COMMAND MODE
	JZ	SU1		; SPACE ENTERED, SPACE BY
	XCHG			; SAVE MEMORY ADDRESS
	CALL	PA0		; GET NEW VALUE
	XCHG			; E = VALUE
	MOV	M,E		; STORE NEW VALUE
	RC			; CR ENTERED AFTER VALUE, RETURN
SU1:	INX	H
	JMP	SU0
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; TRANSFER CONTENTS OF A PROM TO MEMORY.
;
; THIS ROUTINE EXPECTS (1) AN OPTION CHARACTER (X,Y,Z)
; WHICH SPECIFIES WHICH SOCKET OPTION IS SELECTED, AND
; (2) TWO HEXADECIMAL PARAMETERS WHICH IT INTERPRETS
; AS THE RAM MEMORY AREA WHERE THE CONTENTS OF THE
; PROM IN THE SELECTED PROGRAMMING SOCKET IS TO BE STORED.
;
TRAN:	CALL	SELECT		; SELECT SOCKET
	MVI	C,0		; BC = PROM ADDRESS + COMMANDS
	PUSH	B		; STACK PROM ADDRESS
	MVI	C,2
	CALL	EXPR		; GET MEMORY AREA
	POP	D		; HIGH ADDRESS
	POP	H		; LOW ADDRESS
	POP	B		; PROM ADDRESS
TR0:	MOV	A,B
	OUT	PHI		; OUTPUT COMMAND AND 4 MSB
	MOV	A,C
	OUT	PLO		; OUTPUT 8 LSB OF ADDRESS
	INX	B
	IN	PDATA
	PUSH	H
	LXI	H,MSK		; FETCH T/F FLAG
	XRA	M
	POP	H
	MOV	M,A		; PUT DATA IN RAM
	IN	PSTAT
	ANI	PCOMP
	JZ	ERROR
	CALL	HILO
	JNC	TR0		; CONTINUE LOOPING
	RET
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; WRITE ROUTINE.
;
; THIS ROUTINE EXPECTS TWO HEXADECIMAL PARAMETERS WHICH ARE
; INTERPRETED AS THE BOUNDS OF A MEMORY AREA TO BE ENCODED
; INTO HEXADECIMAL FORMAT AND PUNCHED ON THE ASSIGNED PUNCH
; DEVICE.
;
WRITE:	CALL	EXPR		; GET ADDRESS RANGE
	CALL	CRLF		; NEW LINE
	POP	D		; HIGH ADDRESS
	POP	H		; LOW ADDRESS
WR0:	CALL	POC		; EMIT RECORD MARK
	DB	':'
	LXI	B,16		; INITIALIZE B=0, C=16
	PUSH	H		; SAVE HL
WR1:	INR	B
	DCR	C
	JZ	WR2		; TERMINATE ON COUNT OF 16 BYTES
	CALL	HILO		; OR END OF RANGE
	JNC	WR1		; WHICHEVER OCCURS FIRST
WR2:	POP	H		; RESTORE LOW ADDRESS
	PUSH	D		; SAVE HIGH ADDRESS
	MVI	D,0		; INITIALIZE CHECKSUM
	MOV	A,B		; PUT RECORD LENGTH IN A
	CALL	PBYTE		; EMIT RECORD LENGTH
	CALL	PADR		; EMIT LOW ADDRESS
	XRA	A		; EMIT RECORD TYPE
	CALL	PBYTE
WR3:	MOV	A,M		; FETCH CODE
	CALL	PBYTE		; EMIT IT
	INX	H		; INCREMENT MEMORY ADDRESS
	DCR	B		; DECREMENT COUNT
	JNZ	WR3
	XRA	A
	SUB	D		; PUNCH -CHECKSUM
	CALL	PBYTE
	POP	D		; RESTORE HIGH ADDRESS
	DCX	H		; BACKUP MEMORY POINTER
	CALL	PEOL		; PUNCH CR,LF
	CALL	HILO		; TEST FOR TERMINATION
	JNC	WR0
	RET
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; EXAMINE AND MODIFY CPU REGISTERS.
;
; THIS ROUTINE ALLOWS THE OPERATOR TO EXAMINE AND/OR MODIFY
; THE CONTENTS OF THE USER PROGRAM'S REGISTERS.  THE REGISTER
; VALUES WERE STORED AS A RESULT OF A PREVIOUS BREAKPOINT AND
; WILL BE RESTORED TO THE USER PROGRAM DURING A SUBSEQUENT 'G'
; COMMAND.
;
X:	LXI	H,ACTBL		; POINT TO ACCESS TABLE
	CALL	PCHK		; GET REGISTER IDENTIFIER
	JC	X5		; IF CARRY = 1, CR ENTERED
	MVI	C,NREGS
X0:	CMP	M
	JZ	X1		; MATCHED REGISTER IDENTIFIER
	INX	H		; POINT TO NEXT TABLE ENTRY
	INX	H
	INX	H
	DCR	C		; DECREMENT REGISTER COUNTER
	JNZ	X0		; TRY AGAIN
	JMP	ERROR		; NOT IN TABLE, ERROR
X1:	CALL	BLK
X2:	CALL	DREG		; DISPLAY THE REGISTER
	CALL	COMC
	DB	'-'		; TYPE PROMPT
	CALL	PCHK		; SKIP IF NULL ENTRY
	RC			; CR ENTERED, RETURN TO COMMAND MODE
	JZ	X4
	PUSH	H		; SAVE POINTER TO ACTBL
	PUSH	B		; SAVE PRECISION
	CALL	PA0		; GET NEW REG VALUE
	MOV	A,L
	STAX	D		; STORE LSB IN REGISTER AREA
	POP	PSW		; RETRIEVE PRECISION (A)
	ORA	A		; SET SIGN
	JM	X3		; 8 BITS ONLY
	INX	D
	MOV	A,H
	STAX	D		; STORE MSB IN REGISTER AREA
X3:	POP	H		; RETRIEVE ACTBL POINTER
X4:	XRA	A
	ORA	M
	RM			; END OF TABLE, RETURN TO COMMAND MODE
	MOV	A,B		; TEST DELIMITER
	CPI	CR
	RZ			; CR ENTERED, RETURN TO COMMAND MODE
	JMP	X2
X5:	CALL	CRLF		; FULL REGISTER DISPLAY
X6:	CALL	BLK		; OUTPUT A SPACE
	XRA	A		; CLEAR A
	ORA	M		; SET CONDITION CODES
	RM			; ALL DONE, RETURN TO COMMAND MODE
	MOV	C,M
	CALL	COM		; PRINT CHARACTER
	CALL	COMC		; PRINT EQUAL SIGN
	DB	'='
	CALL	DREG		; DISPLAY REGISTER CONTENTS
	JMP	X6		; CONTINUE
;
; TABLE FOR ACCESSING REGISTERS
; TABLE CONTAINS:
;	(1) REGISTER IDENTIFIER
;	(2) LOCATION ON STORAGE PAGE
;	(3) PRECISION
;
ACTBL:	DB	'A',	ALOC,	0
	DB	'B',	BLOC,	0
	DB	'C',	CLOC,	0
	DB	'D',	DLOC,	0
	DB	'E',	ELOC,	0
	DB	'F',	FLOC,	0
	DB	'H',	HLOC,	0
	DB	'I',	ILOC,	0
	DB	'L',	LLOC,	0
	DB	'M',	HLOC,	1
	DB	'P',	PLOC,	1
	DB	'S',	SLOC,	1
	DB	-1
NREGS	EQU	($-ACTBL)/3	; LENGTH OF ACCESS TABLE
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; END OF MONITOR COMMANDS, BEGINNING OF I/O SUBROUTINES
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; EXTERNALLY REFERENCED ROUTINE
; CONSOLE INPUT CODE, VALUE RETURNED IN A
; A, FLAGS MODIFIED
; STACK USAGE: 2 BYTES
;
CI:				; CONSOLE INPUT
	LDA	IOBYT		; GET STATUS BYTE
	ANI	NOT CMSK	; GET CONSOLE BITS
	JNZ	CI0		; TEST FOR CRT
TTYIN:	IN	TTS		; TTY STATUS PORT
	ANI	RBR		; CHECK FOR RECEIVE BUFFER READY
	JZ	TTYIN
	IN	TTI		; READ THE CHARACTER
	RET			; RETURN
CI0:	CPI	CCRT		; CONSOLE = CRT?
	JNZ	CI1		; TEST FOR BATCH
CRTIN:	IN	CRTS		; CRT STATUS PORT
	ANI	RBR		; CHECK FOR RECEIVE BUFFER READY
	JZ	CRTIN		; NOT READY, CONTINUE LOOPING
	IN	CRTI		; READ THE CHARACTER
	RET
CI1:	CPI	BATCH
	JZ	RI		; BATCH MODE, INPUT = READER
	MVI	A,CILOC		; USER DEFINE CONSOLE INPUT
	JMP	@USER
;
; TEST FOR OPERATOR INTERRUPTION OF COMMAND
; BY DEPRESSING BREAK KEY
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A - X
;	B -		C -
;	D -		D -
;	H -		H -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE: 4 BYTES
;
BREAK:	CALL	CSTS		; SEE IF A KEY WAS DEPRESSED
	ORA	A
	RZ			; NO CHARACTER READY
	JMP	TI		; GET THE CHARACTER
;
; EXTERNALLY REFERENCED ROUTINE
; READER INPUT CODE
; VALUE RETURNED IN A, AND FLAGS MODIFIED
; STACK USAGE: 8 BYTES
;
RI:				; READER INPUT
	PUSH	H		; SAVE HL
	LXI	H,IOBYT		; POINT HL AT IOBYT
	MOV	A,M
	ANI	NOT RMSK	; READER = PTR?
	JNZ	RI3		; BRANCH TO PTR ROUTINE
	MVI	A,TTYADV	; READER = TTY
	OUT	PTRC
	MVI	H,TOUT		; SET READER TIMEOUT TIMER
RI0:	IN	TTS
	ANI	RBR
	JNZ	RI2		; DATA IS READY
	CALL	DELAY		; DELAY 10 MS
	DCR	H
	JNZ	RI0
RI1:	XRA	A
	STC			; SET CARRY INDICATING EOF
	POP	H
	RET			; RETURN
RI2:	IN	TTI
	ORA	A		; CLEAR CARRY
	POP	H
	RET			; RETURN
RI3:	CPI	RPTR		; PTR ROUTINE
	JNZ	RI6
	MVI	A,PTRADV	; START PTR
	OUT	PTRC
	MVI	H,TOUT		; SET READER TIMEOUT TIMER
RI4:	IN	PTRS
	ANI	PTRDY
	JNZ	RI5
	CALL	DELAY
	DCR	H
	JNZ	RI4
	JMP	RI1
RI5:	IN	PTRI		; GET THE DATA
	ORA	A
	POP	H
	RET			; RETURN
RI6:	POP	H
	CPI	RUSE1
	MVI	A,R1LOC
	JZ	@USER
	MVI	A,R2LOC
;
; USER DEFINED I/O ENTRY POINT TRANSFER LOGIC
;
@USER:	PUSH	H		; SAVE HL, CREATE A STACK ENTRY
	LHLD	MEMTOP
	MOV	L,A
	XTHL
	RET
;
; EXTERNALLY REFERENCED ROUTINE
; CONSOLE OUTPUT CODE, VALUE EXPECTED IN C
; A,FLAGS,C MODIFIED
; STACK USAGE: 2 BYTES
;
BLK:	MVI	C,' '		; PRINT A BLANK
COM:	LDA	IOBYT		; CONSOLE OUTPUT
	ANI	NOT CMSK
	CPI	BATCH		; DON'T HONOR BREAK KEY IN BATCH MODE
	CNZ	BREAK		; TEST FOR BREAK KEY
CO:				; EXTERNAL ENTRY POINT
	LDA	IOBYT		; GET STATUS BYTE
	ANI	NOT CMSK	; GET CONSOLE BITS
	JNZ	CO0		; TEST FOR CRT
TTYOUT:	IN	TTS		; CONSOLE = TTY
	ANI	TRDY
	JZ	TTYOUT		; LOOP UNTIL READY
	MOV	A,C
	OUT	TTO		; OUTPUT CHARACTER
	RET			; RETURN
CO0:	CPI	BATCH
	JZ	LO
	CPI	CCRT		; CONSOLE = CRT?
	MVI	A,COLOC
	JNZ	@USER		; USER DEFINED CONSOLE OUTPUT
CRTOUT:	IN	CRTS		; CONSOLE = CRT
	ANI	TRDY
	JZ	CRTOUT		; LOOP UNTIL READY
	MOV	A,C
	OUT	CRTO
	RET
;
; CONSOLE OUTPUT OF CONSTANT DATA
;
COMC:	XTHL			; GET RETURN ADDRESS
	MOV	C,M		; GET PARAMETER
	INX	H		; BUMP RETURN ADDRESS
	XTHL
	JMP	COM		; OUTPUT IT
;
; EXTERNALLY REFERENCED ROUTINE
; PUNCH OUTPUT CODE, VALUE EXPECTED IN C
; A, FLAGS, AND C MODIFIED
; STACK USAGE: 2 BYTES
;
POC:	XTHL			; PUNCH A CONSTANT
	MOV	C,M
	INX	H
	XTHL
PO:				; PUNCH OUTPUT
	LDA	IOBYT		; GET STATUS BYTE
	ANI	NOT PMSK	; GET PUNCH BITS
	JZ	TTYOUT		; NO, PUNCH = TTY
	CPI	PPTP		; TEST FOR PTP
	JNZ	PO1		; TEST FOR USER DEVICE(S)
PO0:				; PUNCH = PTP
	IN	PTPS		; GET STATUS
	ANI	PTPRY		; CHECK STATUS
	JZ	PO0		; LOOP UNTIL READY
	MOV	A,C
	OUT	PTPO
	MVI	A,PTPADV	; START PUNCH
	OUT	PTRC
	RET
PO1:	CPI	PUSE1
	MVI	A,P1LOC
	JZ	@USER		; USER DEFINED PUNCH 1
	MVI	A,P2LOC
	JMP	@USER		; USER DEFINED PUNCH 2
;
; EXTERNALLY REFERENCED ROUTINE
; LIST OUTPUT CODE
; VALUE EXPECTED IN C, A AND FLAGS MODIFIED
; STACK USAGE: 2 BYTES
;
LOM:	LDA	IOBYT		; LIST OUTPUT
	ANI	NOT CMSK
	CPI	BATCH		; DON'T HONOR BREAK KEY IN BATCH MODE
	CNZ	BREAK		; TEST FOR BREAK KEY
LO:				; LIST OUTPUT
	LDA	IOBYT		; GET STATUS BYTE
	ANI	NOT LMSK	; GET LIST BITS
	JZ	TTYOUT		; LIST = TTY
	CPI	LCRT
	JZ	CRTOUT		; LIST = CRT
	CPI	LUSE		; TEST FOR USER DEFINED LIST DEVICE
	MVI	A,L1LOC
	JZ	@USER		; USER DEFINED LIST
LP0:	IN	LPTS
	ANI	LPTRY
	JZ	LP0
	MOV	A,C
	CMA
	OUT	LPTO
	RET
;
; EXTERNALLY REFERENCED ROUTINE
; CONSOLE INPUT STATUS CODE
; A, FLAGS MODIFIED
; STACK USAGE: 2 BYTES
;
CSTS:				; CONSOLE INPUT STATUS
	LDA	IOBYT		; GET STATUS BYTE
	ANI	NOT CMSK	; CONSOLE = TTY?
	JNZ	CS0		; CONSOLE = CRT
	IN	TTS		; GET TTY STATUS
	JMP	CS1
CS0:	CPI	CCRT
	JNZ	CS3
	IN	CRTS		; GET CRT STATUS
CS1:	ANI	RBR
	MVI	A,FALSE		; RETURN FALSE IF NO DATA AVAILABLE
CS2:	RZ
	CMA
	RET			; RETURN
CS3:	CPI	BATCH
	MVI	A,TRUE
	JZ	CS2
	MVI	A,CSLOC		; USER DEFINE CONSOLE STATUS
	JMP	@USER
;
; EXTERNALLY REFERENCED ROUTINE
; I/O SYSTEM STATUS CODE
; STATUS BYTE RETURNED IN A
; STACK USAGE: 2 BYTES
;
IOCHK:	LDA	IOBYT		; GET STATUS BYTE
	RET			; RETURN
;
; EXTERNALLY REFERENCED ROUTINE
; SET I/O CONFIGURATION
; VALUE EXPECTED IN C, A MODIFIED
; STACK USAGE: 2 BYTES
;
IOSET:	MOV	A,C
	STA	IOBYT		; PUT NEW IOBYT IN MEMORY
	RET			; RETURN
;
; EXTERNALLY REFERENCED ROUTINE
; RETURN ADDRESS OF END OF MEMORY TO USER
; VALUE RETURNED IN (B,A)
; STACK USAGE: 8 BYTES
;
MEMCK:	LDA	MEMTOP+1
	DCR	A
	MOV	B,A
	MVI	A,USER
	RET
;
; EXTERNALLY REFERENCED ROUTINE
; DEFINE USER I/O ENTRY POINTS
; SELECTION CODE IN C
; ENTRY POINT IN D,E
; A, FLAGS MODIFIED
; STACK USAGE: 8 BYTES
;
IODEF:	PUSH	H
	PUSH	B
	GET	XTBL+1
	MOV	A,C
	CPI	UCS+1
	JNC	ERROR		; INVALID SELECTION CODE
	ADD	C		; DOUBLE INDEX
	ADD	C		; TRIPLE INDEX
	MOV	C,A
	MVI	B,0
	DAD	B		; COMPUTE LOCATION OF I/O OPERAND
	MOV	M,E		; STORE BRANCH OPERAND IN INSTRUCTION
	INX	H
	MOV	M,D
	POP	B
	POP	H
	RET
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; END OF I/O SUBROUTINES, BEGINNING OF MONITOR SUBROUTINES
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; READ TWO ASCII CHARACTERS, DECODE INTO 8 BITS BINARY
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A -
;	B -		C -
;	D -		E -
;	H -		L -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
BYTE:	PUSH	B
	CALL	RIX		; READ CHAR FROM TAPE
	CALL	NIBBLE		; CONVERT ASCII TO HEX
	RLC
	RLC
	RLC
	RLC			; SHIFT FOUR PLACES
	MOV	C,A
	CALL	RIX
	CALL	NIBBLE		; GET LOWER NIBBLE
	ORA	C
	MOV	C,A
	ADD	D		; UPDATE CHECKSUM
	MOV	D,A
	MOV	A,C
	POP	B
	RET			; RETURN
;
; CONVERT 4 BIT HEX VALUE TO ASCII CHARACTER
; INPUT = 0...0FH
; OUTPUT = 30H...39H, 41H...46H
;
; REGISTER USAGE
;
; X - MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A - U,X,S
;	B -		C - S
;	D -		E -
;	H -		L -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
CONV:	ANI	0FH		; ONLY 4 LSB ARE SIGNIFICANT
	ADI	90H		; SET UP A SO THAT A-F CAUSE CARRY
	DAA
	ACI	40H		; ADD IN CARRY AND ADJUST UPPER NIBBLE
	DAA
	MOV	C,A
	RET			; RETURN
;
; TYPE CARRIAGE RETURN AND LINE FEED ON CONSOLE
;
CRLF:	CALL	COMC
	DB	CR
	CALL	COMC
	DB	LF
	RET
;
; PRINT CONTENTS OF HL IN HEX ON LIST DEVICE
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A - X
;	B -		C -
;	D -		E -
;	H - U		L - U
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
DADR:	MOV	A,H		; PRINT MSB
	CALL	DBYTE
	MOV	A,L		; PRINT LSB
	JMP	DBYTE
;
; LIST A BYTE ON THE LIST DEVICE AS 2 ASCII CHARACTERS
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A - U,X
;	B -		C - X
;	D -		E -
;	H -		L -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
DBYTE:	PUSH	PSW		; SAVE A COPY OF A
	RRC
	RRC
	RRC
	RRC
	CALL	CONV
	CALL	LOM
	POP	PSW		; RETRIEVE ORIGINAL VALUE
	CALL	CONV
	JMP	LOM
;
; 1.0 MS. DELAY
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A -
;	B -		C -
;	D -		E -
;	H -		L -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
DELAY:	IN	RTC		; LOOP UNTIL REAL TIME
	ANI	RTCS		; CLOCK CHANGES PHASE
	JZ	DELAY
	RET			; RETURN
;
; DISPLAY THE CONTENTS OF A USER REGISTER
;
; HL POINTS TO CHARACTER IN ACTBL,
; RETURNS POINTING TO NEXT CHARACTER
; DE IS RETURNED WITH ADDRESS OF REGISTER LOCATION
; B IS RETURNED WITH THE REGISTER PRECISION
;
DREG:	INX	H
	MOV	E,M		; INCREMENT HL TO POINT AT DISPLACEMENT
	LDA	MEMTOP+1	; LOCATE REGISTER CONTENTS
	MOV	D,A		; IN TOP OF MEMORY
	INX	H
	MOV	B,M		; PRECISION, 0=8 BITS, 1=16 BITS
	INX	H		; POINT AT NEXT REGISTER IDENTIFIER
	LDAX	D		; 8/16 BIT DISPLAY AND MODIFICATION
	CALL	LBYTE		; MSB OF 16 BIT REG, ALL OF 8 BIT REG
	DCR	B		; TEST PRECISION
	RM			; 8 BIT DISPLAY, RETURN
	DCX	D
	LDAX	D
	JMP	LBYTE		; LSB OF 16 BIT REG
;
; EVALUATE EXPRESSION: <EXPR>,<EXPR>,<EXPR>
;
; THE C REGISTER CONTAINS THE NUMBER OF PARAMETERS REQUIRED
; (1, 2, OR 3).  PARAMETERS ARE RETURNED ON THE STACK.
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A -
;	B -		C -
;	D -		E -
;	H -		L -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
EXPR:	CALL	PARAM		; GET A PARAMETER
	XTHL			; GET RETURN ADDRESS OFF STACK,
				; PUT HL ON
	PUSH	H		; REPLACE RETURN ADDRESS
	DCR	C		; DECREMENT COUNT
	JNC	EX0		; COMMA ENTERED
	JNZ	ERROR		; INCORRECT PARAM COUNT
	RET
EX0:	JNZ	EXPR		; GET ANOTHER PARAMETER
	JMP	ERROR		; NOT TERMINATED WITH CR
;
; COMPARE HL WITH DE:
; IF HL <= DE THEN CARRY = 0;
; IF HL > DE THEN CARRY = 1;
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S : SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U : USED AS INPUT.
;
;	A -
;	B -		C -
;	D -		E -
;	H -		H -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
HILO:	INX	H		; BUMP HL
	MOV	A,H		; TEST FOR HL = 0
	ORA	L
	STC
	RZ
	MOV	A,E		; DE = HL, SET/RESET CARRY
	SUB	L
	MOV	A,D
	SBB	H
	RET			; RETURN
;
; CONVERT NIBBLE IN A-REGISTER TO ASCII IN A-REGISTER
; AND PRINT ON CONSOLE DEVICE
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A -
;	B -		C -
;	D -		E -
;	H -		L -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
HXD:	CALL	CONV
	JMP	COM
;
; PRINT CONTENTS OF HL IN HEX ON CONSOLE DEVICE
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A -
;	B -		C -
;	D -		E -
;	H -		L -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
LADR:	MOV	A,H		; PRINT MSB
	CALL	LBYTE
	MOV	A,L		; PRINT LSB
	JMP	LBYTE
;
; LIST A BYTE AS 2 ASCII CHARACTERS
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A -
;	B -		C -
;	D -		E -
;	H -		L -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
LBYTE:	PUSH	PSW		; SAVE A COPY OF A
	RRC
	RRC
	RRC
	RRC
	CALL	HXD
	POP	PSW		; RETRIEVE ORIGINAL VALUE
	JMP	HXD
;
; PRINT CR, LF ON LIST DEVICE
;
LCRLF:	MVI	C,CR
	CALL	LOM
	MVI	C,LF
	JMP	LOM
;
; PUNCH 6 INCHES OF LEADER
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A - X
;	B - X		C - X
;	D -		E -
;	H -		L -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
LEAD:	MVI	B,60		; SET TO PUNCH 6 INCHES OF NULLS
LE0:	CALL	POC
	DB	0
	DCR	B
	JNZ	LE0
	RET			; RETURN
;
; COLLECT A HEXADECIMAL PARAMETER
;
PARAM:	CALL	PCHK		; GET FIRST CHARACTER
	JZ	ERROR		; DISALLOW NULL PARAMETERS
PA0:	LXI	H,0		; CLEAR ACCUMULATOR
PA1:	MOV	B,A		; SAVE DELIMITER CHARACTER
	CALL	NIBBLE		; CONVERT TO HEX
	JC	PA2		; NOT LEGAL CHAR, TREAT AS DELIMITER
	DAD	H		; *2
	DAD	H		; *4
	DAD	H		; *8
	DAD	H		; *16
	ORA	L
	MOV	L,A
	CALL	TI		; GET SUBSEQUENT CHARACTERS
	JMP	PA1		; DECODE NEXT CHARACTER
PA2:	MOV	A,B
	CALL	P2C
	JNZ	ERROR
	RET
;
; DECODE ASCII CHAR IN A-REGISTER INTO HEX DIGIT IN A-REGISTER
; FILTER OUT ALL CHARACTERS NOT IN THE SEQUENCE (0...9,A...F).
; RETURN CARRY = 1 FOR ILLEGAL CHARACTERS.
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A -
;	B -		C -
;	D -		E -
;	H -		L -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
NIBBLE:	SUI	'0'
	RC			; FILTER OUT 0-2FH
	ADI	'0'-'G'
	RC			; FILTER OUT 47H-0FFH
	ADI	6
	JP	NI0		; TAKE BRANCH FOR A-F
	ADI	7
	RC			; FILTER OUT 3AH-40H
NI0:	ADI	10
	ORA	A		; CLEAR ERROR FLAG
	RET			; RETURN
;
; PUNCH CONTENTS OF HL IN HEX ON PUNCH DEVICE
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A -
;	B -		C -
;	D -		E -
;	H -		L -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
PADR:	MOV	A,H
	CALL	PBYTE
	MOV	A,L
	JMP	PBYTE
;
; PUNCH A BYTE AS 2 ASCII CHARACTERS
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A -
;	B -		C -
;	D -		E -
;	H -		L -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
PBYTE:	MOV	E,A		; SAVE VALUE
	RRC
	RRC
	RRC
	RRC
	CALL	CONV
	CALL	PO
	MOV	A,E
	CALL	CONV
	CALL	PO
	MOV	A,E
	ADD	D
	MOV	D,A
	RET			; RETURN
;
; TEST FOR NULL INPUT PARAMETER
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A -
;	B -		C -
;	D -		E -
;	H -		L -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
PCHK:	CALL	TI		; GET A CHARACTER
P2C:	CPI	' '
	RZ
	CPI	','
	RZ
	CPI	CR
	STC
	RZ
	CMC
	RET
;
; PUNCH CR, LF
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A -
;	B -		C -
;	D -		E -
;	H -		L -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
PEOL:	CALL	POC
	DB	CR
	CALL	POC
	DB	LF
	RET
;
; RESTART 2 CODE, (PROGRAMMED BREAKPOINT).
;
; THIS ROUTINE IS ENTERED VIA A RESTART 0 (RST 0) INSTRUCTION.
; THE INSTRUCTION IS ENCOUNTERED EITHER IN THE USER PROGRAM (AS
; A BREAKPOINT) OR IS INPUT VIA A CONSOLE INTERRUPT.  THIS
; ROUTINE SAVES THE STATE OF THE CALLING PROCESS AND TURNS CONTROL
; OVER TO THE MONITOR.
;
RESTART:
	DI			; DISABLE IF SOFTWARE TRAP
	PUSH	H		; SAVE MACHINE STATE
	PUSH	D
	PUSH	B
	PUSH	PSW
	POP	H		; GET A,F IN H,L
	IN	MASK
	PUSH	PSW		; SAVE INTERRUPT MASK
	PUSH	H		; STACK A,F ABOVE MASK
	MVI	A,NOT INT0
	OUT	MASK		; SET DEFAULT INTERRUPT MASK
	GET	EXIT		; FIND TOP OF MEMORY
	XCHG
	FETCH	12		; COMPUTE ORIGINAL STACK POINTER
	MVI	B,5		; COUNT FOR TRANSFER OF MACHINE STATE
	XCHG			; TO STORAGE (MOVE THE STACK)
RST0:	DCX	H
	MOV	M,D
	DCX	H
	MOV	M,E
	POP	D
	DCR	B
	JNZ	RST0
	POP	B		; GET OLD PC = B,C; OLD HL = D,E
	DCX	B		; DECREMENT TO POINT AT TRAPPED CODE
	SPHL			; NEW STACK VALUE
	GET	TLOC
	MOV	A,M		; TEST IF THIS IS A PROGRAMMED RESTART
	SUB	C		; OR A CONSOLE RESTART
	INX	H
	JNZ	RSTA
	MOV	A,M
	SBB	B
	JZ	RST1		; PC MATCHES TRAP1, PROGRAMMED RESTART
RSTA:	INX	H
	INX	H
	MOV	A,M
	SUB	C
	INX	H
	JNZ	RSTB
	MOV	A,M
	SBB	B
	JZ	RST1		; PC MATCHES TRAP2, PROGRAMMED RESTART
RSTB:	MVI	A,EOI		; END OF INTERRUPT
	OUT	REVRT		; REVERT INTERRUPT SYSTEM
	INX	B		; ADJUST PC FOR CONSOLE RESTART
RST1:	GET	LLOC
	MOV	M,E
	INX	H
	MOV	M,D		; SAVE OLD HL
	MVI	L,PLOC-1
	MOV	M,C		; SAVE OLD PC
	INX	H
	MOV	M,B
	PUSH	B
	CALL	COMC
	DB	'#'
	POP	H		; RETRIEVE OLD PC FOR DISPLAY
	CALL	LADR		; DISPLAY PC
	GET	TLOC		; CLEAR TRAPS
	MVI	D,2		; SET COUNT FOR TWO TRAPS
RST2:	MOV	C,M		; GET LSB OF ADDRESS
	XRA	A
	MOV	M,A
	INX	H
	MOV	B,M		; GET MSB OF ADDRESS
	MOV	M,A
	INX	H
	MOV	A,C
	ORA	B		; TEST FOR VALID TRAP
	JZ	RST3		; ADDRESS = 0, NO TRAP TO RESTORE
	MOV	A,M		; GET OPCODE BYTE
	STAX	B		; REPLACE IT
RST3:	INX	H		; POINT TO NEXT TRAP ADDRESS
	DCR	D
	JNZ	RST2		; REPEAT FOR TRAP 2
	JMP	START		; ENTER MONITOR
;
; GET CHARACTER FROM READER, MASK OFF PARITY BIT
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A -
;	B -		C -
;	D -		E -
;	H -		L -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
RIX:	CALL	RI
	JC	ERROR		; READER TIMEOUT ERROR
	ANI	7FH
	RET			; RETURN
;
; GET A CHARACTER FROM THE CONSOLE DEVICE, ASSUME
; THAT IT'S A SOCKET SELECT OPTION CHARACTER, AND TURN
; IT INTO A SOCKET SELECTION MASK. IF THE CHARACTER IS
; IN ERROR, TAKE THE STANDARD ERROR EXIT.
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A -
;	B -		C -
;	D -		E -
;	H -		L -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
SELECT:	IN	PSTAT		; READ PROM PROGRAMMER STATUS
	ORA	A		; PROM PERIPHERAL CONNECTED?
	JZ	ERROR		; NO, ABORT
	CALL	TI
	CPI	'T'
	JNZ	SE0
	XRA	A
	JMP	SE1
SE0:	CPI	'F'
	JNZ	ERROR
	MVI	A,0FFH
SE1:	STA	MSK
	CALL	TI
	SUI	'X'
	LXI	B,0FFH		; OPTION X SELECTED
	RZ
	DCR	A
	LXI	B,(PSOCK OR PNIB) SHL 8 + 0F0H
	RZ
	DCR	A
	JNZ	ERROR
	LXI	B,PSOCK SHL 8 + 0FH	; OPTION Z SELECTED
	RET
;
; I/O CONTROL ENTRY POINT (LATER EXPANSION)
;
SPCL:	RET
;
; INPUT FROM CONSOLE, ECHOED AND RETURNED IN A
;
; REGISTER USAGE
;
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;
;	A -
;	B -		C -
;	D -		E -
;	H -		L -
;	CARRY - X	ZERO - X
;	SIGN - X	PARITY - X
;	SP -		PC -
;	STACK USAGE:
;
TI:	PUSH	B
	CALL	CI
	ANI	7FH		; MASK PARITY
	CALL	UC		; FORCE UPPER CASE
	CPI	ETX		; TEST FOR BREAK
	JZ	ERROR		; ABORT COMMAND
	MOV	C,A
	CALL	CO		; ECHO
	MOV	A,C
	POP	B
	RET			; RETURN
;
; CONVERT CHARACTER IN A-REG FROM LOWER CASE TO UPPER CASE
;
UC:	CPI	'A'+20H
	RM			; CHAR < LC(A)
	CPI	'Z'+20H+1
	RP			; CHAR > LC(Z)
	ANI	NOT 20H		; FORCE UPPER CASE
	RET
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
; END OF PROGRAM
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
	END
